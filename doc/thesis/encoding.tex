\section{Verification}

The main part of this work is implemented in the \texttt{solve} submodule,
% allowing the verification of concurrent assembly programs by bounded model checking based on register states in our abstract machine model.
% allowing bounded model checking of concurrent assembly programs based on register states in our abstract machine model.
% performing bounded model checking of concurrent software running on our abstract machine model.
allowing verification of concurrent software running on our abstract machine model by the means of bounded model checking \cite{ref:BMC}.
It takes an arbitrary number of programs plus the upper bound as input and encodes them into a finite state machine, expressed as a SMT formula where each transition translates to the execution of a single thread.
SMT-Lib \cite{ref:SMT-Lib} and the novel BTOR2 \cite{ref:BTOR2} word level model checking format can be generated, using the theories of arrays, uninterpreted functions and bitvectors.
To simplify the definition of bad states directly in the program code, the possibility of encountering an exit code greater than zero is checked for per default, but custom properties may be defined in a separate file and added with the \texttt{-c} command line parameter.
The resulting formula is then evaluated by a state-of-the-art solver.
If it is satisfiable, the corresponding execution trace is extracted from the resulting model and stored for later inspection.

% \todo{intro
  % \begin{itemize}
    % \item submodule \texttt{solve}
    % \item verification of assembly programs by bounded model checking based on register states
    % \item property: there exists a trace in which $\mathbf{EG^?F^?}(\EXITCODE \neq 0)$ holds (exists globally)
    % \item using satisfiability modulo theories (arrays and bitvectors)
    % \item problem defined by state and transition variables
    % \item one step corresponds to a specific thread's execution of a single instruction
  % \end{itemize}
% }

\todo[inline]{Basic Definitions? sorts, functions, etc.}

\subsection{Basic Encoding Scheme}

Let $\BVSORT[n]$ be the fixed size bitvector sort of width $n$ and $\ASORT[n]$ the array sort with index and element sorts $\BVSORT[n]$.
The following variables are used to encode the machine state at a particular step $k \in [0, bound] \subset \mathbb{N}$, where $k = 0$ is the initial state.

% \renewcommand{\arraystretch}{1.5}
\setlength{\tabulinesep}{3pt}
\begin{longtabu}{llX}
  \firsthline
  % \textbf{Machine} &&\\
  % \hline
  $\HEAP^k$ & $\in \ASORT$ & shared memory \\
  $\EXIT^k$ & $\in \BVSORT[1]$ & exit flag \\
  $\EXITCODE^k$ & $\in \BVSORT$ & exit code \\
  \hline
  % \textbf{Threads} &&\\
  % \hline
  $\ACCU^k_t$ & $\in \BVSORT$ & accumulator register of thread $t$ \\
  $\MEM^k_t$ & $\in \BVSORT$ & CAS memory register of thread $t$ \\
  $\SBADR^k_t$ & $\in \BVSORT$ & store buffer address register of thread $t$ \\
  $\SBVAL^k_t$ & $\in \BVSORT$ & store buffer value register of thread $t$ \\
  $\SBFULL^k_t$ & $\in \BVSORT[1]$ & store buffer full flag of thread $t$ \\
  $\STMT^k_{t, pc}$ & $\in \BVSORT[1]$ & activation flag for statement at $pc$ of thread $t$ \\
  $\BLOCK^k_{id, t}$ & $\in \BVSORT[1]$ & block flag for checkpoint $id$ of thread $t$ \\
  $\HALT^k_t$ & $\in \BVSORT[1]$ & halt flag of thread $t$ \\
  \lasthline
  \caption{State Variables}
  \label{tbl:states}
\end{longtabu}

\newcommand{\READ}{\texttt{read}}
\newcommand{\WRITE}{\texttt{write}}

% Shared memory is modelled using the array variable $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$ for updating the element at $adr \in \BVSORT$ with a given value $val \in \BVSORT$ in step $k$.
% Shared memory in step $k$ is modelled using the array variable $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving an element and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$, returning an updated version of the shared memory state array with the given element set to a specific value.
Shared memory states are modelled using the array variables $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving an element and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$ returning an updated version of the shared memory state array with the given element set to a specific value.
% Its initial state $\HEAP^0$ may contain input data according to a given memory map, but is assumed to be uninitialized in general.
Register states of a thread $t$ are determined by the bitvector variables $\ACCU^k_t$, $\MEM^k_t$, $\SBADR^k_t$, $\SBVAL^k_t$ and the flag $\SBFULL^k_t$, signalling that the store buffer is full.
%, which are all initially set to zero.
To aid solvers by reducing the formulas complexity, program flow is modelled without an explicit problem counter.
Instead, an activation flag $\STMT^k_{t, pc}$ is added for every statement in the program of thread $t$, expressing that it is about to execute the statement at $pc$.
%To model the program flow without an explicit program counter, an activation flag $\STMT^k_{t, pc}$ is added for every statement in the program of thread $t$, expressing that it is about to execute the statement at $pc$.
Blocking a thread $t$ while it is waiting for all other threads to reach a checkpoint $id$ is achieved by a flag $\BLOCK^k_t$.
% Blocking a thread $t$ while waiting for all other threads to synchronize on a checkpoint $id$ is achieved by the $\BLOCK^k_{id, t}$ state flag.
Similarly, the flag $\HALT^k_t$ indicates that thread $t$ executed a \texttt{HALT} instruction and is therefore also prevented from being scheduled.
% Termination due to an call to \texttt{EXIT}, or because all threads finished executing their programs, or \texttt{EXIT}  is captured by
Termination is captured by the flag $\EXIT^k$ and bitvector variable $\EXITCODE^k$.

% The shared memory state array $\HEAP^0$ may be initialized with input data according to a given memory map, but is assumed to be uninitialized in general.
% All other states are initially set to zero, with the exception of the initial statement activation flag $\STMT^0_{t, 0}$ of every thread $t$.
All states are initially set to zero, except the initial statement activation flag $\STMT^0_{t, 0}$ of every thread $t$ and the shared memory state array $\HEAP^0$, which may be initialized with input data according to a given memory map, but is assumed to be uninitialized in general.

\bigskip

% Constraints for valid machine state transitions of the form $s_k \to^k s_{k + 1}$ are governed by the following variables.
Machine state transitions of the form $s_k \to^k s_{k + 1}$ are governed by the following free variables.
% Machine state transitions of the form $s_k \to^k s_{k + 1}$ are governed by the free variables given in Table \ref{tbl:encoding:transitions}.
% Transitions $s_k \to^k s_{k + 1}$ of a state $s_k$ are governed by the following free variables and are allowed to be chosen non-deterministically.

\begin{longtabu}{llX}
  \firsthline
  $\THREAD^k_t$ & $\in \BVSORT[1]$ & thread $t$ is scheduled to execute an instruction in step $k$ \\
  $\FLUSH^k_t$ & $\in \BVSORT[1]$ & thread $t$ flushes its store buffer in step $k$ \\
  \lasthline
  \caption{Transition Variables}
  \label{tbl:encoding:transitions}
\end{longtabu}

% \todo[inline]{helper variables}
To simplify the definition of successor states, the following helper variables capture frequently used terms.
% The following helper variables are introduced to simplify the latter definition of state transitions by capturing frequently used terms.

\begin{longtabu}{llX}
  \firsthline
  $\EXEC^k_{t, pc}$ & $\in \BVSORT[1]$ & thread $t$ is executing instruction at $pc$ in step $k$ \\
  $\CHECK^k_{id}$ & $\in \BVSORT[1]$ & all threads reached checkpoint $id$ in step $k$ \\
  \lasthline
  \caption{Helper Variables}
\end{longtabu}

% The statement execution variable $\EXEC^k_{t, pc}$,
The actual execution of a specific statement is encoded by $\EXEC^k_{t, pc}$ and
% The actual execution of a statement at $pc$ by thread $t$ in step $k$ is encoded by the execution variable $\EXEC^k_{t, pc}$ and
is defined as a conjunction of the corresponding statement and thread activation variables.

\[
  \EXEC^k_{t, pc} = \STMT^k_{t, pc} \land \THREAD^k_t
\]

Furthermore, we use $\CHECK^k_{id}$ to signal that all threads containing a call to checkpoint $id$, given in the set $C_{id}$, have synchronized.% and the corresponding $\BLOCK^k_{id, t}$ flags set.
\todo[noline]{$C_{id}$ ok?}
% from a set $C_{id}$ of threads containing a call to checkpoint $id$
\[
  \CHECK^k_{id} = \bigwedge_{t \in C_{id}} \BLOCK^k_{id, t}
\]

% \bigskip
\subsubsection{Scheduling}

\newcommand{\CardLt}{\leq^1_n(x_1, \ldots, x_n)}
\newcommand{\CardLtSeq}{\text{LT}^{n, 1}_{\text{SEQ}}}

\newcommand{\ITE}{\texttt{ite}}
\newcommand{\ITEindent}{\;\;\;\;\;\;\;}

% Non-deterministic scheduling of a single thread per step is realized by a boolean cardinality constraint over all $\THREAD^k_t$ and $\FLUSH^k_t$ variables for a number of threads $n$.
Non-deterministic scheduling of at most one thread per step is realized by a boolean cardinality constraint over all transition variables and the exit flag $\EXIT^k$ to ensure satisfiability if the machine terminates in a step $k < bound$.
Let $\CardLt$ be a predicate expressing that at most one out of $n$ variables is allowed to be true.
% The na\"{i}ve way of defining $\leq^1_n(x_1, \ldots, x_n)$ is by explicitly excluding all combinations of two variables being simultaneously true.
The intuitive way of encoding $\CardLt$ is by excluding all combinations of two variables being simultaneously true.
% The traditional way of defining such a constraint is by excluding all combinations of two variables being simultaneously true:
\[
  \bigwedge_{1 \leq i < j \leq n} (\neg x_i \lor \neg x_j)
\]
This na\"ive approach, however, consists of $\binom{n}{2}$ Horn clauses.
% While this na\"ive approach consists of $\binom{n}{2}$ Horn clauses, a more compact formulation, based on a sequential counter circuit, is presented as $\text{LT}^{n, 1}_{\text{SEQ}}$ in \cite{ref:Sinz}.
A more compact formulation, based on a sequential counter circuit computing partial sums $s_i = \sum^i_{j = 1} x_j$ for increasing values of $i$ up to the final $i = n$, is presented as $\CardLtSeq$ in \cite{ref:Sinz} and defined as follows.
% It only requires $3n - 4$ clauses in contrast to the na\"ive approach
% It is based on a sequential counter circuit, only requiring $3n - 4$ clauses, but $n - 1$ additional auxiliary variables.
% Beside this na\"ive approach, consisting of $\binom{n}{2}$ Horn clauses, a more compact formulation with respect to the number of clauses is presented as $\text{LT}^{n, 1}_{\text{SEQ}}$ in \cite{ref:Sinz}.
% This approach consists of $\binom{n}{2}$ Horn clauses.
% consisting of $\binom{n}{2}$ Horn clauses.
% A more compact formulation in terms of the number of clauses, called , based on a sequential counter circuit, is  presented in \cite{ref:Sinz} as $\text{LT}^{n, 1}_{\text{SEQ}}$.
% Cardinality constraint predicate $\leq^1_n(x_1, \ldots, x_n)$ defined as:
\[
  (\neg x_1 \lor s_1) \land (\neg x_n \lor \neg s_{n-1}) \bigwedge_{1 < i < n} \big ( (\neg x_i \lor s_i) \land (\neg s_{i-1} \lor s_i) \land (\neg x_i \lor \neg s_{i-1}) \big )
\]
% $\CardLtSeq$ only requires $3n - 4$ Horn clauses and $n - 1$ additional auxiliary variables.
% It is therefore superior to the na\"ive encoding with regard to the number of clauses for all $n > 5$.
$\CardLtSeq$ is superior to the na\"ive encoding with regard to the number of clauses for all $n > 5$, as it only requires $3n - 4$ Horn clauses and $n - 1$ additional auxiliary variables.
% \todo[inline]{constraint selection}
% Since we need to include two times the number of threads plus one variables in the constraint, the actual definition of $\leq^1_n(x_1, \ldots, x_n)$ is therefore determined by the number of threads involved and the na\"ive encoding only used for up to two threads, $\CardLtSeq$ otherwise.
The actual definition of the at most one constraint predicate $\CardLt$ is therefore determined by the number of threads involved.
Since we have to include two times the number of threads plus one variables in the constraint, the na\"ive encoding is only used for up to two threads and $\CardLtSeq$ otherwise.
% \[
  % \leq^1_n(x_1, \ldots, x_n) \equiv
    % \begin{cases}
      % \CardLtSeq & \text{if } n > 5 \\
      % \text{na\"ive} & \text{otherwise}
    % \end{cases}
% \]
% \todo[inline]{exactly one constraint}
An at most one constraint alone is not sufficient, as we need exactly one transition variable or the exit flag to be true in every step, such that our generated formula is not trivially satisfiable by never scheduling a single thread.
\todo[noline]{stuttering?}
Thus, we define the exactly one constraint predicate $=^1_n\!(x_1, \ldots, x_n)$ by simply adding a disjunction over all variables.% to $\CardLt$.
% The required exactly one constraint predicate $=^1_n(x_1, \ldots, x_n)$ as a conjunction of $\leq^1_n(x_1, \ldots, x_n)$ with a disjunction over all variables
% Let $=^1_n(x_1, \ldots, x_n)$ therefore be an exactly one constraint predicate.
\[
  %=^1_n(x_1, \ldots, x_n) \equiv
  (x_1 \lor \ldots \lor x_n) \; \land \CardLt
  % \CardLt \land (x_1 \lor \ldots \lor x_n)
\]
% \todo[inline]{actual constraint added}
% If we now redeclare $n$ to be the number of threads, the exactly one constraint used for non-deterministic scheduling of a single thread in step $k$ looks as follows.
If we redeclare $n$ as the number of threads, non-deterministic scheduling of a single thread in step $k$ can now be encoded by the following constraint.
% We are now able to state the actual exactly one constraint added to our formula as follows.
\[
  =^1_{2n + 1}\!(\THREAD^k_0, \ldots, \THREAD^k_{n-1}, \FLUSH^k_0, \ldots, \FLUSH^k_{n-1}, \EXIT^k)
\]
% \todo[inline]{scheduling influenced by constraints}
% restrictions by our machine model.
% To comply with our machine model, the cardinality constraint influenced under certain conditions.
% The scheduling constraint is influenced by  certain transitions
% influenced by disabling transition variables under certain conditions.
% to comply with our machine model,
% This cardinality constraint is further influenced by explicitly disabling transitions from certain states in order to meet the requirements of our machine model.

This cardinality constraint is further influenced by explicitly disabling transitions from certain states that are prohibited by our machine model.
% \todo[inline]{store buffer constraints}
% Blocking a thread $t$ not performing a store operation.
% Flushing an empty store buffer of a thread $t$, not containing any barrier \todo{atomic?} operation, can be prevented by a simple implication.
Flushing an empty store buffer of a thread $t$ can be prevented by a simple implication.
\[
  \lnot \SBFULL^k_t \implies \lnot \FLUSH^k_t
\]
% If thread $t$ contains a write together with a barrier operation, execution of the latter has to be restricted while the store is full.
In case thread $t$ containing a write, execution of any barrier operation has to be delayed while the store buffer is full.
% In this case, both mutually exclusive store buffer constraints are combined in a single expression by using
% Both store buffer constraints may be combined in a single expression by using $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$, a functional if-then-else, returning the $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$.
% If a write or barrier operation
% Otherwise,
Let $F_t$ be a set of statements requiring an empty store buffer
and $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$ be a functional if-then-else, returning $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$.
% Let $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$ be a functional if-then-else, returning $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$
\[
  \ITE(x, a, b) =
  \begin{cases}
    a \text{ if } x \text{ is } true \\
    b \text{ otherwise}
  \end{cases}
\]
% Blocking a thread $t$ about to execute a statement that requires the store buffer being empty.
% Set of statements requiring an empty store buffer $F_t$.
Since both store buffer related constraints mainly depend on mutually exclusive values of $\SBFULL^k_t$, we are able to encode them in a single expression.
\[
  \ITE(\SBFULL^k_t, \bigvee_{pc \in F_t} \STMT^k_{t, pc} \implies \lnot \THREAD^k_t, \lnot \FLUSH^k_t)
\]
% \todo[inline]{checkpoint constraints}
% Blocking a thread $t$, while it is waiting for all other threads reaching a checkpoint $id$ is expressed by a conjunction of the corresponding block flag $\BLOCK^k_{id, t}$ and helper variable $\CHECK^k_{id}$ implying a negated thread activation $\THREAD^k_t$.
Blocking a thread $t$, while it is waiting for all other threads reaching a checkpoint $id$ is implied by a conjunction of the corresponding block flag $\BLOCK^k_{id, t}$ and synchronization variable $\CHECK^k_{id}$.
\todo[noline]{unsat if deadlock by CHECK}
\[
  \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id} \implies \lnot \THREAD^k_t
\]
% \todo[inline]{halt constraints}
% Finally, a halted thread $t$ is also excluded from the cardinality constraint by disabling its activation variable.% by a simple implication.
% If a thread $t$ has finally halted, it is also excluded from the cardinality constraint.
Finally, if a thread $t$ has halted, it must also be stopped from being scheduled.
\[
  \HALT^k_t \implies \lnot \THREAD^k_t
\]

\subsubsection{Memory Access}

% \newcommand{\READ}{\texttt{read}}
\newcommand{\LOAD}{\texttt{load}}

% Let $\READ^k: \BVSORT \to \BVSORT$ be a function, returning a given element from array $\HEAP^k$.
% Due to store forwarding in combination with indirect addressing, memory access can not be expressed by simple array lookups, but turns out to be the most complicated part in our encoding scheme.
Due store forwarding, memory access can not be expressed as simple array lookups, but is encoded by a separate function $\LOAD^k_t: \BVSORT \to \BVSORT$ for loading the shared memory element at address $adr \in \BVSORT$ with store forwarding from thread $t$. % and indirect addressing signalled by $indirect \in \BVSORT[1]$, being defined as follows.
\begin{align*}
  \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t \land \SBADR^k_t = adr, \\
  & \SBVAL^k_t, \\
  & \READ^k(adr))
\end{align*}
In case of indirect addressing, $\LOAD^k_t$ is redefined as a single expression instead of a composition with itself to prevent dependency on certain features of the target language or the use of additional auxiliary variables.
\todo[noline]{repeated, iterative, recursive?}
\begin{align}
  \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t, \label{def:load:1} \\
  & \ITE(\SBADR^k_t = adr, \label{def:load:2} \\
  & \ITEindent \ITE(\SBVAL^k_t = adr, \label{def:load:3} \\
  & \ITEindent \ITEindent \SBVAL^k_t, \label{def:load:4} \\
  & \ITEindent \ITEindent \READ^k(\SBVAL^k_t)), \label{def:load:5} \\
  & \ITEindent \ITE(\SBADR^k_t = \READ^k(adr), \label{def:load:6} \\
  & \ITEindent \ITEindent \SBVAL^k_t, \label{def:load:7}\\
  & \ITEindent \ITEindent \READ^k(\READ^k(adr)))), \label{def:load:8} \\
  & \READ^k(\READ^k(adr))) \label{def:load:9}
\end{align}
\todo[noline]{use tabbing evironment?}
First, we check if the store buffer contains an entry and store forwarding might apply (\ref{def:load:1}).
%, or the requested value can be directly retrieved from memory (\ref{def:load:9}).
If it is empty, the requested value has to be directly retrieved from memory (\ref{def:load:9}).
% Otherwise, if the immediate address can be forwarded (\ref{def:load:2}), we must further check if it is equal to the effective address (\ref{def:load:3}) and either both (\ref{def:load:4}), or just the immediate address is forwarded (\ref{def:load:5}).
Otherwise, if the store buffer contains an entry for the given address (\ref{def:load:2}), we must further check if it is equal to the effective address (\ref{def:load:3}) to determine if either both (\ref{def:load:4}), or just the given address can be forwarded (\ref{def:load:5}).
% Otherwise, if the store buffer contains an entry for the immediate address (\ref{def:load:2}), we check if it is equal to the effective address (\ref{def:load:3}) and either return the store buffer value (\ref{def:load:4}) or the element at
% Otherwise, if the store buffer contains an entry for the immediate address (\ref{def:load:2}) and
% Finally, in case the given address could not be forwarded, the store buffer might contain an entry
% Finally, in case the given address was not contained,
Finally, in case there is no entry for the given address,
%we test if and either the effective address can be forwarded (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
the effective address is fetched from memory and compared to the store buffer address (\ref{def:load:6}) to see if it
% can be forwarded (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
% might be subject to store forwarding (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
might be contained (\ref{def:load:7}), or nothing can be forwarded after all (\ref{def:load:8}).
% fetch the effective address from memory and
% or nothing after all.
% and nothing could be forwarded after all.
% If the immediate address cannot be forwarded,

% If store forwaring does not apply because either the store buffer being empty or it neither contains the immediate nor the effective address,
% In case of indirect addressing, we first need to check if the store buffer is full (\ref{def:load:indirect:sbfull}) and the given base address can be forwarded (\ref{def:load:indirect:sbadr}).
% If a value for the base address is contained in the store buffer, we then check if this value

% \begin{align}
  % \LOAD^k_t(adr, indirect) = \ITE(& indirect, \\
  % & \ITE(\SBFULL^k_t, \label{def:load:sbfull} \\
  % & \ITEindent \ITE(\SBADR^k_t = adr, \label{def:load:indirect:sbadr} \\
  % & \ITEindent \ITEindent \ITE(\SBVAL^k_t = adr, \\
  % & \ITEindent \ITEindent \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \ITEindent \ITEindent \READ^k(\SBVAL^k_t)), \\
  % & \ITEindent \ITEindent \ITE(\SBADR^k_t = \READ^k(adr), \\
  % & \ITEindent \ITEindent \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \ITEindent \ITEindent \READ^k(\READ^k(adr)))), \\
  % & \ITEindent \READ^k(\READ^k(adr))), \\
  % & \ITE(\SBFULL^k_t \land \SBADR^k_t = adr, \\
  % & \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \READ^k(adr)))
% \end{align}

% \begin{itemize}
  % \item Nested array lookups if the store buffer is empty and store forwarding does not apply alltogether, or neither the indirect, nor the effective address can be forwarded.
  % \item The value contained in the store buffer if either the effective or both addresses can be forwarded.
% \end{itemize}

% store buffer empty: nested lookup

% \begin{enumerate}
  % \item nothing can be forwarded
  % \item only the indirect address can be forwarded
  % \item only the effective address can be forwarded
  % \item both addresses can be forwarded
% \end{enumerate}

% \[
  % \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t \land \SBADR^k_t = adr, \SBVAL^k_t, \READ^k(adr)))
% \]

% \ref{def:load:sbfull}

% \paragraph{Store Forwarding:} $\sbfull \; \land \; \sbadr = adr \land \accu = \sbval \lor \lnot (\sbfull \land \sbadr = adr)$

% \bigskip
\subsubsection{Frame Axioms}

\newcommand{\TRUE}{\textit{true}}
\newcommand{\FALSE}{\textit{false}}

\newcommand{\EFFECTIVE}{\texttt{effective}}
\newcommand{\MSB}{\texttt{msb}}

\todo[noline]{Successor State Axioms?}\noindent
% The effect of a particular operation, determined by the transition variables $\FLUSH^k_t$ and $\EXEC^k_{t, pc}$
% The effect of a thread $t$ flushing its store buffer or executing the instruction at $pc$ in step $k$
Successor states of transitions for all possible types of operations, determined by $\FLUSH^k_t$ and $\EXEC^k_{t, pc}$, are defined by the frame axioms in the table below.
% \todo[inline]{block}
All state variables, not explicitly altered are assumed to be unchanged in the next step, except the block flags $\BLOCK^{k + 1}_{id, t}$, which are reset if all threads synchronized upon checkpoint $id$.
\[
  \BLOCK^{k + 1}_{id, t} = \ITE(\CHECK^k_{id}, \FALSE, \BLOCK^k_{id, t})
\]
To further simplify the definition of axioms, two additional functions are introduced:
% Let $\EFFECTIVE^k: \BVSORT \to \BVSORT$ be a function for transparently selecting the effective address during $\texttt{STORE}$ or $\texttt{CAS}$ instructions.
$\MSB: \BVSORT \to \BVSORT[1]$ for retrieving the most significant bit of a given bitvector and $\EFFECTIVE^k: \BVSORT \to \BVSORT$ for transparently selecting the effective address during $\texttt{STORE}$ or $\texttt{CAS}$ instructions.
\[
  \EFFECTIVE^k(adr) =
  \begin{cases}
    \READ^k(adr) \text{ if indirect} \\
    adr \text{ otherwise}
  \end{cases}
\]
% and $\MSB: \BVSORT \to \BVSORT[1]$ a function for retrieving the most significant bit of a given bitvector.

% $\SLICE: \BVSORT \times \mathcal{N} \times \mathcal{N} \to \BVSORT[m]$

% \newcommand{\defaxiom}[1]{
    % \vspace{-0.4cm}
    % {\begin{align*}#1\end{align*}}
    % \vspace{-1.3cm}
% }
% \begin{longtabu}{lX[lm]}
  % \firsthline
    % \texttt{FLUSH} &
    % \vspace{-0.4cm}
    % {\begin{align*}
      % \HEAP^{k + 1} &= \WRITE^k(\SBADR^k_t, \SBVAL^k_t) \\
      % \SBFULL^{k + 1}_t &= false \\
    % \end{align*}}
    % \vspace{-1.3cm}
    % \\
  % \hline
  % \texttt{LOAD adr} &
    % \defaxiom{
      % \ACCU^{k + 1}_t &= \LOAD^k_t(\texttt{adr}) \\
      % \STMT^k_{t, pc} &= false \\
      % \STMT^k_{t, pc + 1} &= true \\
    % } \\
  % \hline
  % foo & bar \\
  % \lasthline
  % \caption{Frame Axioms}
  % \label{tbl:axioms}
% \end{longtabu}

% \doublerulesep=6pt
% \arrayrulewidth=1pt
% \doublerulesep=1.5 pt
% \everyrow{\hline\hline}

% \newcommand{\defaxiom}[2]{
  % \paragraph{#1} ~\\
  % \rule[0.5\baselineskip]{\textwidth}{0.1pt}\vspace{-1\baselineskip}\par\noindent
  % #2
% }

% \newpage
% \defaxiom
% {\texttt{FLUSH}}
% {
  % \begin{itemize}
    % \item[] $\HEAP^{k + 1} = \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$
    % \item[] $\SBFULL^{k + 1} = false$
  % \end{itemize}
% }

% \defaxiom
% {\texttt{LOAD arg}}
% {
  % \begin{itemize}
    % \item[] $\ACCU^{k + 1}_t = \LOAD^k_t(\texttt{adr})$
    % \item[] $\STMT^k_{t, pc} = false$
    % \item[] $\STMT^k_{t, pc + 1} = true$
  % \end{itemize}
% }

% \defaxiom
% {\texttt{STORE arg}}
% {
  % \begin{itemize}
    % \item[] $\SBADR^{k + 1}_t =
      % \begin{cases}
        % \READ^k(adr) \text{ if indirect} \\
        % adr \text{ otherwise}
      % \end{cases}$
    % \item[] $\SBVAL^{k + 1}_t = \ACCU^k_t$
    % \item[] $\STMT^k_{t, pc} = false$
    % \item[] $\STMT^k_{t, pc + 1} = true$
  % \end{itemize}
% }

% \newsavebox{\STORESBADRAXIOM}
% \savebox{\STORESBADRAXIOM}{
  % \hspace{-0.3cm}
  % $\begin{cases}
    % \READ^k(adr) \text{ if indirect} \\
    % adr \text{ otherwise}
  % \end{cases}$
% }

\newsavebox{\CASHEAPAXIOM}
\savebox{\CASHEAPAXIOM}{
  \hspace{-0.3cm}
  % $\begin{cases}
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
      % & \WRITE^k(\READ^k(\texttt{arg}), \ACCU^k_t), \\
      % & \HEAP^k)
    % \end{aligned}
    % \hspace{0.2cm}
    % \text{if indirect} \\
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
      % & \WRITE^k(\texttt{arg}, \ACCU^k_t), \\
      % & \HEAP^k)
    % \end{aligned}
    % \hspace{1.5cm}
    % \text{otherwise}
  % \end{cases}$

  $\begin{aligned}
    \ITE(& \MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), \\
    & \WRITE^k(\EFFECTIVE^k(\texttt{arg}), \ACCU^k_t), \\
    & \HEAP^k)
  \end{aligned}$
}

\newsavebox{\CASACCUAXIOM}
\savebox{\CASACCUAXIOM}{
  \hspace{-0.3cm}
  % $\begin{cases}
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
      % & 1, \\
      % & 0)
    % \end{aligned}
    % % \ITE(\MEM^k_t = \READ^k(\READ^k(\texttt{arg})), 1, 0)
    % \hspace{0.2cm}
    % \text{if indirect} \\
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
      % & 1, \\
      % & 0) \\
    % \end{aligned}
    % % \ITE(\MEM^k_t = \READ^k(\texttt{arg}), 1, 0)
    % \hspace{1.5cm}
    % \text{otherwise}
  % \end{cases}$

  $\begin{aligned}
    \ITE(& \MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), \\
    & 1, \\
    & 0)
  \end{aligned}$

  % $\ITE(\MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), 1, 0)$
}

% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\mybox} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
    % \lasthline
% \end{longtabu}

% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2}{*}{\texttt{FLUSH}}
    % & $\HEAP^{k + 1}$       & $= \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$ \\
    % & $\SBFULL^{k + 1}$     & $= false$ \\
  % \lasthline
% \end{longtabu}
% \vspace{-0.9cm}
% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{3}{*}{\texttt{LOAD adr}}
    % & $\ACCU^{k + 1}_t$     & $= \LOAD^k_t(\texttt{adr})$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  % \lasthline
% \end{longtabu}
% \vspace{-0.9cm}
% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\mybox} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  % \lasthline
% \end{longtabu}

% \setlength{\tabulinesep}{2pt}
% \setlength{\doublerulesep}{4pt}
\begin{longtabu}{llX[m]}
  \firsthline
  \multirow{2}{*}{\texttt{FLUSH}}
    & $\HEAP^{k + 1}$   & $= \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$ \\
    & $\SBFULL^{k + 1}$ & $= \FALSE$ \\
  \hline
  % \hhline{===}
  % \tabucline[2pt off 2pt]{-}
  \multirow{3.05}{*}{\texttt{LOAD arg}}
    & $\ACCU^{k + 1}_t$           & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \hhline{===}
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\STORESBADRAXIOM} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  \multirow{4}{*}{\texttt{STORE arg}}
    & $\SBADR^{k + 1}_t$          & $= \EFFECTIVE^k(\texttt{arg})$ \\
    & $\SBVAL^{k + 1}_t$          & $= \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \hhline{===}
  \multirow{2}{*}{\texttt{FENCE}}
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\texttt{ADD arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t + \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\texttt{ADDI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t + \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\texttt{SUB arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\texttt{SUBI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\texttt{MUL arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t * \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \newpage
  \hline
  \multirow{3.05}{*}{\texttt{MULI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t * \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3}{*}{\texttt{CMP arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{2}{*}{\texttt{JMP arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \TRUE$ \\
  \hline
  \multirow{3}{*}{\texttt{JZ arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \lnot \ACCU^k_t$ \\
  \hline
  \multirow{3}{*}{\texttt{JNZ arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \ACCU^k_t$ \\
  \hline
  \multirow{3}{*}{\texttt{JS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \MSB(\ACCU^k_t)$ \\
  \hline
  \multirow{3}{*}{\texttt{JNS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \lnot \MSB(\ACCU^k_t)$ \\
  \hline
  \multirow{3}{*}{\texttt{JNZNS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \ACCU^{k + 1}_t \lor \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \ACCU^{k + 1}_t \land \lnot \MSB(\ACCU^k_t)$ \\
  \hline
  \multirow{4}{*}{\texttt{MEM arg}}
    & $\ACCU^{k + 1}_t$           & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\MEM^{k + 1}_t$            & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + k}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \multirow{2.35}{*}{\texttt{CAS arg}}
  \multirow{2.97}{*}{\texttt{CAS arg}}
    & $\HEAP^{k + 1}$             & $=$ \usebox{\CASHEAPAXIOM} \\
    & $\ACCU^{k + 1}_t$           & $=$ \usebox{\CASACCUAXIOM} \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{2}{*}{\texttt{HALT}}
    % & $\EXIT^{k + 1}_t$ & $= \HALT^{k + 1}_0 \land \ldots \land \HALT^{k + 1}_{n - 1}$ \\
    & $\EXIT^{k + 1}_t$       & $= \displaystyle \bigwedge^{n - 1}_{i = 0} \HALT^{k + 1}_i$ \\
    & $\HALT^{k + 1}_t$       & $= \TRUE$ \\
    & $\STMT^{k + 1}_{t, pc}$ & $= \FALSE$ \\
  \hline
  \multirow{3}{*}{\texttt{EXIT arg}}
    & $\EXIT^{k + 1}_t$       & $= \TRUE$ \\
    & $\EXITCODE^{k + 1}$     & $= \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$ & $= \FALSE$ \\
  \hline
  \multirow{3}{*}{\texttt{CHECK arg}}
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
    & $\BLOCK^{k + 1}_{arg, t}$   & $= \TRUE$ \\
  \lasthline
  \caption{Frame Axioms}
  \label{tbl:axioms}
\end{longtabu}

% \vspace{0.2cm}
% \hlinE
% \VSPACE{0.1CM}
% \NOINDENT
% \BEGIN{TABU} TO \TEXTWIDTH {Lx[M]}
  % $\heap^{K + 1}$       & $= \write^K(\sbadr^K_T, \sbval^K_T)$ \\
  % $\sbfull^{K + 1}$     & $= FALSE$ \\
% \END{TABU}

% \PARAGRAPH{\TEXTTT{flush}}

% \VSPACE{0.2CM}
% \HLINE
% \VSPACE{0.1CM}
% \NOINDENT
% \BEGIN{TABU} TO \TEXTWIDTH {Lx[M]}
  % $\heap^{K + 1}$       & $= \write^K(\sbadr^K_T, \sbval^K_T)$ \\
  % $\sbfull^{K + 1}$     & $= FALSE$ \\
% \END{TABU}

% \[
% \texttt{compare}^k_t(adr) =
% \begin{cases}
  % \MEM^k_t = \READ^k(\READ^k(adr)) \text{ if indirect} \\
  % \MEM^k_t = \READ^k(adr) \text{ otherwise}
% \end{cases}
% \]

% $\HEAP^{k + 1} =
% \begin{cases}
  % \begin{aligned}
    % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
    % & \WRITE^k(\READ^k(\texttt{arg}), \ACCU^k_t) \\
    % & \HEAP^k)
  % \end{aligned}
  % \text{ if indirect} \\
  % \begin{aligned}
    % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
    % & \WRITE^k(\texttt{arg}, \ACCU^k_t) \\
    % & \HEAP^k)
  % \end{aligned}
  % \text{ otherwise}
% \end{cases}$

% Let $\texttt{define-accu}(k, t, pc)$ be the predicate defining the accumulator register state $\ACCU^k_t$ of thread $t$ in step $k$ and $pc$ the set of program counters, altering that state.% \todonote{refine}

% \paragraph{\texttt{LOAD adr}}

% \subsubsection{Statement Activation}

% \setlength{\tabulinesep}{2\lineskip}

\newpage
\subsection{SMT-Lib}

\todo[inline]{Pseudo\texttt{++}}

% \DontPrintSemicolon
\SetAlgoVlined
% \SetAlgoNoLine

% default style
\SetKwProg{Fn}{function}{}{end}

% C-style
% \SetStartEndCondition{ (}{) }{)}\SetAlgoBlockMarkers{\{}{\}}%
% \AlgoDisplayBlockMarkers\SetAlgoNoLine%
% \SetKwProg{Fn}{}{}{}
% \SetKwIF{If}{ElseIf}{Else}{if}{}{elif}{else}{}%

% alternative C-Style
% \SetStartEndCondition{ (}{)}{)}\SetAlgoBlockMarkers{}{\}}%
% \SetKwProg{Fn}{}{ \{}{}\SetKwFunction{FRecurs}{void FnRecursive}%
% \SetKwFor{For}{for}{ \{}{}%
% \SetKwIF{If}{ElseIf}{Else}{if}{ \{}{else if}{else \{}{}%
% \SetKwFor{While}{while}{ \{}{}%
% \SetKwRepeat{Repeat}{repeat\{}{until}%
% \AlgoDisplayBlockMarkers\SetAlgoNoLine%

% standard library functions
\SetKwFunction{ToString}{str}
\SetKwFunction{Append}{<<}

% global variables %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SetKwData{Formula}{formula}
\SetKwData{EOL}{eol}

\SetKwFunction{DeclareStates}{declare_states}
\SetKwFunction{DeclareTransitions}{declare_transitions}
\SetKwFunction{DefineTransitions}{define_transitions}
\SetKwFunction{InitStates}{init_states}
\SetKwFunction{DefineConstraints}{define_constraints}
\SetKwFunction{DefineStates}{define_states}

% macros
\newcommand{\IterateThreads}[1]{\ForEach{thread t}{#1}}
\newcommand{\IteratePrograms}[1]{\ForEach{thread t}{\ForEach{statement at pc}{#1}}}
\newcommand{\IterateCheckpoints}[1]{\ForEach{checkpoint id}{\ForEach{thread t containing a call to id}{#1}}}

% programs
\noindent
\begin{minipage}{.3\textwidth}
  \lstinputlisting[
    language={[concubine]Assembler},
    numbers=left,
    firstnumber=0,
    numberstyle=\footnotesize,
    xleftmargin=0.39\textwidth
  ]{../../examples/demo/processor.0.asm}
\end{minipage}
\begin{minipage}{.3\textwidth}
  \lstinputlisting[
    language={[concubine]Assembler},
    numbers=left,
    firstnumber=0,
    numberstyle=\footnotesize,
    xleftmargin=0.39\textwidth
  ]{../../examples/demo/processor.1.asm}
\end{minipage}
\begin{minipage}{.3\textwidth}
  \lstinputlisting[
    language={[concubine]Assembler},
    numbers=left,
    firstnumber=0,
    numberstyle=\footnotesize,
    xleftmargin=0.39\textwidth
  ]{../../examples/demo/checker.asm}
\end{minipage}

% \noindent
% \begin{tabu}{|X|X|X|}
  % \hline
  % \textbf{Thread 0} & \textbf{Thread 1} & \textbf{Thread 2} \\
  % \hline
  % \texttt{ADDI 1}   & \texttt{ADDI 1}   & \\
  % \texttt{STORE 0}  & \texttt{STORE 1}  & \\
  % \texttt{LOAD 1}   & \texttt{LOAD 0}   & \\
  % \texttt{CHECK 0}  & \texttt{CHECK 0}  & \texttt{CHECK 0} \\
  % \texttt{HALT}     & \texttt{HALT}     & \texttt{ADD 0} \\
  % && \texttt{ADD 1} \\
  % && \texttt{JZ error} \\
  % && \texttt{EXIT 0} \\
  % && \texttt{error:} \texttt{EXIT 1} \\
  % \hline
% \end{tabu}

\noindent
\begin{tabu}{|X|X|X|}
  \firsthline
  \centering \textbf{Thread 0} & \centering \textbf{Thread 1} & \centering \textbf{Thread 2} \\
  \hline
  \hline
  \begin{tabu}{lX}
    0 & \lstinline[language={[concubine]Assembler}]{ADDI 1} \\
    1 & \lstinline[language={[concubine]Assembler}]{STORE 0} \\
    2 & \lstinline[language={[concubine]Assembler}]{LOAD 1} \\
    3 & \lstinline[language={[concubine]Assembler}]{CHECK 0} \\
    4 & \lstinline[language={[concubine]Assembler}]{HALT} \\
  \end{tabu}
  &
  \begin{tabu}{lX}
    0 & \lstinline[language={[concubine]Assembler}]{ADDI 1} \\
    1 & \lstinline[language={[concubine]Assembler}]{STORE 1} \\
    2 & \lstinline[language={[concubine]Assembler}]{LOAD 0} \\
    3 & \lstinline[language={[concubine]Assembler}]{CHECK 0} \\
    4 & \lstinline[language={[concubine]Assembler}]{HALT} \\
  \end{tabu}
  &
  \begin{tabu}{lX}
    & \\
    & \\
    & \\
    0 & \lstinline[language={[concubine]Assembler}]{CHECK 0} \\
    1 & \lstinline[language={[concubine]Assembler}]{ADD 0} \\
    2 & \lstinline[language={[concubine]Assembler}]{ADD 1} \\
    3 & \lstinline[language={[concubine]Assembler}]{JZ error} \\
    4 & \lstinline[language={[concubine]Assembler}]{EXIT 0} \\
    5 & \lstinline[language={[concubine]Assembler}]{error: EXIT 1} \\
  \end{tabu} \\
  \lasthline
\end{tabu}

\subsubsection{types}
\todo[inline]{types} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
enum State {
  heap,
  accu,
  mem,
  sb_adr,
  sb_val,
  sb_full
}
\end{lstlisting}

\subsubsection{globals}
\todo[inline]{gobal variables} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
// SMT formula buffer
//
ostringstream formula;

// initial memory layout
//
map<uint, uint> mmap = {{0, 0}, {1, 0}};

// bound
//
size_t bound = 17;

// list of programs being encoded (index == thread id)
//
vector<vector<Instruction *>> programs = {
  {
    new Addi(1),
    new Store(0),
    new Load(1),
    new Check(0),
    new Halt()
  },
  {
    new Addi(1),
    new Store(1),
    new Load(0),
    new Check(0),
    new Halt()
  },
  {
    new Check(0),
    new Add(0),
    new Add(1),
    new Jz(5),
    new Exit(0),
    new Exit(1)
  }
};

// pcs of statements altering a specific state
//
// State -> thread -> list of program counters
//
std::map<State, std::map<uint, std::vector<uint>>> alters = {
  { State::accu, {
    {0, {0, 2}},
    {1, {0, 2}},
    {2, {1, 2}}
  }},
  { State::sb_adr, {
    {0, {1}},
    {1, {1}}
  }},
  { State::sb_val, {
    {0, {1}},
    {1, {1}}
  }},
  { State::sb_full, {
    {0, {1}},
    {1, {1}}
  }}
};

// list of predecessors for each thread
//
// thread -> pc -> set of predecessors
//
vector<unordered_map<uint, set<uint>>> predecessors = {
  {{0, {}}, {1, {0}}, {2, {1}}, {3, {2}}, {4, {3}}},
  {{0, {}}, {1, {0}}, {2, {1}}, {3, {2}}, {4, {3}}},
  {{0, {}}, {1, {0}}, {2, {1}}, {3, {2}}, {4, {3}}, {5, {3}}}
};

// pcs of statements requiring an empty store buffer
//
// thread -> list of program counters
//
map<uint, vector<uint>> flushes = {{0, {1, 4}}, {1, {1, 4}}};

// pcs of checkpoint statements
//
// checkpoint id -> thread -> list of program counters
//
map<uint, map<uint, vector<uint>>> checkpoints = {
  {0, {{0, {3}}, {1, {3}}, {2, {0}}}}
};

// pcs of halt statements
//
// thread -> list of program counters
//
map<uint, vector<uint>> halts = {{0, {4}}, {1, {4}}};

// pcs of exit calls
//
// thread -> list of program counters
//
map<uint, vector<uint>> exits = {{2, {4, 5}}};
\end{lstlisting}

\subsubsection{main encoding function}
\todo[inline]{main encoding function} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{Encode}{encode}
\begin{algorithm}[H]
  \Fn{\Encode{}}{
    \Formula \Append \texttt{"(set-logic QF_AUFBV)"} \Append \EOL \Append \EOL\;
    ~\\
    \For{$k = 0$ \KwTo $bound$}{
      \DeclareStates{k}\;
      \DeclareTransitions{}\;
      \DefineTransitions{}\;
      \DefineConstraints{}\;
      ~\\
      \If{$k > 0$}{
        \DefineStates{}\;
      } \Else {
        \InitStates{}\;
      }
    }
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
void encode ()
{
  formula << "(set-logic QF_AUFBV)" << eol << eol;

  for (step = 0, prev = -1; step <= bound; step++, prev++)
    {
      declare_states();
      declare_transitions();
      define_transitions();
      define_constraints ();

      if (step)
        define_states();
      else
        init_states();
    }
}
\end{lstlisting}

\subsubsection{declare states}
\todo[inline]{declare states} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{DeclareAccu}{declare_accu}
\SetKwFunction{DeclareMem}{declare_mem}
\SetKwFunction{DeclareSBAdr}{declare_sb_adr}
\SetKwFunction{DeclareSBVal}{declare_sb_val}
\SetKwFunction{DeclareSBFull}{declare_sb_full}
\SetKwFunction{DeclareStmt}{declare_stmt}
\SetKwFunction{DeclareBlock}{declare_block}
\SetKwFunction{DeclareHalt}{declare_halt}
\SetKwFunction{DeclareHeap}{declare_heap}
\SetKwFunction{DeclareExitFlag}{declare_exit_flag}
\SetKwFunction{DeclareExitCode}{declare_exit_code}

\begin{algorithm}[H]
  \Fn{\DeclareStates{k}}{
    \tcc{declare thread state variables}
    \DeclareAccu{k}\;
    \DeclareMem{}\;
    \DeclareSBAdr{}\;
    \DeclareSBVal{}\;
    \DeclareSBFull{}\;
    \DeclareStmt{}\;
    \DeclareBlock{}\;
    \DeclareHalt{}\;
    ~\\
    \tcc{declare machine state variables}
    \DeclareHeap{}\;
    \DeclareExitFlag{}\;
    ~\\
    \If{$k = 0$}{
      \DeclareExitCode{}\;
    }
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
void declare_states ()
{
  // thread states
  declare_accu();
  declare_mem();
  declare_sb_adr();
  declare_sb_val();
  declare_sb_full();
  declare_stmt();
  declare_block();
  declare_halt();

  // machine states
  declare_heap();
  declare_exit_flag();

  if (!step)
    declare_exit_code();
}
\end{lstlisting}

\subsubsection{declare accu}
\todo[inline]{declare accu} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{DeclareBV}{declare_bv_var}
\begin{algorithm}[H]
  \Fn{\DeclareBV{name}}{
    \Return \texttt{"(declare-fun "} + \ArgSty{name} + \texttt{" () (_ BitVec 16))"}\;
  }
\end{algorithm}

\SetKwFunction{AccuVar}{accu_var}
\begin{algorithm}[H]
  \Fn{\AccuVar{k, t}}{
    \Return \texttt{"accu_"} + \ToString{k} + \texttt{"_"} + \ToString{t}\;
  }
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareAccu{k}}{
    \IterateThreads{
      \Formula \Append \DeclareBV{\AccuVar{k, t}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
string declare_bv_var (string name)
{
  return "(declare-fun " + name + " () (_BitVec 16))";
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string var (std::string name, std::vector<uint> attributes)
{
  for (const auto & attr : attributes)
    (name += '_') += std::to_string(attr);

  return name;
}
\end{lstlisting}

% return "accu_" + std::to_string(k) + '_' + std::to_string(t);
\begin{lstlisting}[
  style=c++,
  morekeywords={std::string, std::to_string},
]
std::string accu_var (int k, int t) { return var("accu", {k, t}); }
\end{lstlisting}

\begin{lstlisting}[style=c++]
template <class Functor>
void iterate_threads (const Functor & fun)
{
  for (thread = 0; thread < programs->size(); thread++)
    fun();
}

void declare_accu (int k)
{
  iterate_threads([] {
    formula << declare_bv_var(accu_var(k, t)) << eol;
  });
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_accu (int k)
{
  for (int t = 0; t < programs.size(); t++)
    formula << declare_bv_var(accu_var(k, t)) << eol;
  formula << eol;
}
\end{lstlisting}

% \lstinputlisting[language=SMTLib, linerange={9-12}]{../../examples/demo/formula.functional.smt2}
\begin{lstlisting}[language=SMTLib]
; accu variables - accu_<step>_<thread>
(declare-fun accu_0_0 () (_ BitVec 16))
(declare-fun accu_0_1 () (_ BitVec 16))
(declare-fun accu_0_2 () (_ BitVec 16))
\end{lstlisting}

\subsubsection{declare mem}
\todo[inline]{declare mem} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Symbol generator for $\MEM^k_t$

\SetKwFunction{MemVar}{mem_var}
\begin{algorithm}[H]
  \Fn{\MemVar{k, t}}{
    \Return \texttt{"mem_"} + \ToString{k} + \texttt{"_"} + \ToString{t}\;
  }
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareMem{k}}{
    \IterateThreads{
      \Formula \Append \DeclareBV{\MemVar{k, t}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
std::string mem_var (uint k, uint t) { return var("mem", {k, t}); }
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_mem (uint k)
{
  for (word t = 0; t < programs.size(); t++)
    formula << declare_bv_var(mem_var(k, t)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; mem variables - mem_<step>_<thread>
(declare-fun mem_0_0 () (_ BitVec 16))
(declare-fun mem_0_1 () (_ BitVec 16))
(declare-fun mem_0_2 () (_ BitVec 16))
\end{lstlisting}

\subsubsection{declare sb-adr}
\todo[inline]{declare sb-adr} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{SBAdrVar}{sb_adr_var}
\begin{algorithm}[H]
  \Fn{\SBAdrVar{k, t}}{\Return \texttt{"sb-adr_"} + \ToString{k} + \texttt{"_"} + \ToString{t}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareSBAdr{k}}{
    \IterateThreads{
      \Formula \Append \DeclareBV{\SBAdrVar{k, t}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[language=SMTLib]
; store buffer address variables - sb-adr_<step>_<thread>
(declare-fun sb-adr_0_0 () (_ BitVec 16))
(declare-fun sb-adr_0_1 () (_ BitVec 16))
(declare-fun sb-adr_0_2 () (_ BitVec 16))
\end{lstlisting}

\subsubsection{declare sb-val}
\todo[inline]{declare sb_val} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{SBValVar}{sb_val_var}
\begin{algorithm}[H]
  \Fn{\SBValVar{k, t}}{\Return \texttt{"sb-val_"} + \ToString{k} + \texttt{"_"} + \ToString{t}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareSBVal{k}}{
    \IterateThreads{
      \Formula \Append \DeclareBV{\SBValVar{k, t}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[language=SMTLib]
; store buffer value variables - sb-val_<step>_<thread>
(declare-fun sb-val_0_0 () (_ BitVec 16))
(declare-fun sb-val_0_1 () (_ BitVec 16))
(declare-fun sb-val_0_2 () (_ BitVec 16))
\end{lstlisting}

\subsubsection{declare sb-full}
\todo[inline]{declare sb_full} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{DeclareBool}{declare_bool_var}
\begin{algorithm}[H]
  \Fn{\DeclareBool{name}}{
    \Return \texttt{"(declare-fun "} $+$ \ArgSty{name} $+$ \texttt{" () Bool)"}\;
  }
\end{algorithm}

\SetKwFunction{SBFullVar}{sb_full_var}
\begin{algorithm}[H]
  \Fn{\SBFullVar{k, t}}{\Return \texttt{"sb-full_"} + \ToString{k} + \texttt{"_"} + \ToString{t}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareSBFull{k}}{
    \IterateThreads{
      \Formula \Append \DeclareBool{\SBFullVar{k, t}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[language=SMTLib]
; store buffer full variables - sb-full_<step>_<thread>
(declare-fun sb-full_0_0 () Bool)
(declare-fun sb-full_0_1 () Bool)
(declare-fun sb-full_0_2 () Bool)
\end{lstlisting}

\subsubsection{declare stmt}
\todo[inline]{declare stmt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{StmtVar}{stmt_var}
\begin{algorithm}[H]
  \Fn{\StmtVar{k, t, pc}}{\Return \texttt{"stmt_"} + \ToString{k} + \texttt{"_"} + \ToString{t} + \texttt{"_"} + \ToString{pc}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareStmt{k}}{
    \IteratePrograms{
      \Formula \Append \DeclareBool{\StmtVar{k, t, pc}} \Append \EOL\;
      % \Formula \\
      % \Indp \Append \DeclareBool{\StmtVar{k, t, pc}} \\
      % \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\noindent
\begin{tabu}{|XX[r]|XX[r]|lr|}
  \hline
  \multicolumn{2}{|c|}{\textbf{Thread 0}} & \multicolumn{2}{c|}{\textbf{Thread 1}} & \multicolumn{2}{c|}{\textbf{Thread 2}} \\
  \hline
  \texttt{ADDI 1}   & $\STMT^k_{0, 0}$  & \texttt{ADDI 1}   & $\STMT^k_{1, 0}$  && \\
  \texttt{STORE 0}  & $\STMT^k_{0, 1}$  & \texttt{STORE 1}  & $\STMT^k_{1, 1}$  && \\
  \texttt{LOAD 1}   & $\STMT^k_{0, 2}$  & \texttt{LOAD 0}   & $\STMT^k_{1, 2}$  && \\
  \texttt{CHECK 0}  & $\STMT^k_{0, 3}$  & \texttt{CHECK 0}  & $\STMT^k_{1, 3}$  & \texttt{CHECK 0} & $\STMT^k_{2, 0}$ \\
  \texttt{HALT}     & $\STMT^k_{0, 4}$  & \texttt{HALT}     & $\STMT^k_{1, 4}$  & \texttt{ADD 0}         & $\STMT^k_{2, 1}$ \\
  &&&& \texttt{ADD 1}         & $\STMT^k_{2, 2}$ \\
  &&&& \texttt{JZ error}      & $\STMT^k_{2, 3}$ \\
  &&&& \texttt{EXIT 0}        & $\STMT^k_{2, 4}$ \\
  &&&& \texttt{error:} \texttt{EXIT 1} & $\STMT^k_{2, 5}$ \\
  \hline
\end{tabu}

\begin{lstlisting}[style=c++]
std::string stmt_var (uint k, uint t, uint pc)
{
  return var("stmt", {k, t, pc});
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_stmt (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    for (uint pc = 0; pc < programs[t].size(); pc++)
      formula << declare_bv_var(stmt_var(k, t, pc)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; statement activation variables - stmt_<step>_<thread>_<pc>
(declare-fun stmt_0_0_0 () Bool)
(declare-fun stmt_0_0_1 () Bool)
(declare-fun stmt_0_0_2 () Bool)
(declare-fun stmt_0_0_3 () Bool)
(declare-fun stmt_0_0_4 () Bool)

(declare-fun stmt_0_1_0 () Bool)
(declare-fun stmt_0_1_1 () Bool)
(declare-fun stmt_0_1_2 () Bool)
(declare-fun stmt_0_1_3 () Bool)
(declare-fun stmt_0_1_4 () Bool)

(declare-fun stmt_0_2_0 () Bool)
(declare-fun stmt_0_2_1 () Bool)
(declare-fun stmt_0_2_2 () Bool)
(declare-fun stmt_0_2_3 () Bool)
(declare-fun stmt_0_2_4 () Bool)
(declare-fun stmt_0_2_5 () Bool)
\end{lstlisting}

\subsubsection{declare block}
\todo[inline]{declare block} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{BlockVar}{block_var}
\begin{algorithm}[H]
  \Fn{\BlockVar{k, id, t}}{\Return \texttt{"block_"} + \ToString{k} + \texttt{"_"} + \ToString{id} + \texttt{"_"} + \ToString{t}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareBlock{k}}{
    \IterateCheckpoints{
      \Formula \Append \DeclareBool{\BlockVar{k, id, t}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
std::string block_var (uint k, uint id, uint t)
{
  return
    "block_" +
    std::to_string(k) + '_' +
    std::to_string(id) + '_' +
    std::to_string(tid);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string block_var (uint k, uint id, uint t)
{
  return var("block", {k, id, t});
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_block (int k)
{
  for (const auto & [id, threads] : checkpoints)
    {
      for (const auto & [t, _] : threads)
        formula << declare_bool_var(block_var(k, id, t)) << eol;

      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; blocking variables - block_<step>_<id>_<thread>
(declare-fun block_0_0_0 () Bool)
(declare-fun block_0_0_1 () Bool)
(declare-fun block_0_0_2 () Bool)
\end{lstlisting}

\subsubsection{declare halt}
\todo[inline]{declare halt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{HaltVar}{halt_var}
\begin{algorithm}[H]
  \Fn{\HaltVar{k, t}}{\Return \texttt{"halt_"} + \ToString{k} + \texttt{"_"} + \ToString{t}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareHalt{k}}{
    \todo[noline]{skip if there are no halts?}
    \IterateThreads{
      \Formula \Append \DeclareBool{\HaltVar{k, t}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
std::string halt_var (uint k, uint t) { return var("halt", {k, t}); }
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_halt (int k)
{
  for (const auto & [t, _] : halts)
    formula << declare_bool_var(halt_var(k, t)) << eol;

  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; halt variables - halt_<step>_<thread>
(declare-fun halt_0_0 () Bool)
(declare-fun halt_0_1 () Bool)
(declare-fun halt_0_2 () Bool)
\end{lstlisting}

\subsubsection{declare heap}
\todo[inline]{declare heap} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{DeclareArray}{declare_array_var}
\begin{algorithm}[H]
  \Fn{\DeclareArray{name}}{
    % \Return \texttt{"(declare-fun "} $+$ \ArgSty{name} $+$ \texttt{" (Array (\_ BitVec 16) (\_ BitVec 16)))"}\;
    \begin{tabbing}
      \Return \=\texttt{"(declare-fun "} \\
      \> $+$ \ArgSty{name} \\
      \> $+$ \texttt{" (Array (\_ BitVec 16) (\_ BitVec 16)))"}\;
    \end{tabbing}
    \vspace{-1\baselineskip}
  }
\end{algorithm}

\SetKwFunction{HeapVar}{heap_var}
\begin{algorithm}[H]
  \Fn{\HeapVar{k, t}}{\Return \texttt{"heap_"} + \ToString{k}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareHeap{k}}{
    \Formula \Append \DeclareArray{\HeapVar{k}} \Append \EOL \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[language=SMTLib]
; heap variable - heap_<step>
(declare-fun heap_0 () (Array (_ BitVec 16) (_ BitVec 16)))
\end{lstlisting}

\subsubsection{declare exit-flag}
\todo[inline]{declare exit-flag} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{ExitFlagVar}{exit_flag_var}
\begin{algorithm}[H]
  \Fn{\ExitFlagVar{k}}{\Return \texttt{"exit_"} + \ToString{k}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareExitFlag{k}}{
    \Formula \Append \DeclareBool{\ExitFlagVar{k}} \Append \EOL \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[language=SMTLib]
; exit flag variable - exit_<step>
(declare-fun exit_0 () Bool)
\end{lstlisting}

\subsubsection{declare exit-code}
\todo[inline]{declare exit-code} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{ExitCodeVar}{exit_code_var}
\begin{algorithm}[H]
  \Fn{\ExitCodeVar{}}{\Return \texttt{"exit_code"}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareExitCode{}}{
    \Formula \Append \DeclareBool{\ExitCodeVar{}} \Append \EOL \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[language=SMTLib]
; exit code variable
(declare-fun exit-code () (_ BitVec 16))
\end{lstlisting}

\subsubsection{declare transitions}
\todo[inline]{declare transitions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{DeclareThread}{declare_thread}
\SetKwFunction{DeclareExec}{declare_exec}
\SetKwFunction{DeclareFlush}{declare_flush}
\SetKwFunction{DeclareCheck}{declare_check}

\begin{algorithm}[H]
  \Fn{\DeclareTransitions{k}}{
    \DeclareThread{k}\;
    \DeclareExec{}\;
    \DeclareFlush{}\;
    \DeclareCheck{}\;
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
void declare_transitions (int k)
{
  declare_thread(k);
  declare_exec(k);
  declare_flush(k);
  declare_check(k);
}
\end{lstlisting}

\subsubsection{declare thread}
\todo[inline]{declare thread} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{ThreadVar}{thread_var}
\begin{algorithm}[H]
  \Fn{\ThreadVar{k, t}}{\Return \texttt{"thread_"} + \ToString{k} + \texttt{"_"} + \ToString{t}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareThread{k}}{
    \IterateThreads{
      \Formula \Append \DeclareBool{\ThreadVar{k, t}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[language=SMTLib]
; thread activation variables - thread_<step>_<thread>
(declare-fun thread_0_0 () Bool)
(declare-fun thread_0_1 () Bool)
(declare-fun thread_0_2 () Bool)
\end{lstlisting}

\subsubsection{declare exec}
\todo[inline]{declare exec} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{ExecVar}{exec_var}
\begin{algorithm}[H]
  \Fn{\ExecVar{k, t, pc}}{\Return \texttt{"exec_"} + \ToString{k} + \texttt{"_"} + \ToString{t} + \texttt{"_"} + \ToString{pc}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareExec{k}}{
    \IteratePrograms{
      \Formula \Append \DeclareBool{\ExecVar{k, t, pc}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[language=SMTLib]
; statement execution variables - exec_<step>_<thread>_<pc>
(declare-fun exec_0_0_0 () Bool)
(declare-fun exec_0_0_1 () Bool)
(declare-fun exec_0_0_2 () Bool)
(declare-fun exec_0_0_3 () Bool)
(declare-fun exec_0_0_4 () Bool)

(declare-fun exec_0_1_0 () Bool)
(declare-fun exec_0_1_1 () Bool)
(declare-fun exec_0_1_2 () Bool)
(declare-fun exec_0_1_3 () Bool)
(declare-fun exec_0_1_4 () Bool)

(declare-fun exec_0_2_0 () Bool)
(declare-fun exec_0_2_1 () Bool)
(declare-fun exec_0_2_2 () Bool)
(declare-fun exec_0_2_3 () Bool)
(declare-fun exec_0_2_4 () Bool)
(declare-fun exec_0_2_5 () Bool)
\end{lstlisting}

\subsubsection{declare flush}
\todo[inline]{declare flush} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{FlushVar}{flush_var}
\begin{algorithm}[H]
  \Fn{\FlushVar{k, t}}{\Return \texttt{"flush_"} + \ToString{k} + \texttt{"_"} + \ToString{t}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareFlush{k}}{
    \IterateThreads{
      \Formula \Append \DeclareBool{\FlushVar{k, t}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[language=SMTLib]
; store buffer flush variables - flush_<step>_<thread>
(declare-fun flush_0_0 () Bool)
(declare-fun flush_0_1 () Bool)
(declare-fun flush_0_2 () Bool)
\end{lstlisting}

\subsubsection{declare check}
\todo[inline]{declare check} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{CheckVar}{check_var}
\begin{algorithm}[H]
  \Fn{\CheckVar{k, id}}{\Return \texttt{"check_"} + \ToString{k} + \texttt{"_"} + \ToString{id}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DeclareFlush{k}}{
    \ForEach{checkoint id}{
      \Formula \Append \DeclareBool{\FlushVar{k, t}} \Append \EOL\;
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
std::string check_var (uint k, uint id)
{
  return var("check", {k, id});
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_check (uint k)
{
  if (checkpoints.empty())
    return;

  for (const auto & [id, _] : checkpoints)
    formula << declare_bool_var(check_var(k, id)) << eol;

  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; checkpoint variables - check_<step>_<id>
(declare-fun check_0_0 () Bool)
\end{lstlisting}

\subsubsection{define transitions}
\todo[inline]{define transitions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{DefineExec}{define_exec}
\SetKwFunction{DefineCheck}{define_check}

\begin{algorithm}[H]
  \Fn{\DefineTransitions{k}}{
    \DefineExec{}\;
    \DefineCheck{}\;
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
void define_transitions (uint k)
{
  define_exec(k);
  define_check(k);
}
\end{lstlisting}

\subsubsection{define exec}
\todo[inline]{define exec} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{Assert}{assert}
\begin{algorithm}[H]
  \Fn{\Assert{expr}}{
    \Return \texttt{"(assert "} + \ArgSty{expr} + \texttt{")"}\;
  }
\end{algorithm}

\SetKwFunction{Equality}{equality}
\begin{algorithm}[H]
  \Fn{\Equality{var, expr}}{
    \Return \texttt{"(= "} + \ArgSty{var} + \texttt{" "} + \ArgSty{expr} + \texttt{")"}\;
  }
\end{algorithm}

\SetKwFunction{Assign}{assign}
\begin{algorithm}[H]
  \Fn{\Assign{var, expr}}{
    \Return \Assert{\Equality{var, expr}}\;
  }
\end{algorithm}

\SetKwFunction{And}{and}
\begin{algorithm}[H]
  \Fn{\And{args}}{
    \Return \texttt{"(and "} + \ArgSty{var} + \texttt{" "} + \ArgSty{expr} + \texttt{")"}\;
  }
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DefineExec{k}}{
    \IteratePrograms{
      % \Formula \Append \\
        % \Indp \Assign{ \\
          % \Indp \ExecVar{k, t, pc}, \\
          % \Indp \And{\StmtVar{k, t, pc}, \ThreadVar{k, t}}}\;
      \begin{tabbing}
        \Formula \Append \Assign{\=\ExecVar{k, t, pc}, \\
        \> \And{\=\StmtVar{k, t, pc}, \\
        \> \> \ThreadVar{k, t}}}\;
      \end{tabbing}
      \vspace{-1\baselineskip}
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
template <class ... T>
inline string expr (const char * op, const T & ... args)
{
  string e = '(' + op;
  (((e += ' ') += args), ...);
  return e += ')';
}

template <template <class, class...> class C>
inline string expr (const char * op, const C<string> & args)
{
  string e = '(' + op;
  for (const auto & a : args)
    (e += ' ') += a;
  return e += ')';
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
string assertion (string expr)
{
  return expr("assert", expr);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
string assertion (string expr)
{
  return "(assert " + expr + ')';
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
string equality (string var, string expr)
{
  return "(= " + var + ' ' + expr + ')';
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
string assign (string var, string expr)
{
  return assertion(equality(var, expr));
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
string land (string var, string expr)
{
  return assertion(equality(var, expr));
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void define_exec (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    {
      for (uint pc = 0; pc < programs[t].size(); pc++)
        formula << assign(exec(k, t, pc),
                          land(stmt(k, t, pc),
                               thread(k, t))) << eol;
      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; statement execution variables - exec_<step>_<thread>_<pc>
(assert (= exec_0_0_0 (and stmt_0_0_0 thread_0_0)))
(assert (= exec_0_0_1 (and stmt_0_0_1 thread_0_0)))
(assert (= exec_0_0_2 (and stmt_0_0_2 thread_0_0)))
(assert (= exec_0_0_3 (and stmt_0_0_3 thread_0_0)))
(assert (= exec_0_0_4 (and stmt_0_0_4 thread_0_0)))

(assert (= exec_0_1_0 (and stmt_0_1_0 thread_0_1)))
(assert (= exec_0_1_1 (and stmt_0_1_1 thread_0_1)))
(assert (= exec_0_1_2 (and stmt_0_1_2 thread_0_1)))
(assert (= exec_0_1_3 (and stmt_0_1_3 thread_0_1)))
(assert (= exec_0_1_4 (and stmt_0_1_4 thread_0_1)))

(assert (= exec_0_2_0 (and stmt_0_2_0 thread_0_2)))
(assert (= exec_0_2_1 (and stmt_0_2_1 thread_0_2)))
(assert (= exec_0_2_2 (and stmt_0_2_2 thread_0_2)))
(assert (= exec_0_2_3 (and stmt_0_2_3 thread_0_2)))
(assert (= exec_0_2_4 (and stmt_0_2_4 thread_0_2)))
(assert (= exec_0_2_5 (and stmt_0_2_5 thread_0_2)))
\end{lstlisting}

\subsubsection{define check}
\todo[inline]{define check} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{Not}{not}
\begin{algorithm}[H]
  \Fn{\Not{expr}}{
    \Return \texttt{"(not "} + \ArgSty{expr} + \texttt{")"}\;
  }
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DefineCheck{k}}{
    \ForEach{checkpoint id}{
      \SetKwData{Args}{args}
      \If{$k > 0$}{
        \Args = \{\}\;
        % list \Args\;
        \ForEach{thread t containing a call to checkpoint id}{
          % push to args bitvector
          % \Args.append(\BlockVar{k, id, t})\;
          \SetKwFunction{Push}{append}
          \Push{\Args, \BlockVar{k, id, t}}\;
        }

        \Formula \Append \Assign{\CheckVar{k, id}, \And{\Args}}\;
      }
      \Else {
        \Formula \Append \Assert{\Not{\CheckVar{k, id}}}\;
      }
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DefineCheck{k}}{
    \SetKwData{Args}{args}
    \For{every checkpoint id}{
      \If{step > 0}{
        \Args = list of all threads containing a call to checkpoint id\;
        append assignment to the formula\;
      }
      \Else{
        append an assertion of the negated check variable\;
      }
    }
  }
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\DefineCheck{k}}{
    \ForEach{id \KwSty{in} \DataSty{checkpoints}}{
      \SetKwData{Args}{args}
      \If{$k > 0$}{
        % \Args\;
        % list \Args\;
        \ForEach{t \KwSty{in} \DataSty{checkpoints[\ArgSty{id}]}}{
          % push to args bitvector
          \SetKwFunction{Put}{push_back}
          \Args.\Put{\BlockVar{k, id, t}}\;
          % \Push{\Args, \BlockVar{k, id, t}}\;
        }

        \Formula \Append \Assign{\CheckVar{k, id}, \And{\Args}}\;
      }
      \Else {
        \Formula \Append \Assert{\Not{\CheckVar{k, id}}}\;
      }
    }
    \Formula \Append \EOL\;
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
void define_check (uint k)
{
  if (checkpoints.empty())
    return;

  for (const auto & [id, threads] : checkpoints)
    {
      if (k)
        {
          vector<string> args;

          for (const auto & t : threads)
            args.push_back(block_var(step, id, t.first));

          formula << assign(check_var(step, id), land(args));
        }
      else
        formula << assertion(lnot(check_var(step, id)));

      formula << eol;
    }

  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; checkpoint variables - check_<step>_<id>
(assert (not check_0_0))
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; checkpoint variables - check_<step>_<id>
(assert (= check_1_0 (and block_1_0_0 block_1_0_1 block_1_0_2)))
\end{lstlisting}

\subsubsection{define constraints}
\todo[inline]{define constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SetKwFunction{DefineSchedulingConstraints}{define_scheduling_constraints}
\SetKwFunction{DefineStoreBufferConstraints}{define_store_buffer_constraints}
\SetKwFunction{DefineCheckpointConstraints}{define_checkpoint_constraints}
\SetKwFunction{DefineHaltConstraints}{define_halt_constraints}

\begin{algorithm}[H]
  \Fn{\DefineConstraints{k}}{
    \DefineSchedulingConstraints{k}\;
    \DefineStoreBufferConstraints{k}\;
    \DefineCheckpointConstraints{k}\;
    \DefineHaltConstraints{k}\;
  }
\end{algorithm}

\begin{lstlisting}[style=c++]
void define_constraints (unsigned k)
{
  define_scheduling_constraints(k);
  define_store_buffer_constraints(k);
  define_checkpoint_constraints(k);
  define_halt_constraints(k);
}
\end{lstlisting}

\subsubsection{define scheduling constraints}
\todo[inline]{define scheduling constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string card_constraint_naive (std::vector<std::string> vars)
{
  switch (vars.size())
    {
    case 1: return assertion(vars.front()) += eol;
    case 2: return assertion(lxor(vars)) += eol;
    default: break;
    }

  // >= 1 constraint
  std::string constraint = assertion(lor(vars)) += eol;

  // <= 1 constraint
  for (auto it1 = vars.begin(); it1 != vars.end(); ++it1)
    for (auto it2 = it1 + 1; it2 != vars.end(); ++it2)
      (constraint += assertion(lor(lnot(*it1), lnot(*it2)))) += eol;

  return constraint;
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string card_constraint_sinz (std::vector<std::string> vars)
{
  const size_t n = vars.size();

  assert(n);

  switch (n)
    {
    case 1: return assertion(vars.front()) + eol;
    case 2: return assertion(lxor(vars)) + eol;
    default: break;
    }

  std::string constraint;

  // n-1 auxiliary variables
  std::vector<std::string> auxs;
  auxs.reserve(n - 1);

  const auto end = --vars.end();

  for (auto it = vars.begin(); it != end; ++it)
    {
      constraint += declare_bool_var(auxs.emplace_back(*it + "_aux"));
      constraint += eol;
    }

  // >= 1 constraint
  constraint += eol;
  constraint += assertion(lor(vars));
  constraint += eol;

  // <= 1 constraint
  auto var = vars.begin();
  auto aux = auxs.begin();

  constraint += assertion(lor(lnot(*var), *aux));
  constraint += eol;

  while (++var != end)
    {
      const std::string & aux_prev = *aux++;

      constraint += assertion(lor(lnot(*var), *aux));
      constraint += eol;
      constraint += assertion(lor(lnot(aux_prev), *aux));
      constraint += eol;
      constraint += assertion(lor(lnot(*var), lnot(aux_prev)));
      constraint += eol;
    }

  constraint += assertion(lor(lnot(*var), lnot(*aux)));
  constraint += eol;

  return constraint;
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void define_scheduling_constraints (uint k)
{
  std::vector<std::string> variables;

  iterate_threads([this, &variables]
  for (unsigned t = 0; t < programs.size(); t++)
    {
      variables.push_back(thread_var());
      variables.push_back(flush_var());
    });

  if (!halts.empty() || !exits.empty())
    variables.push_back(exit_flag_var());

  formula
    << (use_sinz_constraint
      ? card_constraint_sinz(variables)
      : card_constraint_naive(variables))
    << eol;
}
\end{lstlisting}

\subsubsection{define store buffer constraints}
\todo[inline]{define store buffer constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_store_buffer_constraints (uint k)
{
  for (unsigned t = 0; t < programs.size(); t++)
    if (flushes.find(thread) != flushes.end())
      {
        std::vector<std::string> stmts;

        for (const auto & pc : flushes[t])
          stmts.push_back(stmt_var(k, t, pc));

        formula <<
          assertion(
            ite(
              sb_full_var(),
              implication(
                lor(stmts),
                lnot(thread_var(k, t))),
              lnot(flush_var(k, t)))) <<
          eol;
      }
    else
      {
        formula <<
          assertion(
            implication(
              lnot(sb_full_var(k, t)),
          lnot(flush_var(k, t)))) <<
          eol;
      }

  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (ite sb-full_1_0
             (=> (or stmt_1_0_1 stmt_1_0_4) (not thread_1_0))
             (not flush_1_0)))
(assert (ite sb-full_1_1
             (=> (or stmt_1_1_1 stmt_1_1_4) (not thread_1_1))
             (not flush_1_1)))
(assert (=> (not sb-full_1_2) (not flush_1_2)))
\end{lstlisting}

\subsubsection{define checkpoint constraints}
\todo[inline]{define checkpoint constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_checkpoint_constraints (unsigned k)
{
  for (const auto & [id, threads] : checkpoints)
    {
      for (const auto & [t, _] : threads)
        {
          formula <<
            assertion(
              implication(
                land(
                  block_var(k, id, t),
                  lnot(check_var(k, id))),
                lnot(thread_var(k, t))));

          formula << eol;
        }

      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (=> (and block_1_0_0 (not check_1_0)) (not thread_1_0)))
(assert (=> (and block_1_0_1 (not check_1_0)) (not thread_1_1)))
(assert (=> (and block_1_0_2 (not check_1_0)) (not thread_1_2)))
\end{lstlisting}

\subsubsection{define halt constraints}
\todo[inline]{define halt constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_halt_constraints (uint k)
{
  if (halts.empty())
    return;

  for (const auto & [t, _] : halts)
    formula << assertion(
                 implication(
                   halt_var(k, t),
                   lnot(thread_var(k, t)))) << eol;

  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (=> halt_1_0 (not thread_1_0)))
(assert (=> halt_1_1 (not thread_1_1)))
\end{lstlisting}

\subsubsection{init states}
\todo[inline]{init states} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_states ()
{
  init_accu();
  init_mem();
  init_sb_adr();
  init_sb_val();
  init_sb_full();
  init_stmt();
  init_block();
  init_halt();

  init_heap();
  init_exit_flag();
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
\end{lstlisting}

\subsubsection{init accu}
\todo[inline]{init accu} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_accu ()
{
  for (unsigned t = 0; t < programs.size(); t++)
    formula << assign(accu_var(k, t), word2hex(0)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; accu variables - accu_<step>_<thread>
(assert (= accu_0_0 #x0000))
(assert (= accu_0_1 #x0000))
(assert (= accu_0_2 #x0000))
\end{lstlisting}

\subsubsection{init mem}
\todo[inline]{init mem} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_mem ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assign(mem_var(k, t), word2hex(0)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; mem variables - mem_<step>_<thread>
(assert (= mem_0_0 #x0000))
(assert (= mem_0_1 #x0000))
(assert (= mem_0_2 #x0000))
\end{lstlisting}

\subsubsection{init sb-adr}
\todo[inline]{init sb-adr} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_sb_adr ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assign(sb_adr_var(k, t), word2hex(0)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer address variables - sb-adr_<step>_<thread>
(assert (= sb-adr_0_0 #x0000))
(assert (= sb-adr_0_1 #x0000))
(assert (= sb-adr_0_2 #x0000))
\end{lstlisting}

\subsubsection{init sb-val}
\todo[inline]{init sb-val} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_sb_val ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assign(sb_val_var(k, t), word2hex(0)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer value variables - sb-val_<step>_<thread>
(assert (= sb-val_0_0 #x0000))
(assert (= sb-val_0_1 #x0000))
(assert (= sb-val_0_2 #x0000))
\end{lstlisting}

\subsubsection{init sb-full}
\todo[inline]{init sb-full} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_sb_full ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assertion(lnot(sb_full_var(k, t))) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer full variables - sb-full_<step>_<thread>
(assert (not sb-full_0_0))
(assert (not sb-full_0_1))
(assert (not sb-full_0_2))
\end{lstlisting}

\subsubsection{init stmt}
\todo[inline]{init stmt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_stmt ()
{
  for (uint t = 0; t < programs.size(); t++)
    {
      for (uint pc = 0; t < programs[t].size(); t++)
        formula << assertion(pc ? lnot(stmt_var(k, t, pc))
                                : stmt_var(k, t, pc)) << eol;
      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; statement activation variables - stmt_<step>_<thread>_<pc>
(assert stmt_0_0_0)
(assert (not stmt_0_0_1))
(assert (not stmt_0_0_2))
(assert (not stmt_0_0_3))
(assert (not stmt_0_0_4))

(assert stmt_0_1_0)
(assert (not stmt_0_1_1))
(assert (not stmt_0_1_2))
(assert (not stmt_0_1_3))
(assert (not stmt_0_1_4))

(assert stmt_0_2_0)
(assert (not stmt_0_2_1))
(assert (not stmt_0_2_2))
(assert (not stmt_0_2_3))
(assert (not stmt_0_2_4))
(assert (not stmt_0_2_5))
\end{lstlisting}

\subsubsection{init block}
\todo[inline]{init block} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_block ()
{
  for (const auto & [id, threads] : checkpoints)
    {
      for (const auto & [t, _] : threads)
        formula << assertion(lnot(block_var(k, id, t))) << eol;
      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; blocking variables - block_<step>_<id>_<thread>
(assert (not block_0_0_0))
(assert (not block_0_0_1))
(assert (not block_0_0_2))
\end{lstlisting}

\subsubsection{init halt}
\todo[inline]{init halt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_halt ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assertion(lnot(halt_var(0, t))) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; halt variables - halt_<step>_<thread>
(assert (not halt_0_0))
(assert (not halt_0_1))
(assert (not halt_0_2))
\end{lstlisting}

\subsubsection{init heap}
\todo[inline]{init heap} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_heap ()
{
  if (mmap.empty())
    return;

  for (const auto & [adr, val] : mmap)
    formula
      << assign(select(heap_var(0), word2hex(adr)), word2hex(val))
      << eol;

  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; heap variable - heap_<step>
(assert (= (select heap_0 #x0000) #x0000))
(assert (= (select heap_0 #x0001) #x0000))
\end{lstlisting}

\subsubsection{init exit-flag}
\todo[inline]{init exit-flag} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_exit_flag ()
{
  // TODO: remove - exits.empty() => !halts.empty()
  if (halts.empty() && exits.empty())
    return;

  formula << assertion(lnot(exit_flag_var(0))) << eol << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; exit flag variable - exit_<step>
(assert (not exit_0))
\end{lstlisting}

\subsubsection{init exit-flag}
\todo[inline]{init exit-flag} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_exit_flag ()
{
  // TODO: remove - exits.empty() => !halts.empty()
  if (halts.empty() && exits.empty())
    return;

  formula << assertion(lnot(exit_flag_var(0))) << eol << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; exit flag variable - exit_<step>
(assert (not exit_0))
\end{lstlisting}

\subsubsection{define states}
\todo[inline]{define states} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_states (uint k)
{
  define_accu(k);
  define_mem(k);
  define_sb_adr(k);
  define_sb_val(k);
  define_sb_full(k);
  define_stmt(k);
  define_block(k);
  define_halt(k);

  define_heap(k);
  define_exit_flag(k);
}
\end{lstlisting}

\subsubsection{encoding instructions}
\todo[inline]{encoding instructions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
struct Instruction
{
  uint arg;
  bool indirect;

  virtual std::string encode (uint k, uint t, State state) = 0;
}
\end{lstlisting}

\subsubsection{encode LOAD}
\todo[inline]{encode LOAD} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string load (uint k, uint t, uint adr, bool indirect = false)
{
  std::string address = word2hex(adr);

  std::string sb_adr = sb_adr_var(k - 1, t);
  std::string sb_val = sb_val_var(k - 1, t);
  std::string sb_full = sb_full_var(k - 1, t);
  std::string heap = heap_var(k - 1);

  if (indirect)
    return
      ite(sb_full,
          ite(equality(sb_adr, address),
              ite(equality(sb_val, address),
                  sb_val,
                  select(heap, sb_val)),
              ite(equality(sb_adr, select(heap, address)),
                  sb_val,
                  select(heap, select(heap, address)))),
          select(heap, select(heap, address)));
  else
    return ite(land(sb_full, equality(sb_adr, address)),
               sb_val,
               select(heap, address));
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string Load::encode (uint k, uint t, State state)
{
  return load(k, t, arg, indirect);
}
\end{lstlisting}

\subsubsection{encode STORE}
\todo[inline]{encode STORE} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Store::encode (uint k, uint t, State state)
{
  switch (state)
    {
    case State::sb_adr:
      return indirect ? load(arg) : word2hex(arg);

    case State::sb_val: return accu_var(k - 1, t);
    }
}
\end{lstlisting}

\subsubsection{encode ADD}
\todo[inline]{encode ADD} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Add::encode (uint k, uint t, State state)
{
  return bvadd(accu_var(k - 1, t), load(arg, indirect));
}
\end{lstlisting}

\subsubsection{encode ADDI}
\todo[inline]{encode ADDI} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Addi::encode (uint k, uint t, State state)
{
  return bvadd(accu_var(k - 1, t), word2hex(arg));
}
\end{lstlisting}

\subsubsection{encode SUB}
\todo[inline]{encode SUB} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Sub::encode (uint k, uint t, State state)
{
  return bvsub(accu_var(k - 1, t), load(arg, indirect));
}
\end{lstlisting}

\subsubsection{encode SUBI}
\todo[inline]{encode SUBI} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Subi::encode (uint k, uint t, State state)
{
  return bvsub(accu_var(k - 1, t), word2hex(arg));
}
\end{lstlisting}

\subsubsection{encode MUL}
\todo[inline]{encode MUL} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Mul::encode (uint k, uint t, State state)
{
  return bvmul(accu_var(k - 1, t), load(arg, indirect));
}
\end{lstlisting}

\subsubsection{encode MULI}
\todo[inline]{encode MULI} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Muli::encode (uint k, uint t, State state)
{
  return bvmul(accu_var(k - 1, t), word2hex(arg));
}
\end{lstlisting}

\subsubsection{encode CMP}
\todo[inline]{encode CMP} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Cmp::encode (uint k, uint t, State state)
{
  return bvsub(accu_var(k - 1, t), load(arg, indirect));
}
\end{lstlisting}

\subsubsection{encode JMP}
\todo[inline]{encode JMP} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jmp::encode (uint k, uint t, State state) { return ""; }
\end{lstlisting}

\subsubsection{encode JZ}
\todo[inline]{encode JZ} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jz::encode (uint k, uint t, State state)
{
  return equality(accu_var(k - 1, t), word2hex(0));
}
\end{lstlisting}

\subsubsection{encode JNZ}
\todo[inline]{encode JNZ} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jnz::encode (uint k, uint t, State state)
{
  return lnot(equality(accu_var(k - 1, t), word2hex(0)));
}
\end{lstlisting}

\subsubsection{encode JS}
\todo[inline]{encode JS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[noline]{instroduce global std::string msb = "15"}
\begin{lstlisting}[style=c++]
std::string Js::encode (uint k, uint t, State state)
{
  // TODO: introduce global?
  static const std::string msb = std::to_string(word_size - 1);

  return equality("#b1", extract(msb, msb, accu_var(k - 1, t)));
}
\end{lstlisting}

\subsubsection{encode JNS}
\todo[inline]{encode JNS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jns::encode (uint k, uint t, State state)
{
  return equality("#b0", extract(msb, msb, accu_var(k - 1, t)));
}
\end{lstlisting}

\subsubsection{encode JNZNS}
\todo[inline]{encode JNZNS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jnzns::encode (uint k, uint t, State state)
{
  std::string accu = accu_var(k - 1, t);
  return
    land(lnot(equality(accu, word2hex(0))),
         equality("#b0", extract(msb, msb, accu)));
}
\end{lstlisting}

\subsubsection{encode MEM}
\todo[inline]{encode MEM} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Mem::encode (uint k, uint t, State state)
{
  return load(arg, indirect);
}
\end{lstlisting}

\subsubsection{encode CAS}
\todo[inline]{encode CAS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Cas::encode (uint k, uint t, State state)
{
  std::string heap = heap_var(k - 1);
  std::string address =
    indirect ? select(heap, word2hex(arg)) : word2hex(arg);
  std::string condition =
    equality(mem_var(k - 1, t), select(heap, address));

  switch (state)
    {
    case State::accu:
      return ite(condition, word2hex(1), word2hex(0));

    case State::heap:
      return
        ite(condition,
            store(heap, address, accu_var(k - 1, t)),
            heap);
    }
}
\end{lstlisting}

\subsubsection{encode EXIT}
\todo[inline]{encode EXIT} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Exit::encode (uint k, uint t, State state)
{
  return word2hex(arg);
}
\end{lstlisting}

\subsubsection{define accu}
\todo[inline]{define accu} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_accu (unsigned k)
{
  for (const auto & [t, stmts] : alters[State::accu])
    {
      std::string expr = accu_var(k - 1, t);
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        expr = ite(exec_var(k - 1, t, *pc),
                   program[t][*pc].encode(k, t, State::accu),
                   expr);
      formula << assign(accu_var(k, t), expr) << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; accu variables - accu_<step>_<thread>
(assert (= accu_1_0
           (ite exec_0_0_0
                (bvadd accu_0_0 #x0001)
                (ite exec_0_0_2
                     (ite (and sb-full_0_0 (= sb-adr_0_0 #x0001))
                          sb-val_0_0
                          (select heap_0 #x0001))
                     accu_0_0))))
(assert (= accu_1_1
           (ite exec_0_1_0
                (bvadd accu_0_1 #x0001)
                (ite exec_0_1_2
                     (ite (and sb-full_0_1 (= sb-adr_0_1 #x0000))
                          sb-val_0_1
                          (select heap_0 #x0000))
                     accu_0_1))))
(assert (= accu_1_2
           (ite exec_0_2_1
                (bvadd accu_0_2
                       (ite (and sb-full_0_2 (= sb-adr_0_2 #x0000))
                            sb-val_0_2
                            (select heap_0 #x0000)))
                (ite exec_0_2_2
                     (bvadd accu_0_2
                            (ite (and sb-full_0_2 (= sb-adr_0_2 #x0001))
                                 sb-val_0_2
                                 (select heap_0 #x0001)))
                     accu_0_2))))
\end{lstlisting}

\subsubsection{define mem}
\todo[inline]{define mem} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_mem (unsigned k)
{
  for (const auto & [t, stmts] : alters[State::mem])
    {
      std::string expr = mem_var(k - 1, t);
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        expr = ite(exec_var(k - 1, t, *pc),
                   program[t][*pc].encode(k, t, State::mem),
                   expr);
      formula << assign(mem_var(k, t), expr) << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; mem variables - mem_<step>_<thread>
(assert (= mem_1_0 mem_0_0))
(assert (= mem_1_1 mem_0_1))
(assert (= mem_1_2 mem_0_2))
\end{lstlisting}

\subsubsection{define sb-adr}
\todo[inline]{define sb-adr} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_sb_adr (unsigned k)
{
  for (const auto & [t, stmts] : alters[State::sb_adr])
    {
      std::string expr = sb_adr_var(k - 1, t);
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        expr = ite(exec_var(k - 1, t, *pc),
                   program[t][*pc].encode(k, t, State::sb_adr),
                   expr);
      formula << assign(sb_adr_var(k, t), expr) << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer address variables - sb-adr_<step>_<thread>
(assert (= sb-adr_1_0 (ite exec_0_0_1 #x0000 sb-adr_0_0)))
(assert (= sb-adr_1_1 (ite exec_0_1_1 #x0001 sb-adr_0_1)))
(assert (= sb-adr_1_2 sb-adr_0_2))
\end{lstlisting}

\subsubsection{define sb-val}
\todo[inline]{define sb-val} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_sb_val (unsigned k)
{
  for (const auto & [t, stmts] : alters[State::sb_val])
    {
      std::string expr = sb_val_var(k - 1, t);
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        expr = ite(exec_var(k - 1, t, *pc),
                   program[t][*pc].encode(k, t, State::sb_val),
                   expr);
      formula << assign(sb_val_var(k, t), expr) << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer value variables - sb-val_<step>_<thread>
(assert (= sb-val_1_0 (ite exec_0_0_1 accu_0_0 sb-val_0_0)))
(assert (= sb-val_1_1 (ite exec_0_1_1 accu_0_1 sb-val_0_1)))
(assert (= sb-val_1_2 sb-val_0_2))
\end{lstlisting}

\subsubsection{define sb-full}
\todo[inline]{define sb-full} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_sb_full (unsigned k)
{
  for (const auto & [t, stmts] : alters[State::sb_full])
    {
      std::vector<std::string> args;
      for (const auto & pc : stmts)
        args.push_back(exec_var(k - 1, t, pc));
      args.push_back(sb_full_var(k - 1, t));
      formula << assign(sb_full_var(k, t),
                        ite(flush_var(k - 1, t),
                            "false",
                            lor(args)))
              << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer full variables - sb-full_<step>_<thread>
(assert (= sb-full_1_0 (ite flush_0_0
                            false
                            (or exec_0_0_1 sb-full_0_0))))
(assert (= sb-full_1_1 (ite flush_0_1
                            false
                            (or exec_0_1_1 sb-full_0_1))))
(assert (= sb-full_1_2 (ite flush_0_2 false sb-full_0_2)))
\end{lstlisting}

\subsubsection{define stmt}
\todo[inline]{define stmt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_stmt (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    {
      for (uint pc = 0; pc < program[t].size(); pc++)
        {
          // statement reactivation
          std::string expr =
            land(stmt_var(k - 1, t, pc),
                 lnot(exec_var(k - 1, t, pc)));

          const auto & pred = predecessors[thread][pc];

          for (auto rit = pred.rbegin(); rit != pred.rend(); ++rit)
            {
              // predecessor's execution variable
              std::string val = exec_var(k - 1, t, *rit);

              // build conjunction of execution variable and jump condition
              const Instruction & pre = program[*rit];

              if (pre.is_jump())
                {
                  const std::string cond = pre.encode(*this);

                  // JMP has no condition and returns an empty std::string
                  if (!cond.empty())
                    val =
                      land(
                        val,
                        // only activate successor if jump condition failed
                        *rit == pc - 1 && pre.arg() != pc
                          ? lnot(cond)
                          : cond);
                }

              // add predecessor to the activation
              expr = ite(stmt_var(k - 1, t, *rit), val, expr);
            }

          formula << assign(stmt_var(k, t, pc), expr) << eol;
        }

      formula << eol;
    }
 formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; statement activation variables - stmt_<step>_<thread>_<pc>
(assert (= stmt_1_0_0 (and stmt_0_0_0 (not exec_0_0_0))))
(assert (= stmt_1_0_1 (ite stmt_0_0_0
                           exec_0_0_0
                           (and stmt_0_0_1 (not exec_0_0_1)))))
(assert (= stmt_1_0_2 (ite stmt_0_0_1
                           exec_0_0_1
                           (and stmt_0_0_2 (not exec_0_0_2)))))
(assert (= stmt_1_0_3 (ite stmt_0_0_2
                           exec_0_0_2
                           (and stmt_0_0_3 (not exec_0_0_3)))))
(assert (= stmt_1_0_4 (ite stmt_0_0_3
                           exec_0_0_3
                           (and stmt_0_0_4 (not exec_0_0_4)))))

(assert (= stmt_1_1_0 (and stmt_0_1_0 (not exec_0_1_0))))
(assert (= stmt_1_1_1 (ite stmt_0_1_0
                           exec_0_1_0
                           (and stmt_0_1_1 (not exec_0_1_1)))))
(assert (= stmt_1_1_2 (ite stmt_0_1_1
                           exec_0_1_1
                           (and stmt_0_1_2 (not exec_0_1_2)))))
(assert (= stmt_1_1_3 (ite stmt_0_1_2
                           exec_0_1_2
                           (and stmt_0_1_3 (not exec_0_1_3)))))
(assert (= stmt_1_1_4 (ite stmt_0_1_3
                           exec_0_1_3
                           (and stmt_0_1_4 (not exec_0_1_4)))))

(assert (= stmt_1_2_0 (and stmt_0_2_0 (not exec_0_2_0))))
(assert (= stmt_1_2_1 (ite stmt_0_2_0
                           exec_0_2_0
                           (and stmt_0_2_1 (not exec_0_2_1)))))
(assert (= stmt_1_2_2 (ite stmt_0_2_1
                           exec_0_2_1
                           (and stmt_0_2_2 (not exec_0_2_2)))))
(assert (= stmt_1_2_3 (ite stmt_0_2_2
                           exec_0_2_2
                           (and stmt_0_2_3 (not exec_0_2_3)))))
(assert (= stmt_1_2_4 (ite stmt_0_2_3
                           (and exec_0_2_3 (not (= accu_0_2 #x0000)))
                           (and stmt_0_2_4 (not exec_0_2_4)))))
(assert (= stmt_1_2_5 (ite stmt_0_2_3
                           (and exec_0_2_3 (= accu_0_2 #x0000))
                           (and stmt_0_2_5 (not exec_0_2_5)))))
\end{lstlisting}

\todo[inline]{} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \DataSty{bound}
% \[\Programs{i}\KwSty{[}\ArgSty{j}\KwSty{]} = \Int\]
% \Size{\Programs{i}}

% \Word: 16 bit unsigned integer


\SetKw{Int}{word}
\SetKw{String}{string}
\SetKwFunction{Size}{size}
\SetKwArray{Programs}{programs}

\begin{algorithm}[H]
  \Fn{\AccuVar{k, t}}{\Return \texttt{"accu_"} + \ToString{k} + \texttt{"_"} + \ToString{t}\;}
\end{algorithm}

\begin{algorithm}[H]
  \Fn{\AccuVar{k: \Int, t: \Int} : \String}{\Return \texttt{"accu_"} + \ToString{k} + \texttt{"_"} + \ToString{t}\;}
  % \Fn{accu(k: int, t: int) : int}{\KwRet printf(\texttt{"accu_\%d_\%d"}, k, t)\;}
\end{algorithm}

\SetKwFunction{DeclareBool}{declare_bool_var}
\begin{algorithm}[H]
  \Fn{\DeclareBool{name}}{
    \Return \texttt{"(declare-fun "} $+$ \ArgSty{name} $+$ \texttt{" () Bool)"}\;
  }
\end{algorithm}

\SetKwFunction{DeclareBV}{declare_bv_var}
\begin{algorithm}[H]
  \Fn{\DeclareBV{name}}{
    \Return \texttt{"(declare-fun "} $+$ \ArgSty{name} $+$ \texttt{" () (_ BitVec 16))"}\;
  }
\end{algorithm}

\SetKwFunction{DeclareAccu}{declare_accu}
\begin{algorithm}[H]
  \Fn{\DeclareAccu{step}}{
    \For{$i = 0$ \KwTo $\Size{\Programs} - 1$}{
      \Formula \Append \DeclareBV{\AccuVar{step, i}} \Append \DataSty{eol}\;
    }
    \Formula \Append \DataSty{eol}\;
  }
\end{algorithm}

% \begin{algorithm}[H]
  % \Fn{\DeclareAccu{}}{
    % \NumThreads\;
    % \Formula \FuncSty{+=} \texttt{"(set-logic QF_AUFBV)"}\;
    % \Formula \FuncSty{+=} \texttt{"(declare-fun "} $+$ \AccuVar{i, j} $+$ \texttt{" () Bool)"}\;
    % \For{$i = 0$ \KwTo $\Size{\Programs{thread}} - 1$}{
    % % \For{$(i = 0;\ i < \Size{\Programs{thread}};\ i\FuncSty{++})$}{
      % bar\;
    % }
  % }
% \end{algorithm}

\begin{algorithm}[H]
  \SetKwProg{Fn}{Function}{ is}{end}
  \KwIn{foo bar}
  \Fn{afunc(i: int) : int}{return 0\;}
\end{algorithm}

\subsection{BTOR2}

\subsection{Replay}

