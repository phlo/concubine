\section{Verification}

The main part of this work is implemented in the \texttt{solve} submodule,
% allowing the verification of concurrent assembly programs by bounded model checking based on register states in our abstract machine model.
% allowing bounded model checking of concurrent assembly programs based on register states in our abstract machine model.
% performing bounded model checking of concurrent software running on our abstract machine model.
allowing verification of concurrent software running on our abstract machine model by the means of bounded model checking \cite{ref:BMC}.
It takes an arbitrary number of programs plus the upper bound as input and encodes them into a finite state machine, expressed as a SMT formula where each transition translates to the execution of a single thread.
SMT-Lib \cite{ref:SMT-Lib} and the novel BTOR2 \cite{ref:BTOR2} word level model checking format can be generated, using the theories of arrays, uninterpreted functions and bitvectors.
To simplify the definition of bad states directly in the program code, the possibility of encountering an exit code greater than zero is checked for per default, but custom properties may be defined in a separate file and added with the \texttt{-c} command line parameter.
The resulting formula is then evaluated by a state-of-the-art solver.
If it is satisfiable, the corresponding execution trace is extracted from the resulting model and stored for later inspection.

% \todo{intro
  % \begin{itemize}
    % \item submodule \texttt{solve}
    % \item verification of assembly programs by bounded model checking based on register states
    % \item property: there exists a trace in which $\mathbf{EG^?F^?}(\EXITCODE \neq 0)$ holds (exists globally)
    % \item using satisfiability modulo theories (arrays and bitvectors)
    % \item problem defined by state and transition variables
    % \item one step corresponds to a specific thread's execution of a single instruction
  % \end{itemize}
% }

\todo[inline]{Basic Definitions? sorts, functions, etc.}

\subsection{Basic Encoding Scheme}

Let $\BVSORT[n]$ be the fixed size bitvector sort of width $n$ and $\ASORT[n]$ the array sort with index and element sorts $\BVSORT[n]$.
The following variables are used to encode the machine state at a particular step $k \in [0, bound] \subset \mathbb{N}$, where $k = 0$ is the initial state.

% \renewcommand{\arraystretch}{1.5}
\setlength{\tabulinesep}{3pt}
\begin{longtabu}{llX}
  \firsthline
  % \textbf{Machine} &&\\
  % \hline
  $\HEAP^k$ & $\in \ASORT$ & shared memory \\
  $\EXIT^k$ & $\in \BVSORT[1]$ & exit flag \\
  $\EXITCODE^k$ & $\in \BVSORT$ & exit code \\
  \hline
  % \textbf{Threads} &&\\
  % \hline
  $\ACCU^k_t$ & $\in \BVSORT$ & accumulator register of thread $t$ \\
  $\MEM^k_t$ & $\in \BVSORT$ & CAS memory register of thread $t$ \\
  $\SBADR^k_t$ & $\in \BVSORT$ & store buffer address register of thread $t$ \\
  $\SBVAL^k_t$ & $\in \BVSORT$ & store buffer value register of thread $t$ \\
  $\SBFULL^k_t$ & $\in \BVSORT[1]$ & store buffer full flag of thread $t$ \\
  $\STMT^k_{t, pc}$ & $\in \BVSORT[1]$ & activation flag for statement at $pc$ of thread $t$ \\
  $\BLOCK^k_{id, t}$ & $\in \BVSORT[1]$ & block flag for checkpoint $id$ of thread $t$ \\
  $\HALT^k_t$ & $\in \BVSORT[1]$ & halt flag of thread $t$ \\
  \lasthline
  \caption{State Variables}
  \label{tbl:states}
\end{longtabu}

\newcommand{\READ}{\texttt{read}}
\newcommand{\WRITE}{\texttt{write}}

% Shared memory is modelled using the array variable $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$ for updating the element at $adr \in \BVSORT$ with a given value $val \in \BVSORT$ in step $k$.
% Shared memory in step $k$ is modelled using the array variable $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving an element and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$, returning an updated version of the shared memory state array with the given element set to a specific value.
Shared memory states are modelled using the array variables $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving an element and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$ returning an updated version of the shared memory state array with the given element set to a specific value.
% Its initial state $\HEAP^0$ may contain input data according to a given memory map, but is assumed to be uninitialized in general.
Register states of a thread $t$ are determined by the bitvector variables $\ACCU^k_t$, $\MEM^k_t$, $\SBADR^k_t$, $\SBVAL^k_t$ and the flag $\SBFULL^k_t$, signalling that the store buffer is full.
%, which are all initially set to zero.
To aid solvers by reducing the formulas complexity, program flow is modelled without an explicit problem counter.
Instead, an activation flag $\STMT^k_{t, pc}$ is added for every statement in the program of thread $t$, expressing that it is about to execute the statement at $pc$.
%To model the program flow without an explicit program counter, an activation flag $\STMT^k_{t, pc}$ is added for every statement in the program of thread $t$, expressing that it is about to execute the statement at $pc$.
Blocking a thread $t$ while it is waiting for all other threads to reach a checkpoint $id$ is achieved by a flag $\BLOCK^k_t$.
% Blocking a thread $t$ while waiting for all other threads to synchronize on a checkpoint $id$ is achieved by the $\BLOCK^k_{id, t}$ state flag.
Similarly, the flag $\HALT^k_t$ indicates that thread $t$ executed a \texttt{HALT} instruction and is therefore also prevented from being scheduled.
% Termination due to an call to \texttt{EXIT}, or because all threads finished executing their programs, or \texttt{EXIT}  is captured by
Termination is captured by the flag $\EXIT^k$ and bitvector variable $\EXITCODE^k$.

% The shared memory state array $\HEAP^0$ may be initialized with input data according to a given memory map, but is assumed to be uninitialized in general.
% All other states are initially set to zero, with the exception of the initial statement activation flag $\STMT^0_{t, 0}$ of every thread $t$.
All states are initially set to zero, except the initial statement activation flag $\STMT^0_{t, 0}$ of every thread $t$ and the shared memory state array $\HEAP^0$, which may be initialized with input data according to a given memory map, but is assumed to be uninitialized in general.

\bigskip

% Constraints for valid machine state transitions of the form $s_k \to^k s_{k + 1}$ are governed by the following variables.
Machine state transitions of the form $s_k \to^k s_{k + 1}$ are governed by the following free variables.
% Machine state transitions of the form $s_k \to^k s_{k + 1}$ are governed by the free variables given in Table \ref{tbl:encoding:transitions}.
% Transitions $s_k \to^k s_{k + 1}$ of a state $s_k$ are governed by the following free variables and are allowed to be chosen non-deterministically.

\begin{longtabu}{llX}
  \firsthline
  $\THREAD^k_t$ & $\in \BVSORT[1]$ & thread $t$ is scheduled to execute an instruction in step $k$ \\
  $\FLUSH^k_t$ & $\in \BVSORT[1]$ & thread $t$ flushes its store buffer in step $k$ \\
  \lasthline
  \caption{Transition Variables}
  \label{tbl:encoding:transitions}
\end{longtabu}

% \todo[inline]{helper variables}
To simplify the definition of successor states, the following helper variables capture frequently used terms.
% The following helper variables are introduced to simplify the latter definition of state transitions by capturing frequently used terms.

\begin{longtabu}{llX}
  \firsthline
  $\EXEC^k_{t, pc}$ & $\in \BVSORT[1]$ & thread $t$ is executing instruction at $pc$ in step $k$ \\
  $\CHECK^k_{id}$ & $\in \BVSORT[1]$ & all threads reached checkpoint $id$ in step $k$ \\
  \lasthline
  \caption{Helper Variables}
\end{longtabu}

% The statement execution variable $\EXEC^k_{t, pc}$,
The actual execution of a specific statement is encoded by $\EXEC^k_{t, pc}$ and
% The actual execution of a statement at $pc$ by thread $t$ in step $k$ is encoded by the execution variable $\EXEC^k_{t, pc}$ and
is defined as a conjunction of the corresponding statement and thread activation variables.

\[
  \EXEC^k_{t, pc} = \STMT^k_{t, pc} \land \THREAD^k_t
\]

Furthermore, we use $\CHECK^k_{id}$ to signal that all threads containing a call to checkpoint $id$, given in the set $C_{id}$, have synchronized.% and the corresponding $\BLOCK^k_{id, t}$ flags set.
\todo[noline]{$C_{id}$ ok?}
% from a set $C_{id}$ of threads containing a call to checkpoint $id$
\[
  \CHECK^k_{id} = \bigwedge_{t \in C_{id}} \BLOCK^k_{id, t}
\]

% \bigskip
\subsubsection{Scheduling}

\newcommand{\CardLt}{\leq^1_n(x_1, \ldots, x_n)}
\newcommand{\CardLtSeq}{\text{LT}^{n, 1}_{\text{SEQ}}}

\newcommand{\ITE}{\texttt{ite}}
\newcommand{\ITEindent}{\;\;\;\;\;\;\;}

% Non-deterministic scheduling of a single thread per step is realized by a boolean cardinality constraint over all $\THREAD^k_t$ and $\FLUSH^k_t$ variables for a number of threads $n$.
Non-deterministic scheduling of at most one thread per step is realized by a boolean cardinality constraint over all transition variables and the exit flag $\EXIT^k$ to ensure satisfiability if the machine terminates in a step $k < bound$.
Let $\CardLt$ be a predicate expressing that at most one out of $n$ variables is allowed to be true.
% The na\"{i}ve way of defining $\leq^1_n(x_1, \ldots, x_n)$ is by explicitly excluding all combinations of two variables being simultaneously true.
The intuitive way of encoding $\CardLt$ is by excluding all combinations of two variables being simultaneously true.
% The traditional way of defining such a constraint is by excluding all combinations of two variables being simultaneously true:
\[
  \bigwedge_{1 \leq i < j \leq n} (\neg x_i \lor \neg x_j)
\]
This na\"ive approach, however, consists of $\binom{n}{2}$ Horn clauses.
% While this na\"ive approach consists of $\binom{n}{2}$ Horn clauses, a more compact formulation, based on a sequential counter circuit, is presented as $\text{LT}^{n, 1}_{\text{SEQ}}$ in \cite{ref:Sinz}.
A more compact formulation, based on a sequential counter circuit computing partial sums $s_i = \sum^i_{j = 1} x_j$ for increasing values of $i$ up to the final $i = n$, is presented as $\CardLtSeq$ in \cite{ref:Sinz} and defined as follows.
% It only requires $3n - 4$ clauses in contrast to the na\"ive approach
% It is based on a sequential counter circuit, only requiring $3n - 4$ clauses, but $n - 1$ additional auxiliary variables.
% Beside this na\"ive approach, consisting of $\binom{n}{2}$ Horn clauses, a more compact formulation with respect to the number of clauses is presented as $\text{LT}^{n, 1}_{\text{SEQ}}$ in \cite{ref:Sinz}.
% This approach consists of $\binom{n}{2}$ Horn clauses.
% consisting of $\binom{n}{2}$ Horn clauses.
% A more compact formulation in terms of the number of clauses, called , based on a sequential counter circuit, is  presented in \cite{ref:Sinz} as $\text{LT}^{n, 1}_{\text{SEQ}}$.
% Cardinality constraint predicate $\leq^1_n(x_1, \ldots, x_n)$ defined as:
\[
  (\neg x_1 \lor s_1) \land (\neg x_n \lor \neg s_{n-1}) \bigwedge_{1 < i < n} \big ( (\neg x_i \lor s_i) \land (\neg s_{i-1} \lor s_i) \land (\neg x_i \lor \neg s_{i-1}) \big )
\]
% $\CardLtSeq$ only requires $3n - 4$ Horn clauses and $n - 1$ additional auxiliary variables.
% It is therefore superior to the na\"ive encoding with regard to the number of clauses for all $n > 5$.
$\CardLtSeq$ is superior to the na\"ive encoding with regard to the number of clauses for all $n > 5$, as it only requires $3n - 4$ Horn clauses and $n - 1$ additional auxiliary variables.
% \todo[inline]{constraint selection}
% Since we need to include two times the number of threads plus one variables in the constraint, the actual definition of $\leq^1_n(x_1, \ldots, x_n)$ is therefore determined by the number of threads involved and the na\"ive encoding only used for up to two threads, $\CardLtSeq$ otherwise.
The actual definition of the at most one constraint predicate $\CardLt$ is therefore determined by the number of threads involved.
Since we have to include two times the number of threads plus one variables in the constraint, the na\"ive encoding is only used for up to two threads and $\CardLtSeq$ otherwise.
% \[
  % \leq^1_n(x_1, \ldots, x_n) \equiv
    % \begin{cases}
      % \CardLtSeq & \text{if } n > 5 \\
      % \text{na\"ive} & \text{otherwise}
    % \end{cases}
% \]
% \todo[inline]{exactly one constraint}
An at most one constraint alone is not sufficient, as we need exactly one transition variable or the exit flag to be true in every step, such that our generated formula is not trivially satisfiable by never scheduling a single thread.
\todo[noline]{stuttering?}
Thus, we define the exactly one constraint predicate $=^1_n\!(x_1, \ldots, x_n)$ by simply adding a disjunction over all variables.% to $\CardLt$.
% The required exactly one constraint predicate $=^1_n(x_1, \ldots, x_n)$ as a conjunction of $\leq^1_n(x_1, \ldots, x_n)$ with a disjunction over all variables
% Let $=^1_n(x_1, \ldots, x_n)$ therefore be an exactly one constraint predicate.
\[
  %=^1_n(x_1, \ldots, x_n) \equiv
  (x_1 \lor \ldots \lor x_n) \; \land \CardLt
  % \CardLt \land (x_1 \lor \ldots \lor x_n)
\]
% \todo[inline]{actual constraint added}
% If we now redeclare $n$ to be the number of threads, the exactly one constraint used for non-deterministic scheduling of a single thread in step $k$ looks as follows.
If we redeclare $n$ as the number of threads, non-deterministic scheduling of a single thread in step $k$ can now be encoded by the following constraint.
% We are now able to state the actual exactly one constraint added to our formula as follows.
\[
  =^1_{2n + 1}\!(\THREAD^k_0, \ldots, \THREAD^k_{n-1}, \FLUSH^k_0, \ldots, \FLUSH^k_{n-1}, \EXIT^k)
\]
% \todo[inline]{scheduling influenced by constraints}
% restrictions by our machine model.
% To comply with our machine model, the cardinality constraint influenced under certain conditions.
% The scheduling constraint is influenced by  certain transitions
% influenced by disabling transition variables under certain conditions.
% to comply with our machine model,
% This cardinality constraint is further influenced by explicitly disabling transitions from certain states in order to meet the requirements of our machine model.

This cardinality constraint is further influenced by explicitly disabling transitions from certain states that are prohibited by our machine model.
% \todo[inline]{store buffer constraints}
% Blocking a thread $t$ not performing a store operation.
% Flushing an empty store buffer of a thread $t$, not containing any barrier \todo{atomic?} operation, can be prevented by a simple implication.
Flushing an empty store buffer of a thread $t$ can be prevented by a simple implication.
\[
  \lnot \SBFULL^k_t \implies \lnot \FLUSH^k_t
\]
% If thread $t$ contains a write together with a barrier operation, execution of the latter has to be restricted while the store is full.
In case thread $t$ containing a write, execution of any barrier operation has to be delayed while the store buffer is full.
% In this case, both mutually exclusive store buffer constraints are combined in a single expression by using
% Both store buffer constraints may be combined in a single expression by using $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$, a functional if-then-else, returning the $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$.
% If a write or barrier operation
% Otherwise,
Let $F_t$ be a set of statements requiring an empty store buffer
and $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$ be a functional if-then-else, returning $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$.
% Let $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$ be a functional if-then-else, returning $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$
\[
  \ITE(x, a, b) =
  \begin{cases}
    a \text{ if } x \text{ is } true \\
    b \text{ otherwise}
  \end{cases}
\]
% Blocking a thread $t$ about to execute a statement that requires the store buffer being empty.
% Set of statements requiring an empty store buffer $F_t$.
Since both store buffer related constraints mainly depend on mutually exclusive values of $\SBFULL^k_t$, we are able to encode them in a single expression.
\[
  \ITE(\SBFULL^k_t, \bigvee_{pc \in F_t} \STMT^k_{t, pc} \implies \lnot \THREAD^k_t, \lnot \FLUSH^k_t)
\]
% \todo[inline]{checkpoint constraints}
% Blocking a thread $t$, while it is waiting for all other threads reaching a checkpoint $id$ is expressed by a conjunction of the corresponding block flag $\BLOCK^k_{id, t}$ and helper variable $\CHECK^k_{id}$ implying a negated thread activation $\THREAD^k_t$.
Blocking a thread $t$, while it is waiting for all other threads reaching a checkpoint $id$ is implied by a conjunction of the corresponding block flag $\BLOCK^k_{id, t}$ and synchronization variable $\CHECK^k_{id}$.
\todo[noline]{unsat if deadlock by CHECK}
\[
  \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id} \implies \lnot \THREAD^k_t
\]
% \todo[inline]{halt constraints}
% Finally, a halted thread $t$ is also excluded from the cardinality constraint by disabling its activation variable.% by a simple implication.
% If a thread $t$ has finally halted, it is also excluded from the cardinality constraint.
Finally, if a thread $t$ has halted, it must also be stopped from being scheduled.
\[
  \HALT^k_t \implies \lnot \THREAD^k_t
\]

\subsubsection{Memory Access}

% \newcommand{\READ}{\texttt{read}}
\newcommand{\LOAD}{\texttt{load}}

% Let $\READ^k: \BVSORT \to \BVSORT$ be a function, returning a given element from array $\HEAP^k$.
% Due to store forwarding in combination with indirect addressing, memory access can not be expressed by simple array lookups, but turns out to be the most complicated part in our encoding scheme.
Due store forwarding, memory access can not be expressed as simple array lookups, but is encoded by a separate function $\LOAD^k_t: \BVSORT \to \BVSORT$ for loading the shared memory element at address $adr \in \BVSORT$ with store forwarding from thread $t$. % and indirect addressing signalled by $indirect \in \BVSORT[1]$, being defined as follows.
\begin{align*}
  \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t \land \SBADR^k_t = adr, \\
  & \SBVAL^k_t, \\
  & \READ^k(adr))
\end{align*}
In case of indirect addressing, $\LOAD^k_t$ is redefined as a single expression instead of a composition with itself to prevent dependency on certain features of the target language or the use of additional auxiliary variables.
\todo[noline]{repeated, iterative, recursive?}
\begin{align}
  \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t, \label{def:load:1} \\
  & \ITE(\SBADR^k_t = adr, \label{def:load:2} \\
  & \ITEindent \ITE(\SBVAL^k_t = adr, \label{def:load:3} \\
  & \ITEindent \ITEindent \SBVAL^k_t, \label{def:load:4} \\
  & \ITEindent \ITEindent \READ^k(\SBVAL^k_t)), \label{def:load:5} \\
  & \ITEindent \ITE(\SBADR^k_t = \READ^k(adr), \label{def:load:6} \\
  & \ITEindent \ITEindent \SBVAL^k_t, \label{def:load:7}\\
  & \ITEindent \ITEindent \READ^k(\READ^k(adr)))), \label{def:load:8} \\
  & \READ^k(\READ^k(adr))) \label{def:load:9}
\end{align}
\todo[noline]{use tabbing evironment?}
First, we check if the store buffer contains an entry and store forwarding might apply (\ref{def:load:1}).
%, or the requested value can be directly retrieved from memory (\ref{def:load:9}).
If it is empty, the requested value has to be directly retrieved from memory (\ref{def:load:9}).
% Otherwise, if the immediate address can be forwarded (\ref{def:load:2}), we must further check if it is equal to the effective address (\ref{def:load:3}) and either both (\ref{def:load:4}), or just the immediate address is forwarded (\ref{def:load:5}).
Otherwise, if the store buffer contains an entry for the given address (\ref{def:load:2}), we must further check if it is equal to the effective address (\ref{def:load:3}) to determine if either both (\ref{def:load:4}), or just the given address can be forwarded (\ref{def:load:5}).
% Otherwise, if the store buffer contains an entry for the immediate address (\ref{def:load:2}), we check if it is equal to the effective address (\ref{def:load:3}) and either return the store buffer value (\ref{def:load:4}) or the element at
% Otherwise, if the store buffer contains an entry for the immediate address (\ref{def:load:2}) and
% Finally, in case the given address could not be forwarded, the store buffer might contain an entry
% Finally, in case the given address was not contained,
Finally, in case there is no entry for the given address,
%we test if and either the effective address can be forwarded (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
the effective address is fetched from memory and compared to the store buffer address (\ref{def:load:6}) to see if it
% can be forwarded (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
% might be subject to store forwarding (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
might be contained (\ref{def:load:7}), or nothing can be forwarded after all (\ref{def:load:8}).
% fetch the effective address from memory and
% or nothing after all.
% and nothing could be forwarded after all.
% If the immediate address cannot be forwarded,

% If store forwaring does not apply because either the store buffer being empty or it neither contains the immediate nor the effective address,
% In case of indirect addressing, we first need to check if the store buffer is full (\ref{def:load:indirect:sbfull}) and the given base address can be forwarded (\ref{def:load:indirect:sbadr}).
% If a value for the base address is contained in the store buffer, we then check if this value

% \begin{align}
  % \LOAD^k_t(adr, indirect) = \ITE(& indirect, \\
  % & \ITE(\SBFULL^k_t, \label{def:load:sbfull} \\
  % & \ITEindent \ITE(\SBADR^k_t = adr, \label{def:load:indirect:sbadr} \\
  % & \ITEindent \ITEindent \ITE(\SBVAL^k_t = adr, \\
  % & \ITEindent \ITEindent \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \ITEindent \ITEindent \READ^k(\SBVAL^k_t)), \\
  % & \ITEindent \ITEindent \ITE(\SBADR^k_t = \READ^k(adr), \\
  % & \ITEindent \ITEindent \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \ITEindent \ITEindent \READ^k(\READ^k(adr)))), \\
  % & \ITEindent \READ^k(\READ^k(adr))), \\
  % & \ITE(\SBFULL^k_t \land \SBADR^k_t = adr, \\
  % & \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \READ^k(adr)))
% \end{align}

% \begin{itemize}
  % \item Nested array lookups if the store buffer is empty and store forwarding does not apply alltogether, or neither the indirect, nor the effective address can be forwarded.
  % \item The value contained in the store buffer if either the effective or both addresses can be forwarded.
% \end{itemize}

% store buffer empty: nested lookup

% \begin{enumerate}
  % \item nothing can be forwarded
  % \item only the indirect address can be forwarded
  % \item only the effective address can be forwarded
  % \item both addresses can be forwarded
% \end{enumerate}

% \[
  % \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t \land \SBADR^k_t = adr, \SBVAL^k_t, \READ^k(adr)))
% \]

% \ref{def:load:sbfull}

% \paragraph{Store Forwarding:} $\sbfull \; \land \; \sbadr = adr \land \accu = \sbval \lor \lnot (\sbfull \land \sbadr = adr)$

% \bigskip
\subsubsection{Frame Axioms}

\newcommand{\TRUE}{\textit{true}}
\newcommand{\FALSE}{\textit{false}}

\newcommand{\EFFECTIVE}{\texttt{effective}}
\newcommand{\MSB}{\texttt{msb}}

\todo[noline]{Successor State Axioms?}\noindent
% The effect of a particular operation, determined by the transition variables $\FLUSH^k_t$ and $\EXEC^k_{t, pc}$
% The effect of a thread $t$ flushing its store buffer or executing the instruction at $pc$ in step $k$
Successor states of transitions for all possible types of operations, determined by $\FLUSH^k_t$ and $\EXEC^k_{t, pc}$, are defined by the frame axioms in the table below.
% \todo[inline]{block}
All state variables, not explicitly altered are assumed to be unchanged in the next step, except the block flags $\BLOCK^{k + 1}_{id, t}$, which are reset if all threads synchronized upon checkpoint $id$.
\[
  \BLOCK^{k + 1}_{id, t} = \ITE(\CHECK^k_{id}, \FALSE, \BLOCK^k_{id, t})
\]
To further simplify the definition of axioms, two additional functions are introduced:
% Let $\EFFECTIVE^k: \BVSORT \to \BVSORT$ be a function for transparently selecting the effective address during $\texttt{STORE}$ or $\texttt{CAS}$ instructions.
$\MSB: \BVSORT \to \BVSORT[1]$ for retrieving the most significant bit of a given bitvector and $\EFFECTIVE^k: \BVSORT \to \BVSORT$ for transparently selecting the effective address during $\texttt{STORE}$ or $\texttt{CAS}$ instructions.
\[
  \EFFECTIVE^k(adr) =
  \begin{cases}
    \READ^k(adr) \text{ if indirect} \\
    adr \text{ otherwise}
  \end{cases}
\]
% and $\MSB: \BVSORT \to \BVSORT[1]$ a function for retrieving the most significant bit of a given bitvector.

% $\SLICE: \BVSORT \times \mathcal{N} \times \mathcal{N} \to \BVSORT[m]$

% \newcommand{\defaxiom}[1]{
    % \vspace{-0.4cm}
    % {\begin{align*}#1\end{align*}}
    % \vspace{-1.3cm}
% }
% \begin{longtabu}{lX[lm]}
  % \firsthline
    % \texttt{FLUSH} &
    % \vspace{-0.4cm}
    % {\begin{align*}
      % \HEAP^{k + 1} &= \WRITE^k(\SBADR^k_t, \SBVAL^k_t) \\
      % \SBFULL^{k + 1}_t &= false \\
    % \end{align*}}
    % \vspace{-1.3cm}
    % \\
  % \hline
  % \texttt{LOAD adr} &
    % \defaxiom{
      % \ACCU^{k + 1}_t &= \LOAD^k_t(\texttt{adr}) \\
      % \STMT^k_{t, pc} &= false \\
      % \STMT^k_{t, pc + 1} &= true \\
    % } \\
  % \hline
  % foo & bar \\
  % \lasthline
  % \caption{Frame Axioms}
  % \label{tbl:axioms}
% \end{longtabu}

% \doublerulesep=6pt
% \arrayrulewidth=1pt
% \doublerulesep=1.5 pt
% \everyrow{\hline\hline}

% \newcommand{\defaxiom}[2]{
  % \paragraph{#1} ~\\
  % \rule[0.5\baselineskip]{\textwidth}{0.1pt}\vspace{-1\baselineskip}\par\noindent
  % #2
% }

% \newpage
% \defaxiom
% {\texttt{FLUSH}}
% {
  % \begin{itemize}
    % \item[] $\HEAP^{k + 1} = \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$
    % \item[] $\SBFULL^{k + 1} = false$
  % \end{itemize}
% }

% \defaxiom
% {\texttt{LOAD arg}}
% {
  % \begin{itemize}
    % \item[] $\ACCU^{k + 1}_t = \LOAD^k_t(\texttt{adr})$
    % \item[] $\STMT^k_{t, pc} = false$
    % \item[] $\STMT^k_{t, pc + 1} = true$
  % \end{itemize}
% }

% \defaxiom
% {\texttt{STORE arg}}
% {
  % \begin{itemize}
    % \item[] $\SBADR^{k + 1}_t =
      % \begin{cases}
        % \READ^k(adr) \text{ if indirect} \\
        % adr \text{ otherwise}
      % \end{cases}$
    % \item[] $\SBVAL^{k + 1}_t = \ACCU^k_t$
    % \item[] $\STMT^k_{t, pc} = false$
    % \item[] $\STMT^k_{t, pc + 1} = true$
  % \end{itemize}
% }

% \newsavebox{\STORESBADRAXIOM}
% \savebox{\STORESBADRAXIOM}{
  % \hspace{-0.3cm}
  % $\begin{cases}
    % \READ^k(adr) \text{ if indirect} \\
    % adr \text{ otherwise}
  % \end{cases}$
% }

\newsavebox{\CASHEAPAXIOM}
\savebox{\CASHEAPAXIOM}{
  \hspace{-0.3cm}
  % $\begin{cases}
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
      % & \WRITE^k(\READ^k(\texttt{arg}), \ACCU^k_t), \\
      % & \HEAP^k)
    % \end{aligned}
    % \hspace{0.2cm}
    % \text{if indirect} \\
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
      % & \WRITE^k(\texttt{arg}, \ACCU^k_t), \\
      % & \HEAP^k)
    % \end{aligned}
    % \hspace{1.5cm}
    % \text{otherwise}
  % \end{cases}$

  $\begin{aligned}
    \ITE(& \MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), \\
    & \WRITE^k(\EFFECTIVE^k(\texttt{arg}), \ACCU^k_t), \\
    & \HEAP^k)
  \end{aligned}$
}

\newsavebox{\CASACCUAXIOM}
\savebox{\CASACCUAXIOM}{
  \hspace{-0.3cm}
  % $\begin{cases}
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
      % & 1, \\
      % & 0)
    % \end{aligned}
    % % \ITE(\MEM^k_t = \READ^k(\READ^k(\texttt{arg})), 1, 0)
    % \hspace{0.2cm}
    % \text{if indirect} \\
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
      % & 1, \\
      % & 0) \\
    % \end{aligned}
    % % \ITE(\MEM^k_t = \READ^k(\texttt{arg}), 1, 0)
    % \hspace{1.5cm}
    % \text{otherwise}
  % \end{cases}$

  $\begin{aligned}
    \ITE(& \MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), \\
    & 1, \\
    & 0)
  \end{aligned}$

  % $\ITE(\MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), 1, 0)$
}

% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\mybox} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
    % \lasthline
% \end{longtabu}

% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2}{*}{\texttt{FLUSH}}
    % & $\HEAP^{k + 1}$       & $= \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$ \\
    % & $\SBFULL^{k + 1}$     & $= false$ \\
  % \lasthline
% \end{longtabu}
% \vspace{-0.9cm}
% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{3}{*}{\texttt{LOAD adr}}
    % & $\ACCU^{k + 1}_t$     & $= \LOAD^k_t(\texttt{adr})$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  % \lasthline
% \end{longtabu}
% \vspace{-0.9cm}
% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\mybox} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  % \lasthline
% \end{longtabu}

% \setlength{\tabulinesep}{2pt}
% \setlength{\doublerulesep}{4pt}
\begin{longtabu}{llX[m]}
  \firsthline
  \multirow{2}{*}{\texttt{FLUSH}}
    & $\HEAP^{k + 1}$   & $= \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$ \\
    & $\SBFULL^{k + 1}$ & $= \FALSE$ \\
  \hline
  % \hhline{===}
  % \tabucline[2pt off 2pt]{-}
  \multirow{3.05}{*}{\texttt{LOAD arg}}
    & $\ACCU^{k + 1}_t$           & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \hhline{===}
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\STORESBADRAXIOM} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  \multirow{4}{*}{\texttt{STORE arg}}
    & $\SBADR^{k + 1}_t$          & $= \EFFECTIVE^k(\texttt{arg})$ \\
    & $\SBVAL^{k + 1}_t$          & $= \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \hhline{===}
  \multirow{2}{*}{\texttt{FENCE}}
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\texttt{ADD arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t + \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\texttt{ADDI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t + \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\texttt{SUB arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\texttt{SUBI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\texttt{MUL arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t * \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \newpage
  \hline
  \multirow{3.05}{*}{\texttt{MULI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t * \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3}{*}{\texttt{CMP arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{2}{*}{\texttt{JMP arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \TRUE$ \\
  \hline
  \multirow{3}{*}{\texttt{JZ arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \lnot \ACCU^k_t$ \\
  \hline
  \multirow{3}{*}{\texttt{JNZ arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \ACCU^k_t$ \\
  \hline
  \multirow{3}{*}{\texttt{JS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \MSB(\ACCU^k_t)$ \\
  \hline
  \multirow{3}{*}{\texttt{JNS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \lnot \MSB(\ACCU^k_t)$ \\
  \hline
  \multirow{3}{*}{\texttt{JNZNS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \ACCU^{k + 1}_t \lor \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \ACCU^{k + 1}_t \land \lnot \MSB(\ACCU^k_t)$ \\
  \hline
  \multirow{4}{*}{\texttt{MEM arg}}
    & $\ACCU^{k + 1}_t$           & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\MEM^{k + 1}_t$            & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + k}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \multirow{2.35}{*}{\texttt{CAS arg}}
  \multirow{2.97}{*}{\texttt{CAS arg}}
    & $\HEAP^{k + 1}$             & $=$ \usebox{\CASHEAPAXIOM} \\
    & $\ACCU^{k + 1}_t$           & $=$ \usebox{\CASACCUAXIOM} \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{2}{*}{\texttt{HALT}}
    % & $\EXIT^{k + 1}_t$ & $= \HALT^{k + 1}_0 \land \ldots \land \HALT^{k + 1}_{n - 1}$ \\
    & $\EXIT^{k + 1}_t$       & $= \displaystyle \bigwedge^{n - 1}_{i = 0} \HALT^{k + 1}_i$ \\
    & $\HALT^{k + 1}_t$       & $= \TRUE$ \\
    & $\STMT^{k + 1}_{t, pc}$ & $= \FALSE$ \\
  \hline
  \multirow{3}{*}{\texttt{EXIT arg}}
    & $\EXIT^{k + 1}_t$       & $= \TRUE$ \\
    & $\EXITCODE^{k + 1}$     & $= \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$ & $= \FALSE$ \\
  \hline
  \multirow{3}{*}{\texttt{CHECK arg}}
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
    & $\BLOCK^{k + 1}_{arg, t}$   & $= \TRUE$ \\
  \lasthline
  \caption{Frame Axioms}
  \label{tbl:axioms}
\end{longtabu}

% \vspace{0.2cm}
% \hlinE
% \VSPACE{0.1CM}
% \NOINDENT
% \BEGIN{TABU} TO \TEXTWIDTH {Lx[M]}
  % $\heap^{K + 1}$       & $= \write^K(\sbadr^K_T, \sbval^K_T)$ \\
  % $\sbfull^{K + 1}$     & $= FALSE$ \\
% \END{TABU}

% \PARAGRAPH{\TEXTTT{flush}}

% \VSPACE{0.2CM}
% \HLINE
% \VSPACE{0.1CM}
% \NOINDENT
% \BEGIN{TABU} TO \TEXTWIDTH {Lx[M]}
  % $\heap^{K + 1}$       & $= \write^K(\sbadr^K_T, \sbval^K_T)$ \\
  % $\sbfull^{K + 1}$     & $= FALSE$ \\
% \END{TABU}

% \[
% \texttt{compare}^k_t(adr) =
% \begin{cases}
  % \MEM^k_t = \READ^k(\READ^k(adr)) \text{ if indirect} \\
  % \MEM^k_t = \READ^k(adr) \text{ otherwise}
% \end{cases}
% \]

% $\HEAP^{k + 1} =
% \begin{cases}
  % \begin{aligned}
    % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
    % & \WRITE^k(\READ^k(\texttt{arg}), \ACCU^k_t) \\
    % & \HEAP^k)
  % \end{aligned}
  % \text{ if indirect} \\
  % \begin{aligned}
    % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
    % & \WRITE^k(\texttt{arg}, \ACCU^k_t) \\
    % & \HEAP^k)
  % \end{aligned}
  % \text{ otherwise}
% \end{cases}$

% Let $\texttt{define-accu}(k, t, pc)$ be the predicate defining the accumulator register state $\ACCU^k_t$ of thread $t$ in step $k$ and $pc$ the set of program counters, altering that state.% \todonote{refine}

% \paragraph{\texttt{LOAD adr}}

% \subsubsection{Statement Activation}

% \setlength{\tabulinesep}{2\lineskip}

\newpage
\subsection{SMT-Lib}

\newcommand{\Cpp}{C\texttt{++}17 }

% We will now outline the actual encoding process for SMT-Lib.
% We will now outline the process of generating SMT-Lib formulas for our model checking problems, following the previously defined encoding scheme.
We will now outline a simplistic \Cpp implementation for generating SMT-Lib formulas of our model checking problems, following the previously defined encoding scheme.
% We will now outline a simplistic \Cpp implementation for generating our model checking problems in the SMT-Lib format, following the previously defined encoding scheme.

\subsubsection{Types}
% \todo[inline]{types} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To differentiate among particular machine states, we start by introducing:% an \lstinline[style=c++]{enum} \texttt{State}.
% A \lstinline[style=c++]{enum} \texttt{State} is used to differentiate among machine states

% \begin{lstlisting}[style=c++]
% typedef uint16_t word_t;
% \end{lstlisting}

\begin{lstlisting}[style=c++]
enum State
{
  heap,
  accu,
  mem,
  sb_adr,
  sb_val,
  sb_full,
  stmt,
  block,
  halt,
  exit,
  exit_code
};
\end{lstlisting}
% All possible values contained in our machine's 16 bit registers are captured by the corresponding unsigned integer type \texttt{word_t}.
% \begin{lstlisting}[style=c++]
% using uint = unsigned;
% \end{lstlisting}
% Each available instruction is represented by it's own type, derived from an abstract class \texttt{Instruction}, capturing arguments and abolishing the need for lengthy case splits to determine the actual instruction at runtime by utilizing dynamic dispatch of member functions.
Each available instruction is represented by it's own type, derived from an abstract class \texttt{Instruction}, capturing arguments and abolishing the need for lengthy case splits by utilizing dynamic dispatch of member functions to take the appropriate action at runtime.%determine the type of instruction at runtime.
\begin{lstlisting}[style=c++]
struct Instruction
{
  uint arg;
  bool indirect;

  Instruction (uint a, bool i = false) : arg(a), indirect(i) {};

  virtual std::string encode (uint k, uint t, State state) = 0;
};
\end{lstlisting}
% virtual std::string encode (uint k, uint t, uint pc) = 0;

\subsubsection{Globals}

\noindent
Inputs and utility variables are given as globals to keep things simple and function signatures as small as possible.

% \todo[inline]{gobal variables} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[noline]{include halts, exits in alters?}

% programs
% \noindent
% \begin{minipage}{.3\textwidth}
  % \lstinputlisting[
    % language={[concubine]Assembler},
    % numbers=left,
    % firstnumber=0,
    % numberstyle=\footnotesize,
    % xleftmargin=0.39\textwidth
  % ]{../../examples/demo/processor.0.asm}
% \end{minipage}
% \begin{minipage}{.3\textwidth}
  % \lstinputlisting[
    % language={[concubine]Assembler},
    % numbers=left,
    % firstnumber=0,
    % numberstyle=\footnotesize,
    % xleftmargin=0.39\textwidth
  % ]{../../examples/demo/processor.1.asm}
% \end{minipage}
% \begin{minipage}{.3\textwidth}
  % \lstinputlisting[
    % language={[concubine]Assembler},
    % numbers=left,
    % firstnumber=0,
    % numberstyle=\footnotesize,
    % xleftmargin=0.39\textwidth
  % ]{../../examples/demo/checker.asm}
% \end{minipage}

% \noindent
% \begin{tabu}{|X|X|X|}
  % \hline
  % \textbf{Thread 0} & \textbf{Thread 1} & \textbf{Thread 2} \\
  % \hline
  % \texttt{ADDI 1}   & \texttt{ADDI 1}   & \\
  % \texttt{STORE 0}  & \texttt{STORE 1}  & \\
  % \texttt{LOAD 1}   & \texttt{LOAD 0}   & \\
  % \texttt{CHECK 0}  & \texttt{CHECK 0}  & \texttt{CHECK 0} \\
  % \texttt{HALT}     & \texttt{HALT}     & \texttt{ADD 0} \\
  % && \texttt{ADD 1} \\
  % && \texttt{JZ error} \\
  % && \texttt{EXIT 0} \\
  % && \texttt{error:} \texttt{EXIT 1} \\
  % \hline
% \end{tabu}

% \noindent
% \begin{tabu}{|X|X|X|}
  % \firsthline
  % \centering \textbf{Thread 0} & \centering \textbf{Thread 1} & \centering \textbf{Thread 2} \\
  % \hline
  % \hline
  % \begin{tabu}{lXX}
    % 0 & \lstinline[language={[concubine]Assembler}]{ADDI 1} & $\STMT^k_{0, 0}$ \\
    % 1 & \lstinline[language={[concubine]Assembler}]{STORE 0} & $\STMT^k_{0, 1}$ \\
    % 2 & \lstinline[language={[concubine]Assembler}]{LOAD 1} & $\STMT^k_{0, 1}$ \\
    % 3 & \lstinline[language={[concubine]Assembler}]{CHECK 0} & $\STMT^k_{0, 1}$ \\
    % 4 & \lstinline[language={[concubine]Assembler}]{HALT} & $\STMT^k_{0, 1}$ \\
  % \end{tabu}
  % &
  % \begin{tabu}{lXX}
    % 0 & \lstinline[language={[concubine]Assembler}]{ADDI 1} & $\STMT^k_{0, 1}$ \\
    % 1 & \lstinline[language={[concubine]Assembler}]{STORE 1} & $\STMT^k_{0, 1}$ \\
    % 2 & \lstinline[language={[concubine]Assembler}]{LOAD 0} & $\STMT^k_{0, 1}$ \\
    % 3 & \lstinline[language={[concubine]Assembler}]{CHECK 0} & $\STMT^k_{0, 1}$ \\
    % 4 & \lstinline[language={[concubine]Assembler}]{HALT} & $\STMT^k_{0, 1}$ \\
  % \end{tabu}
  % &
  % \begin{tabu}{lXX}
    % & \\
    % & \\
    % & \\
    % 0 & \lstinline[language={[concubine]Assembler}]{CHECK 0} & $\STMT^k_{0, 1}$ \\
    % 1 & \lstinline[language={[concubine]Assembler}]{ADD 0} & $\STMT^k_{0, 1}$ \\
    % 2 & \lstinline[language={[concubine]Assembler}]{ADD 1} & $\STMT^k_{0, 1}$ \\
    % 3 & \lstinline[language={[concubine]Assembler}]{JZ error} & $\STMT^k_{0, 1}$ \\
    % 4 & \lstinline[language={[concubine]Assembler}]{EXIT 0} & $\STMT^k_{0, 1}$ \\
    % 5 & \lstinline[language={[concubine]Assembler}]{error: EXIT 1} & $\STMT^k_{0, 1}$ \\
  % \end{tabu} \\
  % \lasthline
% \end{tabu}

\begin{table}
\begin{tabu}{|c|c|c|}
  \firsthline
  % \begin{tabu}{c} \textbf{Thread 0} \end{tabu} &
  % \begin{tabu}{c} \textbf{Thread 1} \end{tabu} &
  % \begin{tabu}{c} \textbf{Thread 2} \end{tabu} \\
  \textbf{Thread 0} & \textbf{Thread 1} & \textbf{Thread 2} \\
  \hline
  \hline
  \begin{tabu}{ll}
    \lstinline[language={[concubine]Assembler}]{ADDI 1}   & $\STMT^k_{0, 0}$ \\
    \lstinline[language={[concubine]Assembler}]{STORE 0}  & $\STMT^k_{0, 1}$ \\
    \lstinline[language={[concubine]Assembler}]{LOAD 1}   & $\STMT^k_{0, 2}$ \\
    \lstinline[language={[concubine]Assembler}]{CHECK 0}  & $\STMT^k_{0, 3}$ \\
    \lstinline[language={[concubine]Assembler}]{HALT}     & $\STMT^k_{0, 4}$ \\
  \end{tabu}
  &
  \begin{tabu}{ll}
    \lstinline[language={[concubine]Assembler}]{ADDI 1}   & $\STMT^k_{1, 0}$ \\
    \lstinline[language={[concubine]Assembler}]{STORE 1}  & $\STMT^k_{1, 1}$ \\
    \lstinline[language={[concubine]Assembler}]{LOAD 0}   & $\STMT^k_{1, 2}$ \\
    \lstinline[language={[concubine]Assembler}]{CHECK 0}  & $\STMT^k_{1, 3}$ \\
    \lstinline[language={[concubine]Assembler}]{HALT}     & $\STMT^k_{1, 4}$ \\
  \end{tabu}
  &
  \begin{tabu}{ll}
    & \\
    & \\
    & \\
    \lstinline[language={[concubine]Assembler}]{CHECK 0}        & $\STMT^k_{2, 0}$ \\
    \lstinline[language={[concubine]Assembler}]{ADD 0}          & $\STMT^k_{2, 1}$ \\
    \lstinline[language={[concubine]Assembler}]{ADD 1}          & $\STMT^k_{2, 2}$ \\
    \lstinline[language={[concubine]Assembler}]{JZ error}       & $\STMT^k_{2, 3}$ \\
    \lstinline[language={[concubine]Assembler}]{EXIT 0}         & $\STMT^k_{2, 4}$ \\
    \lstinline[language={[concubine]Assembler}]{error: EXIT 1}  & $\STMT^k_{2, 5}$ \\
  \end{tabu} \\
  \lasthline
\end{tabu}
\caption{Store buffer litmus test programs and their activation variables.}
\label{tbl:programs}
\end{table}

% \noindent
% \begin{tabu}{|XX[r]|XX[r]|lr|}
  % \hline
  % \multicolumn{2}{|c|}{\textbf{Thread 0}} & \multicolumn{2}{c|}{\textbf{Thread 1}} & \multicolumn{2}{c|}{\textbf{Thread 2}} \\
  % \hline
  % \texttt{ADDI 1}   & $\STMT^k_{0, 0}$  & \texttt{ADDI 1}   & $\STMT^k_{1, 0}$  && \\
  % \texttt{STORE 0}  & $\STMT^k_{0, 1}$  & \texttt{STORE 1}  & $\STMT^k_{1, 1}$  && \\
  % \texttt{LOAD 1}   & $\STMT^k_{0, 2}$  & \texttt{LOAD 0}   & $\STMT^k_{1, 2}$  && \\
  % \texttt{CHECK 0}  & $\STMT^k_{0, 3}$  & \texttt{CHECK 0}  & $\STMT^k_{1, 3}$  & \texttt{CHECK 0} & $\STMT^k_{2, 0}$ \\
  % \texttt{HALT}     & $\STMT^k_{0, 4}$  & \texttt{HALT}     & $\STMT^k_{1, 4}$  & \texttt{ADD 0}         & $\STMT^k_{2, 1}$ \\
  % &&&& \texttt{ADD 1}         & $\STMT^k_{2, 2}$ \\
  % &&&& \texttt{JZ error}      & $\STMT^k_{2, 3}$ \\
  % &&&& \texttt{EXIT 0}        & $\STMT^k_{2, 4}$ \\
  % &&&& \texttt{error:} \texttt{EXIT 1} & $\STMT^k_{2, 5}$ \\
  % \hline
% \end{tabu}

Input programs are given as a list of instructions.

\begin{lstlisting}[style=c++]
// list of programs being encoded (index == thread id)
//
std::vector<std::vector<Instruction *>> programs = {
  {
    new Addi(1),
    new Store(0),
    new Load(1),
    new Check(0),
    new Halt()
  },
  {
    new Addi(1),
    new Store(1),
    new Load(0),
    new Check(0),
    new Halt()
  },
  {
    new Check(0),
    new Add(0),
    new Add(1),
    new Jz(5),
    new Exit(0),
    new Exit(1)
  }
};
\end{lstlisting}

\begin{lstlisting}[style=c++]
// bound
//
uint bound = 17;
\end{lstlisting}

\begin{lstlisting}[style=c++]
// initial memory layout
//
std::map<uint, uint> mmap = {{0, 0}, {1, 0}};
\end{lstlisting}

\begin{lstlisting}[style=c++]
// SMT formula buffer
//
std::ostringstream formula;
\end{lstlisting}

\begin{lstlisting}[style=c++]
// pcs of statements updating a specific state
//
// State -> thread -> list of program counters
//
std::map<State, std::map<uint, std::vector<uint>>> updates = {
  { State::accu, {
    {0, {0, 2}},
    {1, {0, 2}},
    {2, {1, 2}}
  }},
  { State::sb_adr, {
    {0, {1}},
    {1, {1}}
  }},
  { State::sb_val, {
    {0, {1}},
    {1, {1}}
  }},
  { State::sb_full, {
    {0, {1}},
    {1, {1}}
  }},
  { State::halt, { // ?
    {0, {4}},
    {1, {4}}
  }},
  { State::exit, { // ?
    {2, {4, 5}},
  }}
};
\end{lstlisting}

\begin{lstlisting}[style=c++]
// list of predecessors for each thread
//
// thread -> pc -> set of predecessors
//
std::vector<std::map<uint, std::set<uint>>> predecessors = {
  {{0, {}}, {1, {0}}, {2, {1}}, {3, {2}}, {4, {3}}},
  {{0, {}}, {1, {0}}, {2, {1}}, {3, {2}}, {4, {3}}},
  {{0, {}}, {1, {0}}, {2, {1}}, {3, {2}}, {4, {3}}, {5, {3}}}
};
\end{lstlisting}

\begin{lstlisting}[style=c++]
// pcs of statements requiring an empty store buffer
//
// thread -> list of program counters
//
std::map<uint, std::vector<uint>> barriers = {
  {0, {1, 4}},
  {1, {1, 4}}
};
\end{lstlisting}

\begin{lstlisting}[style=c++]
// pcs of checkpoint statements
//
// checkpoint id -> thread -> list of program counters
//
std::map<uint, std::map<uint, std::vector<uint>>> checkpoints = {
  {0, {{0, {3}},
       {1, {3}},
       {2, {0}}}}
};
\end{lstlisting}

% \begin{lstlisting}[style=c++]
% // pcs of halt statements
% //
% // thread -> list of program counters
% //
% std::map<uint, std::vector<uint>> halts = {{0, {4}}, {1, {4}}};
% \end{lstlisting}

% \begin{lstlisting}[style=c++]
% // pcs of exit calls
% //
% // thread -> list of program counters
% //
% std::map<uint, std::vector<uint>> exits = {{2, {4, 5}}};
% \end{lstlisting}

\subsubsection{smtlib generator functions}
\todo[inline]{smtlib generator functions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
template <class ... T>
std::string expr (const char * op, const T & ... args)
{
  std::string e = '(' + op;
  (((e += ' ') += args), ...);
  return e += ')';
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
template <template <class, class...> class C>
std::string expr (const char * op, const C<std::string> & args)
{
  std::string e = '(' + op;
  for (const auto & a : args)
    (e += ' ') += a;
  return e += ')';
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string assertion (std::string arg)
{
  return expr("assert", arg);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string lnot (std::string arg)
{
  return expr("not", arg);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string land (const std::string & arg) { return arg; }

template <class ... T>
std::string land (const std::string & arg, const T & ... args)
{
  return expr("and", arg, args...);
}

template <template<class, class...> class C>
std::string land (const C<std::string> & args)
{
  return args.size() < 2 ? *args.begin() : expr("and", args);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string lor (const std::string & arg) { return arg; }

template <class ... T>
std::string lor (const std::string & arg, const T & ... args)
{
  return expr("or", arg, args...);
}

template <template<class, class...> class C>
std::string lor (const C<std::string> & args)
{
  return args.size() < 2 ? *args.begin() : expr("or", args);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string lxor (const std::string & arg) { return arg; }

template <class ... T>
std::string lxor (const std::string & arg, const T & ... args)
{
  return expr("xor", arg, args...);
}

template <template<class, class...> class C>
std::string lxor (const C<std::string> & args)
{
  return args.size() < 2 ? *args.begin() : expr("xor", args);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string implication (std::string antecedent, std::string consequent)
{
  return expr("=>", antecedent, consequent);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string equality (std::string var, std::string val)
{
  return expr("=", var, val);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string ite (std::string condition, std::string t, std::string f)
{
  return expr("ite", condition, t, f);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string bvadd (std::string a, std::string b)
{
  return expr("bvadd", a, b);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string bvsub (std::string a, std::string b)
{
  return expr("bvsub", a, b);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string bvmul (std::string a, std::string b)
{
  return expr("bvmul", a, b);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string select (std::string var, std::string idx)
{
  return expr("select", var, idx);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string to_hex (uint val)
{
  std::ostringstream s;
  s << "#x" << std::setfill('0') << std::setw(4) << std::hex << val;
  return s.str();
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string store (std::string var, std::string idx, std::string val)
{
  return expr("store", var, idx, val);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string extract (std::string msb, std::string lsb, std::string var)
{
  return expr(expr("_ extract", msb, lsb).c_str(), var);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string declare_bool_var (std::string name)
{
  // return "(declare-fun " + name + " () Bool)";
  return expr("declare-fun", {name, "()", "Bool"});
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string declare_bv_var (std::string name)
{
  // return "(declare-fun " + name + " () (_ BitVec 16))";
  return expr("declare-fun", {name, "()", "(_ BitVec 16)"});
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string declare_array_var (std::string name)
{
  // return "(declare-fun "
  //        + name
  //        + " (Array (_ BitVec 16) (_ BitVec 16)))";
  static const char * sort = "(_ BitVec 16)";
  return expr("declare-fun", name, expr("Array", sort, sort));
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string assign (std::string var, std::string val)
{
  return assertion(equality(var, val));
}
\end{lstlisting}

\subsubsection{main encoding function}
\todo[inline]{main encoding function (smtlib)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void encode ()
{
  formula << "(set-logic QF_AUFBV)" << eol << eol;

  for (uint k = 0; k <= bound; k++)
    {
      declare_states(k);
      declare_transitions(k);
      define_transitions(k);
      define_constraints (k);

      if (k)
        define_states(k);
      else
        init_states();
    }
}
\end{lstlisting}

\subsubsection{declare states}
\todo[inline]{declare states} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void declare_states (uint k)
{
  // thread states
  declare_accu(k);
  declare_mem(k);
  declare_sb_adr(k);
  declare_sb_val(k);
  declare_sb_full(k);
  declare_stmt(k);
  declare_block(k);
  declare_halt(k);

  // machine states
  declare_heap(k);
  declare_exit_flag(k);

  if (!k) declare_exit_code();
}
\end{lstlisting}

\subsubsection{declare accu}
\todo[inline]{declare accu} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% template <template<class, class...> class C>
% std::string var (std::string name, C<uint> attributes)
% {
  % for (const auto & attr : attributes)
    % (name += '_') += std::to_string(attr);
%
  % return name;
% }
% \end{lstlisting}

\begin{lstlisting}[style=c++]
template <class ... T>
std::string var (std::string name, const T & ... attributes)
{
  return (((name += '_') += std::to_string(attributes)), ...);
}
\end{lstlisting}

% return "accu_" + std::to_string(k) + '_' + std::to_string(t);
\begin{lstlisting}[style=c++]
std::string accu_var (uint k, uint t)
{
  return var("accu", k, t);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_accu (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    formula << declare_bv_var(accu_var(k, t)) << eol;
  formula << eol;
}
\end{lstlisting}

% \lstinputlisting[language=SMTLib, linerange={9-12}]{../../examples/demo/formula.functional.smt2}
\begin{lstlisting}[language=SMTLib]
; accu variables - accu_<step>_<thread>
(declare-fun accu_0_0 () (_ BitVec 16))
(declare-fun accu_0_1 () (_ BitVec 16))
(declare-fun accu_0_2 () (_ BitVec 16))
\end{lstlisting}

\subsubsection{declare mem}
\todo[inline]{declare mem} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string mem_var (uint k, uint t)
{
  return var("mem", k, t);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_mem (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    formula << declare_bv_var(mem_var(k, t)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; mem variables - mem_<step>_<thread>
(declare-fun mem_0_0 () (_ BitVec 16))
(declare-fun mem_0_1 () (_ BitVec 16))
(declare-fun mem_0_2 () (_ BitVec 16))
\end{lstlisting}

\subsubsection{declare sb-adr}
\todo[inline]{declare sb-adr} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string sb_adr_var (uint k, uint t)
{
  return var("sb-adr", k, t);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_sb_adr (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    formula << declare_bv_var(sb_adr_var(k, t)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer address variables - sb-adr_<step>_<thread>
(declare-fun sb-adr_0_0 () (_ BitVec 16))
(declare-fun sb-adr_0_1 () (_ BitVec 16))
(declare-fun sb-adr_0_2 () (_ BitVec 16))
\end{lstlisting}

\subsubsection{declare sb-val}
\todo[inline]{declare sb_val} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string sb_val_var (uint k, uint t)
{
  return var("sb-val", k, t);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_sb_val (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    formula << declare_bv_var(sb_val_var(k, t)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer value variables - sb-val_<step>_<thread>
(declare-fun sb-val_0_0 () (_ BitVec 16))
(declare-fun sb-val_0_1 () (_ BitVec 16))
(declare-fun sb-val_0_2 () (_ BitVec 16))
\end{lstlisting}

\subsubsection{declare sb-full}
\todo[inline]{declare sb_full} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string sb_full_var (uint k, uint t)
{
  return var("sb-full", k, t);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_sb_full (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    formula << declare_bool_var(sb_full_var(k, t)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer full variables - sb-full_<step>_<thread>
(declare-fun sb-full_0_0 () Bool)
(declare-fun sb-full_0_1 () Bool)
(declare-fun sb-full_0_2 () Bool)
\end{lstlisting}

\subsubsection{declare stmt}
\todo[inline]{declare stmt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string stmt_var (uint k, uint t, uint pc)
{
  return var("stmt", k, t, pc);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_stmt (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    for (uint pc = 0; pc < programs[t].size(); pc++)
      formula << declare_bool_var(stmt_var(k, t, pc)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; statement activation variables - stmt_<step>_<thread>_<pc>
(declare-fun stmt_0_0_0 () Bool)
(declare-fun stmt_0_0_1 () Bool)
(declare-fun stmt_0_0_2 () Bool)
(declare-fun stmt_0_0_3 () Bool)
(declare-fun stmt_0_0_4 () Bool)

(declare-fun stmt_0_1_0 () Bool)
(declare-fun stmt_0_1_1 () Bool)
(declare-fun stmt_0_1_2 () Bool)
(declare-fun stmt_0_1_3 () Bool)
(declare-fun stmt_0_1_4 () Bool)

(declare-fun stmt_0_2_0 () Bool)
(declare-fun stmt_0_2_1 () Bool)
(declare-fun stmt_0_2_2 () Bool)
(declare-fun stmt_0_2_3 () Bool)
(declare-fun stmt_0_2_4 () Bool)
(declare-fun stmt_0_2_5 () Bool)
\end{lstlisting}

\subsubsection{declare block}
\todo[inline]{declare block} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string block_var (uint k, uint id, uint t)
{
  return var("block", k, id, t);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_block (uint k)
{
  for (const auto & [id, threads] : checkpoints)
    {
      for (const auto & [t, _] : threads)
        formula << declare_bool_var(block_var(k, id, t)) << eol;
      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; blocking variables - block_<step>_<id>_<thread>
(declare-fun block_0_0_0 () Bool)
(declare-fun block_0_0_1 () Bool)
(declare-fun block_0_0_2 () Bool)
\end{lstlisting}

\subsubsection{declare halt}
\todo[inline]{declare halt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string halt_var (uint k, uint t)
{
  return var("halt", k, t);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_halt (uint k)
{
  for (const auto & [t, _] : halts)
    formula << declare_bool_var(halt_var(k, t)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; halt variables - halt_<step>_<thread>
(declare-fun halt_0_0 () Bool)
(declare-fun halt_0_1 () Bool)
(declare-fun halt_0_2 () Bool)
\end{lstlisting}

\subsubsection{declare heap}
\todo[inline]{declare heap} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string heap_var (uint k)
{
  return var("heap", k);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_heap (uint k)
{
  formula << declare_array_var(heap_var(k, t)) << eol << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; heap variable - heap_<step>
(declare-fun heap_0 () (Array (_ BitVec 16) (_ BitVec 16)))
\end{lstlisting}

\subsubsection{declare exit-flag}
\todo[inline]{declare exit-flag} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string exit_flag_var (uint k)
{
  return var("exit", k);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_exit_flag (uint k)
{
  if (halts.empty() && exits.empty())
    return;

  formula << declare_bool_var(exit_flag_var(k)) << eol << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; exit flag variable - exit_<step>
(declare-fun exit_0 () Bool)
\end{lstlisting}

\subsubsection{declare exit-code}
\todo[inline]{declare exit-code} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string exit_code_var = "exit-code";
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_exit_code (uint k)
{
  formula << declare_bv_var(exit_code_var) << eol << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; exit code variable
(declare-fun exit-code () (_ BitVec 16))
\end{lstlisting}

\subsubsection{declare transitions}
\todo[inline]{declare transitions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void declare_transitions (uint k)
{
  declare_thread(k);
  declare_exec(k);
  declare_flush(k);
  declare_check(k);
}
\end{lstlisting}

\subsubsection{declare thread}
\todo[inline]{declare thread} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string thread_var (uint k, uint t)
{
  return var("thread", k, t);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_thread (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    formula << declare_bool_var(thread_var(k, t)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; thread activation variables - thread_<step>_<thread>
(declare-fun thread_0_0 () Bool)
(declare-fun thread_0_1 () Bool)
(declare-fun thread_0_2 () Bool)
\end{lstlisting}

\subsubsection{declare exec}
\todo[inline]{declare exec} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string exec_var (uint k, uint t, uint pc)
{
  return var("exec", k, t, pc);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_exec (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    for (uint pc = 0; pc < programs[t].size(); pc++)
      formula << declare_bool_var(exec_var(k, t, pc)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; statement execution variables - exec_<step>_<thread>_<pc>
(declare-fun exec_0_0_0 () Bool)
(declare-fun exec_0_0_1 () Bool)
(declare-fun exec_0_0_2 () Bool)
(declare-fun exec_0_0_3 () Bool)
(declare-fun exec_0_0_4 () Bool)

(declare-fun exec_0_1_0 () Bool)
(declare-fun exec_0_1_1 () Bool)
(declare-fun exec_0_1_2 () Bool)
(declare-fun exec_0_1_3 () Bool)
(declare-fun exec_0_1_4 () Bool)

(declare-fun exec_0_2_0 () Bool)
(declare-fun exec_0_2_1 () Bool)
(declare-fun exec_0_2_2 () Bool)
(declare-fun exec_0_2_3 () Bool)
(declare-fun exec_0_2_4 () Bool)
(declare-fun exec_0_2_5 () Bool)
\end{lstlisting}

\subsubsection{declare flush}
\todo[inline]{declare flush} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string flush_var (uint k, uint t)
{
  return var("flush", k, t);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_flush (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    formula << declare_bool_var(flush_var(k, t)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer flush variables - flush_<step>_<thread>
(declare-fun flush_0_0 () Bool)
(declare-fun flush_0_1 () Bool)
(declare-fun flush_0_2 () Bool)
\end{lstlisting}

\subsubsection{declare check}
\todo[inline]{declare check} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string check_var (uint k, uint id)
{
  return var("check", k, id);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_check (uint k)
{
  if (checkpoints.empty())
    return;

  for (const auto & [id, _] : checkpoints)
    formula << declare_bool_var(check_var(k, id)) << eol;

  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; checkpoint variables - check_<step>_<id>
(declare-fun check_0_0 () Bool)
\end{lstlisting}

\subsubsection{define transitions}
\todo[inline]{define transitions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_transitions (uint k)
{
  define_exec(k);
  define_check(k);
}
\end{lstlisting}

\subsubsection{define exec}
\todo[inline]{define exec} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_exec (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    {
      for (uint pc = 0; pc < programs[t].size(); pc++)
        formula << assign(exec(k, t, pc),
                          land(stmt(k, t, pc),
                               thread(k, t))) << eol;
      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; statement execution variables - exec_<step>_<thread>_<pc>
(assert (= exec_0_0_0 (and stmt_0_0_0 thread_0_0)))
(assert (= exec_0_0_1 (and stmt_0_0_1 thread_0_0)))
(assert (= exec_0_0_2 (and stmt_0_0_2 thread_0_0)))
(assert (= exec_0_0_3 (and stmt_0_0_3 thread_0_0)))
(assert (= exec_0_0_4 (and stmt_0_0_4 thread_0_0)))

(assert (= exec_0_1_0 (and stmt_0_1_0 thread_0_1)))
(assert (= exec_0_1_1 (and stmt_0_1_1 thread_0_1)))
(assert (= exec_0_1_2 (and stmt_0_1_2 thread_0_1)))
(assert (= exec_0_1_3 (and stmt_0_1_3 thread_0_1)))
(assert (= exec_0_1_4 (and stmt_0_1_4 thread_0_1)))

(assert (= exec_0_2_0 (and stmt_0_2_0 thread_0_2)))
(assert (= exec_0_2_1 (and stmt_0_2_1 thread_0_2)))
(assert (= exec_0_2_2 (and stmt_0_2_2 thread_0_2)))
(assert (= exec_0_2_3 (and stmt_0_2_3 thread_0_2)))
(assert (= exec_0_2_4 (and stmt_0_2_4 thread_0_2)))
(assert (= exec_0_2_5 (and stmt_0_2_5 thread_0_2)))
\end{lstlisting}

\subsubsection{define check}
\todo[inline]{define check} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_check (uint k)
{
  if (checkpoints.empty())
    return;

  for (const auto & [id, threads] : checkpoints)
    if (k)
      {
        std::vector<std::string> args;
        for (const auto & [t, _] : threads)
          args.push_back(block_var(k, id, t));
        formula << assign(check_var(k, id), land(args)) << eol;
      }
    else
      {
        formula << assertion(lnot(check_var(k, id))) << eol;
      }

  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; checkpoint variables - check_<step>_<id>
(assert (not check_0_0))
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; checkpoint variables - check_<step>_<id>
(assert (= check_1_0 (and block_1_0_0 block_1_0_1 block_1_0_2)))
\end{lstlisting}

\subsubsection{define constraints}
\todo[inline]{define constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_constraints (uint k)
{
  define_scheduling_constraints(k);
  define_store_buffer_constraints(k);
  define_checkpoint_constraints(k);
  define_halt_constraints(k);
}
\end{lstlisting}

\subsubsection{define scheduling constraints}
\todo[inline]{define scheduling constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string card_constraint_naive (std::vector<std::string> vars)
{
  switch (vars.size())
    {
    case 1: return assertion(vars.front()) += eol;
    case 2: return assertion(lxor(vars)) += eol;
    default: break;
    }

  // >= 1 constraint
  std::string constraint = assertion(lor(vars)) += eol;

  // <= 1 constraint
  for (auto it1 = vars.begin(); it1 != vars.end(); ++it1)
    for (auto it2 = it1 + 1; it2 != vars.end(); ++it2)
      (constraint += assertion(lor(lnot(*it1), lnot(*it2)))) += eol;

  return constraint;
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string card_constraint_sinz (std::vector<std::string> vars)
{
  switch (vars.size())
    {
    case 1: return assertion(vars.front()) + eol;
    case 2: return assertion(lxor(vars)) + eol;
    default: break;
    }

  std::string constraint;

  // n-1 auxiliary variables
  std::vector<std::string> auxs;

  const auto end = --vars.end();

  for (auto it = vars.begin(); it != end; ++it)
    constraint += declare_bool_var(auxs.emplace_back(*it + "_aux"))
                  + eol;

  // >= 1 constraint
  constraint += eol + assertion(lor(vars)) + eol;

  // <= 1 constraint
  auto var = vars.begin();
  auto aux = auxs.begin();

  constraint += assertion(lor(lnot(*var), *aux));
  constraint += eol;

  while (++var != end)
    {
      const std::string & aux_prev = *aux++;

      constraint += assertion(lor(lnot(*var), *aux));
      constraint += eol;
      constraint += assertion(lor(lnot(aux_prev), *aux));
      constraint += eol;
      constraint += assertion(lor(lnot(*var), lnot(aux_prev)));
      constraint += eol;
    }

  constraint += assertion(lor(lnot(*var), lnot(*aux)));
  constraint += eol;

  return constraint;
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
void define_scheduling_constraints (uint k)
{
  std::vector<std::string> vars;

  for (uint t = 0; t < programs.size(); t++)
    {
      vars.push_back(thread_var(k, t));
      vars.push_back(flush_var(k, t));
    }

  if (!halts.empty() || !exits.empty())
    vars.push_back(exit_flag_var(k));

  formula << (use_sinz_constraint ? card_constraint_sinz(vars)
                                  : card_constraint_naive(vars))
          << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(declare-fun thread_0_0_aux () Bool)
(declare-fun flush_0_0_aux () Bool)
(declare-fun thread_0_1_aux () Bool)
(declare-fun flush_0_1_aux () Bool)
(declare-fun thread_0_2_aux () Bool)
(declare-fun flush_0_2_aux () Bool)

(assert (or thread_0_0 flush_0_0
            thread_0_1 flush_0_1
            thread_0_2 flush_0_2
            exit_0))
(assert (or (not thread_0_0) thread_0_0_aux))
(assert (or (not flush_0_0) flush_0_0_aux))
(assert (or (not thread_0_0_aux) flush_0_0_aux))
(assert (or (not flush_0_0) (not thread_0_0_aux)))
(assert (or (not thread_0_1) thread_0_1_aux))
(assert (or (not flush_0_0_aux) thread_0_1_aux))
(assert (or (not thread_0_1) (not flush_0_0_aux)))
(assert (or (not flush_0_1) flush_0_1_aux))
(assert (or (not thread_0_1_aux) flush_0_1_aux))
(assert (or (not flush_0_1) (not thread_0_1_aux)))
(assert (or (not thread_0_2) thread_0_2_aux))
(assert (or (not flush_0_1_aux) thread_0_2_aux))
(assert (or (not thread_0_2) (not flush_0_1_aux)))
(assert (or (not flush_0_2) flush_0_2_aux))
(assert (or (not thread_0_2_aux) flush_0_2_aux))
(assert (or (not flush_0_2) (not thread_0_2_aux)))
(assert (or (not exit_0) (not flush_0_2_aux)))
\end{lstlisting}

\subsubsection{define store buffer constraints}
\todo[inline]{define store buffer constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_store_buffer_constraints (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    if (barriers.find(thread) != barriers.end())
      {
        std::vector<std::string> stmts;
        for (const auto & pc : barriers[t])
          stmts.push_back(stmt_var(k, t, pc));
        formula
          << assertion(ite(sb_full_var(),
                           implication(lor(stmts),
                                       lnot(thread_var(k, t))),
                           lnot(flush_var(k, t))))
          << eol;
      }
    else
      formula << assertion(implication(lnot(sb_full_var(k, t)),
                                       lnot(flush_var(k, t))))
              << eol;

  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (ite sb-full_1_0
             (=> (or stmt_1_0_1 stmt_1_0_4) (not thread_1_0))
             (not flush_1_0)))
(assert (ite sb-full_1_1
             (=> (or stmt_1_1_1 stmt_1_1_4) (not thread_1_1))
             (not flush_1_1)))
(assert (=> (not sb-full_1_2) (not flush_1_2)))
\end{lstlisting}

\subsubsection{define checkpoint constraints}
\todo[inline]{define checkpoint constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_checkpoint_constraints (uint k)
{
  for (const auto & [id, threads] : checkpoints)
    {
      for (const auto & [t, _] : threads)
        {
          formula
            << assertion(implication(land(block_var(k, id, t),
                                          lnot(check_var(k, id))),
                                     lnot(thread_var(k, t))))
            << eol;
        }
      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (=> (and block_1_0_0 (not check_1_0)) (not thread_1_0)))
(assert (=> (and block_1_0_1 (not check_1_0)) (not thread_1_1)))
(assert (=> (and block_1_0_2 (not check_1_0)) (not thread_1_2)))
\end{lstlisting}

\subsubsection{define halt constraints}
\todo[inline]{define halt constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_halt_constraints (uint k)
{
  if (halts.empty())
    return;

  for (const auto & [t, _] : halts)
    formula << assertion(implication(halt_var(k, t),
                                     lnot(thread_var(k, t))))
            << eol;

  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (=> halt_1_0 (not thread_1_0)))
(assert (=> halt_1_1 (not thread_1_1)))
\end{lstlisting}

\subsubsection{init states}
\todo[inline]{init states} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_states ()
{
  init_accu();
  init_mem();
  init_sb_adr();
  init_sb_val();
  init_sb_full();
  init_stmt();
  init_block();
  init_halt();

  init_heap();
  init_exit_flag();
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
\end{lstlisting}

\subsubsection{init accu}
\todo[inline]{init accu} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_accu ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assign(accu_var(k, t), to_hex(0)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; accu variables - accu_<step>_<thread>
(assert (= accu_0_0 #x0000))
(assert (= accu_0_1 #x0000))
(assert (= accu_0_2 #x0000))
\end{lstlisting}

\subsubsection{init mem}
\todo[inline]{init mem} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_mem ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assign(mem_var(k, t), to_hex(0)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; mem variables - mem_<step>_<thread>
(assert (= mem_0_0 #x0000))
(assert (= mem_0_1 #x0000))
(assert (= mem_0_2 #x0000))
\end{lstlisting}

\subsubsection{init sb-adr}
\todo[inline]{init sb-adr} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_sb_adr ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assign(sb_adr_var(k, t), to_hex(0)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer address variables - sb-adr_<step>_<thread>
(assert (= sb-adr_0_0 #x0000))
(assert (= sb-adr_0_1 #x0000))
(assert (= sb-adr_0_2 #x0000))
\end{lstlisting}

\subsubsection{init sb-val}
\todo[inline]{init sb-val} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_sb_val ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assign(sb_val_var(k, t), to_hex(0)) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer value variables - sb-val_<step>_<thread>
(assert (= sb-val_0_0 #x0000))
(assert (= sb-val_0_1 #x0000))
(assert (= sb-val_0_2 #x0000))
\end{lstlisting}

\subsubsection{init sb-full}
\todo[inline]{init sb-full} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_sb_full ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assertion(lnot(sb_full_var(k, t))) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer full variables - sb-full_<step>_<thread>
(assert (not sb-full_0_0))
(assert (not sb-full_0_1))
(assert (not sb-full_0_2))
\end{lstlisting}

\subsubsection{init stmt}
\todo[inline]{init stmt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_stmt ()
{
  for (uint t = 0; t < programs.size(); t++)
    {
      for (uint pc = 0; t < programs[t].size(); t++)
        formula << assertion(pc ? lnot(stmt_var(k, t, pc))
                                : stmt_var(k, t, pc)) << eol;
      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; statement activation variables - stmt_<step>_<thread>_<pc>
(assert stmt_0_0_0)
(assert (not stmt_0_0_1))
(assert (not stmt_0_0_2))
(assert (not stmt_0_0_3))
(assert (not stmt_0_0_4))

(assert stmt_0_1_0)
(assert (not stmt_0_1_1))
(assert (not stmt_0_1_2))
(assert (not stmt_0_1_3))
(assert (not stmt_0_1_4))

(assert stmt_0_2_0)
(assert (not stmt_0_2_1))
(assert (not stmt_0_2_2))
(assert (not stmt_0_2_3))
(assert (not stmt_0_2_4))
(assert (not stmt_0_2_5))
\end{lstlisting}

\subsubsection{init block}
\todo[inline]{init block} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_block ()
{
  for (const auto & [id, threads] : checkpoints)
    {
      for (const auto & [t, _] : threads)
        formula << assertion(lnot(block_var(k, id, t))) << eol;
      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; blocking variables - block_<step>_<id>_<thread>
(assert (not block_0_0_0))
(assert (not block_0_0_1))
(assert (not block_0_0_2))
\end{lstlisting}

\subsubsection{init halt}
\todo[inline]{init halt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_halt ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assertion(lnot(halt_var(0, t))) << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; halt variables - halt_<step>_<thread>
(assert (not halt_0_0))
(assert (not halt_0_1))
(assert (not halt_0_2))
\end{lstlisting}

\subsubsection{init heap}
\todo[inline]{init heap} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_heap ()
{
  if (mmap.empty())
    return;

  for (const auto & [adr, val] : mmap)
    formula << assign(select(heap_var(0), to_hex(adr)), to_hex(val))
            << eol;
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; heap variable - heap_<step>
(assert (= (select heap_0 #x0000) #x0000))
(assert (= (select heap_0 #x0001) #x0000))
\end{lstlisting}

\subsubsection{init exit-flag}
\todo[inline]{init exit-flag} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void init_exit_flag ()
{
  // TODO: remove - exits.empty() => !halts.empty()
  if (halts.empty() && exits.empty())
    return;

  formula << assertion(lnot(exit_flag_var(0))) << eol << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; exit flag variable - exit_<step>
(assert (not exit_0))
\end{lstlisting}

\subsubsection{encoding instructions}
\todo[inline]{encoding instructions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{encode LOAD}
\todo[inline]{encode LOAD} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string load (uint k, uint t, uint adr, bool indirect = false)
{
  std::string address = to_hex(adr);

  std::string sb_adr = sb_adr_var(k - 1, t);
  std::string sb_val = sb_val_var(k - 1, t);
  std::string sb_full = sb_full_var(k - 1, t);
  std::string heap = heap_var(k - 1);

  if (indirect)
    return
      ite(sb_full,
          ite(equality(sb_adr, address),
              ite(equality(sb_val, address),
                  sb_val,
                  select(heap, sb_val)),
              ite(equality(sb_adr, select(heap, address)),
                  sb_val,
                  select(heap, select(heap, address)))),
          select(heap, select(heap, address)));
  else
    return ite(land(sb_full, equality(sb_adr, address)),
               sb_val,
               select(heap, address));
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string Load::encode (uint k, uint t, State state)
{
  return load(k, t, arg, indirect);
}
\end{lstlisting}

\subsubsection{encode STORE}
\todo[inline]{encode STORE} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Store::encode (uint k, uint t, State state)
{
  switch (state)
    {
    case State::sb_adr: return indirect ? load(arg) : to_hex(arg);
    case State::sb_val: return accu_var(k - 1, t);
    }
}
\end{lstlisting}

\subsubsection{encode ADD}
\todo[inline]{encode ADD} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Add::encode (uint k, uint t, State state)
{
  return bvadd(accu_var(k - 1, t), load(arg, indirect));
}
\end{lstlisting}

\subsubsection{encode ADDI}
\todo[inline]{encode ADDI} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Addi::encode (uint k, uint t, State state)
{
  return bvadd(accu_var(k - 1, t), to_hex(arg));
}
\end{lstlisting}

\subsubsection{encode SUB}
\todo[inline]{encode SUB} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Sub::encode (uint k, uint t, State state)
{
  return bvsub(accu_var(k - 1, t), load(arg, indirect));
}
\end{lstlisting}

\subsubsection{encode SUBI}
\todo[inline]{encode SUBI} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Subi::encode (uint k, uint t, State state)
{
  return bvsub(accu_var(k - 1, t), to_hex(arg));
}
\end{lstlisting}

\subsubsection{encode MUL}
\todo[inline]{encode MUL} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Mul::encode (uint k, uint t, State state)
{
  return bvmul(accu_var(k - 1, t), load(arg, indirect));
}
\end{lstlisting}

\subsubsection{encode MULI}
\todo[inline]{encode MULI} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Muli::encode (uint k, uint t, State state)
{
  return bvmul(accu_var(k - 1, t), to_hex(arg));
}
\end{lstlisting}

\subsubsection{encode CMP}
\todo[inline]{encode CMP} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Cmp::encode (uint k, uint t, State state)
{
  return bvsub(accu_var(k - 1, t), load(arg, indirect));
}
\end{lstlisting}

\subsubsection{encode JMP}
\todo[inline]{encode JMP} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jmp::encode (uint k, uint t, State state) { return ""; }
\end{lstlisting}

\subsubsection{encode JZ}
\todo[inline]{encode JZ} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jz::encode (uint k, uint t, State state)
{
  return equality(accu_var(k - 1, t), to_hex(0));
}
\end{lstlisting}

\subsubsection{encode JNZ}
\todo[inline]{encode JNZ} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jnz::encode (uint k, uint t, State state)
{
  return lnot(equality(accu_var(k - 1, t), to_hex(0)));
}
\end{lstlisting}

\subsubsection{encode JS}
\todo[inline]{encode JS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[noline]{instroduce global std::string msb = "15"}
\begin{lstlisting}[style=c++]
std::string Js::encode (uint k, uint t, State state)
{
  return equality("#b1", extract("15", "15", accu_var(k - 1, t)));
}
\end{lstlisting}

\subsubsection{encode JNS}
\todo[inline]{encode JNS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jns::encode (uint k, uint t, State state)
{
  return equality("#b0", extract("15", "15", accu_var(k - 1, t)));
}
\end{lstlisting}

\subsubsection{encode JNZNS}
\todo[inline]{encode JNZNS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jnzns::encode (uint k, uint t, State state)
{
  std::string accu = accu_var(k - 1, t);
  return land(lnot(equality(accu, to_hex(0))),
              equality("#b0", extract("15", "15", accu)));
}
\end{lstlisting}

\subsubsection{encode MEM}
\todo[inline]{encode MEM} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Mem::encode (uint k, uint t, State state)
{
  return load(arg, indirect);
}
\end{lstlisting}

\subsubsection{encode CAS}
\todo[inline]{encode CAS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Cas::encode (uint k, uint t, State state)
{
  std::string heap = heap_var(k - 1);
  std::string address =
    indirect ? select(heap, to_hex(arg)) : to_hex(arg);
  std::string condition =
    equality(mem_var(k - 1, t), select(heap, address));

  switch (state)
    {
    case State::accu:
      return ite(condition, to_hex(1), to_hex(0));

    case State::heap:
      return
        ite(condition,
            store(heap, address, accu_var(k - 1, t)),
            heap);
    }
}
\end{lstlisting}

\subsubsection{encode EXIT}
\todo[inline]{encode EXIT} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Exit::encode (uint k, uint t, State state)
{
  return to_hex(arg);
}
\end{lstlisting}

\subsubsection{Functional State Updates}

\subsubsection{define states (functional)}
\todo[inline]{define states (functional)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_states (uint k)
{
  define_accu(k);
  define_mem(k);
  define_sb_adr(k);
  define_sb_val(k);
  define_sb_full(k);
  define_stmt(k);
  define_block(k);
  define_halt(k);

  define_heap(k);
  define_exit_flag(k);

  if (step == bound)
    define_exit_code();
}
\end{lstlisting}

\subsubsection{define accu}
\todo[inline]{define accu} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_accu (uint k)
{
  for (const auto & [t, stmts] : alters[State::accu])
    {
      std::string val = accu_var(k - 1, t);
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        val = ite(exec_var(k - 1, t, *pc),
                  program[t][*pc].encode(k, t, State::accu),
                  val);
      formula << assign(accu_var(k, t), val) << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; accu variables - accu_<step>_<thread>
(assert (= accu_1_0
           (ite exec_0_0_0
                (bvadd accu_0_0 #x0001)
                (ite exec_0_0_2
                     (ite (and sb-full_0_0 (= sb-adr_0_0 #x0001))
                          sb-val_0_0
                          (select heap_0 #x0001))
                     accu_0_0))))
(assert (= accu_1_1
           (ite exec_0_1_0
                (bvadd accu_0_1 #x0001)
                (ite exec_0_1_2
                     (ite (and sb-full_0_1 (= sb-adr_0_1 #x0000))
                          sb-val_0_1
                          (select heap_0 #x0000))
                     accu_0_1))))
(assert (= accu_1_2
           (ite exec_0_2_1
                (bvadd accu_0_2
                       (ite (and sb-full_0_2 (= sb-adr_0_2 #x0000))
                            sb-val_0_2
                            (select heap_0 #x0000)))
                (ite exec_0_2_2
                     (bvadd accu_0_2
                            (ite (and sb-full_0_2
                                      (= sb-adr_0_2 #x0001))
                                 sb-val_0_2
                                 (select heap_0 #x0001)))
                     accu_0_2))))
\end{lstlisting}

\subsubsection{define mem}
\todo[inline]{define mem} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_mem (uint k)
{
  for (const auto & [t, stmts] : alters[State::mem])
    {
      std::string val = mem_var(k - 1, t);
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        val = ite(exec_var(k - 1, t, *pc),
                  program[t][*pc].encode(k, t, State::mem),
                  val);
      formula << assign(mem_var(k, t), val) << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; mem variables - mem_<step>_<thread>
(assert (= mem_1_0 mem_0_0))
(assert (= mem_1_1 mem_0_1))
(assert (= mem_1_2 mem_0_2))
\end{lstlisting}

\subsubsection{define sb-adr}
\todo[inline]{define sb-adr} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_sb_adr (uint k)
{
  for (const auto & [t, stmts] : alters[State::sb_adr])
    {
      std::string val = sb_adr_var(k - 1, t);
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        val = ite(exec_var(k - 1, t, *pc),
                  program[t][*pc].encode(k, t, State::sb_adr),
                  val);
      formula << assign(sb_adr_var(k, t), val) << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer address variables - sb-adr_<step>_<thread>
(assert (= sb-adr_1_0 (ite exec_0_0_1 #x0000 sb-adr_0_0)))
(assert (= sb-adr_1_1 (ite exec_0_1_1 #x0001 sb-adr_0_1)))
(assert (= sb-adr_1_2 sb-adr_0_2))
\end{lstlisting}

\subsubsection{define sb-val}
\todo[inline]{define sb-val} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_sb_val (uint k)
{
  for (const auto & [t, stmts] : alters[State::sb_val])
    {
      std::string val = sb_val_var(k - 1, t);
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        val = ite(exec_var(k - 1, t, *pc),
                  program[t][*pc].encode(k, t, State::sb_val),
                  val);
      formula << assign(sb_val_var(k, t), val) << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer value variables - sb-val_<step>_<thread>
(assert (= sb-val_1_0 (ite exec_0_0_1 accu_0_0 sb-val_0_0)))
(assert (= sb-val_1_1 (ite exec_0_1_1 accu_0_1 sb-val_0_1)))
(assert (= sb-val_1_2 sb-val_0_2))
\end{lstlisting}

\subsubsection{define sb-full}
\todo[inline]{define sb-full} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_sb_full (uint k)
{
  for (const auto & [t, stmts] : alters[State::sb_full])
    {
      std::vector<std::string> args;
      for (const auto & pc : stmts)
        args.push_back(exec_var(k - 1, t, pc));
      args.push_back(sb_full_var(k - 1, t));
      formula << assign(sb_full_var(k, t),
                        ite(flush_var(k - 1, t),
                            "false",
                            lor(args)))
              << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; store buffer full variables - sb-full_<step>_<thread>
(assert (= sb-full_1_0 (ite flush_0_0
                            false
                            (or exec_0_0_1 sb-full_0_0))))
(assert (= sb-full_1_1 (ite flush_0_1
                            false
                            (or exec_0_1_1 sb-full_0_1))))
(assert (= sb-full_1_2 (ite flush_0_2 false sb-full_0_2)))
\end{lstlisting}

\subsubsection{define stmt}
\todo[inline]{define stmt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[noline]{introduce anonymous is_jump function}

\begin{lstlisting}[style=c++]
void define_stmt (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    {
      for (uint pc = 0; pc < programs[t].size(); pc++)
        {
          // statement reactivation
          std::string val =
            land(stmt_var(k - 1, t, pc),
                 lnot(exec_var(k - 1, t, pc)));
          // activation by predecessor
          const auto & stmts = predecessors[t][pc];
          for (auto pre = stmts.rbegin(); pre != stmts.rend(); ++pre)
            {
              std::string exec = exec_var(k - 1, t, *pre);
              Instruction * op = programs[t][*pre];
              // add condition if predecessor is a jump
              if (is_jump(op))
                {
                  std::string cond = op->encode(k, t, State::stmt);
                  if (!cond.empty())
                    exec = land(exec,
                                // negate condition if jump failed
                                *pre == pc - 1 && op.arg != pc
                                  ? lnot(cond)
                                  : cond);
                }
              val = ite(stmt_var(k - 1, t, *pre), exec, val);
            }
          formula << assign(stmt_var(k, t, pc), val) << eol;
        }
      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
; statement activation variables - stmt_<step>_<thread>_<pc>
(assert (= stmt_1_0_0 (and stmt_0_0_0 (not exec_0_0_0))))
(assert (= stmt_1_0_1 (ite stmt_0_0_0
                           exec_0_0_0
                           (and stmt_0_0_1 (not exec_0_0_1)))))
(assert (= stmt_1_0_2 (ite stmt_0_0_1
                           exec_0_0_1
                           (and stmt_0_0_2 (not exec_0_0_2)))))
(assert (= stmt_1_0_3 (ite stmt_0_0_2
                           exec_0_0_2
                           (and stmt_0_0_3 (not exec_0_0_3)))))
(assert (= stmt_1_0_4 (ite stmt_0_0_3
                           exec_0_0_3
                           (and stmt_0_0_4 (not exec_0_0_4)))))

(assert (= stmt_1_1_0 (and stmt_0_1_0 (not exec_0_1_0))))
(assert (= stmt_1_1_1 (ite stmt_0_1_0
                           exec_0_1_0
                           (and stmt_0_1_1 (not exec_0_1_1)))))
(assert (= stmt_1_1_2 (ite stmt_0_1_1
                           exec_0_1_1
                           (and stmt_0_1_2 (not exec_0_1_2)))))
(assert (= stmt_1_1_3 (ite stmt_0_1_2
                           exec_0_1_2
                           (and stmt_0_1_3 (not exec_0_1_3)))))
(assert (= stmt_1_1_4 (ite stmt_0_1_3
                           exec_0_1_3
                           (and stmt_0_1_4 (not exec_0_1_4)))))

(assert (= stmt_1_2_0 (and stmt_0_2_0 (not exec_0_2_0))))
(assert (= stmt_1_2_1 (ite stmt_0_2_0
                           exec_0_2_0
                           (and stmt_0_2_1 (not exec_0_2_1)))))
(assert (= stmt_1_2_2 (ite stmt_0_2_1
                           exec_0_2_1
                           (and stmt_0_2_2 (not exec_0_2_2)))))
(assert (= stmt_1_2_3 (ite stmt_0_2_2
                           exec_0_2_2
                           (and stmt_0_2_3 (not exec_0_2_3)))))
(assert (= stmt_1_2_4 (ite stmt_0_2_3
                           (and exec_0_2_3 (not (= accu_0_2
                                                   #x0000)))
                           (and stmt_0_2_4 (not exec_0_2_4)))))
(assert (= stmt_1_2_5 (ite stmt_0_2_3
                           (and exec_0_2_3 (= accu_0_2 #x0000))
                           (and stmt_0_2_5 (not exec_0_2_5)))))
\end{lstlisting}

\subsubsection{define block}
\todo[inline]{define block} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_block (uint k)
{
  if (checkpoints.empty())
    return;

  for (const auto & [id, threads] : checkpoints)
    {
      for (const auto & [t, stmts] : threads)
        {
          std::vector<std::string> args;
          for (const auto pc : stmts)
            args.push_back(exec_var(k - 1, t, pc));
          args.push_back(block_var(k - 1, id, t));
          formula << assign(block_var(k, id, t),
                            ite(check_var(k - 1, id),
                                "false",
                                lor(args))) << eol;
        }
      formula << eol;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (= block_1_0_0
           (ite check_0_0
                false
                (or exec_0_0_3 block_0_0_0))))
(assert (= block_1_0_1
           (ite check_0_0
                false
                (or exec_0_1_3 block_0_0_1))))
(assert (= block_1_0_2
           (ite check_0_0
                false
                (or exec_0_2_0 block_0_0_2))))
\end{lstlisting}

\subsubsection{define halt}
\todo[inline]{define halt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_halt (uint k)
{
  if (halts.empty())
    return;

  for (uint t = 0; t < programs.size(); t++)
    {
      if (halts.find(thread) != halts.end())
        {
          std::vector<std::string> args;
          for (const auto pc : halts[t])
            args.push_back(exec_var(k - 1, t, pc));
          args.push_back(halt_var(k - 1, t));
          formula << assign(halt_var(k, t), lor(args)) << eol;
        }
      else
        formula << assign(halt_var(k, t), "false") << eol;
    }
  formula << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (= halt_1_0 (or exec_0_0_4 halt_0_0)))
(assert (= halt_1_1 (or exec_0_1_4 halt_0_1)))
(assert (= halt_1_2 false))
\end{lstlisting}

\subsubsection{define heap}
\todo[inline]{define heap} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_heap (uint k)
{
  std::string val = heap_var(k - 1);
  for (int t = programs.size() - 1; t >= 0; t--)
    {
      const auto & stmts = alters[State::heap];
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        val = ite(exec_var(k - 1, t, *pc),
                  programs[t][*pc].encode(k, t, State::heap),
                  val);

      val = ite(flush_var(k - 1, t),
                store(heap_var(k - 1),
                      sb_adr_var(k - 1, t),
                      sb_val_var(k - 1, t)),
                val);
    }
  formula << assign(heap_var(k, t), val) << eol << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (= heap_1
           (ite flush_0_0
                (store heap_0 sb-adr_0_0 sb-val_0_0)
                (ite flush_0_1
                     (store heap_0 sb-adr_0_1 sb-val_0_1)
                     (ite flush_0_2
                          (store heap_0 sb-adr_0_2 sb-val_0_2)
                          heap_0)))))
\end{lstlisting}

\subsubsection{define exit-flag}
\todo[inline]{define exit-flag} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_exit_flag (uint k)
{
  if (halts.empty() && exits.empty())
    return;

  std::vector<std::string> args {exit_flag_var(k - 1)};

  if (!halts.empty())
    {
      std::vector<std::string> halt;
      for (uint t = 0; t < programs.size(); t++)
        halt.push_back(halt_var(k, t));
      args.push_back(land(halt));
    }

  if (!exits.empty())
    for (const auto & [t, stmts] : exits)
      for (const auto pc : stmts)
        args.push_back(exec_var(k - 1, t, pc));

  formula << assign(exit_flag_var(k), lor(args)) << eol << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (= exit_1
           (or exit_0
               (and halt_1_0 halt_1_1 halt_1_2)
               exec_0_2_4
               exec_0_2_5)))
\end{lstlisting}

\subsubsection{define exit-code}
\todo[inline]{define exit-code} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_exit_code ()
{
  std::string val = to_hex(0);
  if (!exits.empty())
    for (uint k = 0; k <= bound; k++)
      for (int t = programs.size() - 1; t >= 0; t--)
          for (const auto & pc : exits[t])
            val = ite(exec_var(k, t, pc),
                      programs[t][pc].encode(k, t, State::exit_code),
                      val);
  formula << assign(exit_code_var, val) << eol << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (= exit-code
           (ite exec_17_2_5
                #x0001
                (ite exec_17_2_4
                     #x0000
                     ...
                     (ite exec_0_2_5
                          #x0001
                          (ite exec_0_2_4
                               #x0000
                               #x0000))))))
\end{lstlisting}

\subsubsection{Relational State Updates}

\begin{lstlisting}[style=c++]
template <class R, class ... T>
R restore (R (*var) (uint k, T ... args), uint k, T ... args)
{
  return equality(var(k, args...), var(k - 1, args...));
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
template <class R, class ... T>
R reset (R (*var) (int k, int x, T ... args),
         R (*cond) (int k, int x),
         int k, int x, T ... args)
{
  return
    equality(var(k, x, args...),
             ite(cond(k - 1, x),
                 "false",
                 var(k - 1, x, args...)));
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
struct Next : std::map<State, std::string>
{
  Next (k, t)
    {
      (*this)[State::accu] = restore(&accu_var, k, t);
      (*this)[State::mem] = restore(&mem_var, k, t);
      (*this)[State::sb_adr] = restore(&sb_adr_var, k, t);
      (*this)[State::sb_val] = restore(&sb_val_var, k, t);
      (*this)[State::sb_full] = restore(&sb_full_var, k, t);
      (*this)[State::halt] = restore(&halt_var, k, t);
      (*this)[State::heap] = restore(&heap_var, k);
      (*this)[State::exit] = lnot(exit_var(k, t));

      // restore block
      if (!checkpoints.empty())
        {
          std::vector<std::string> block_vars;
          for (const auto & [id, threads] : checkpoints)
            if (threads.find(t) != t.end())
              block_vars.push_back(reset(&block_var,
                                         &check_var,
                                         k, id, t));
          (*this)[State::block] = land(block_vars);
        }
    }

  operator std::string () const
    {
      std::vector<std::string> args;
      for (const auto & [_, value])
        if (!value.empty())
          args.push_back(value);
      return land(args);
    }
};
\end{lstlisting}

\subsubsection{define states (relational)}
\todo[inline]{define states (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_states (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    {
      imply_thread_executed(k, t);
      imply_thread_not_executed(k, t);
      imply_thread_flushed(k, t);
    }

  imply_machine_exited(k);
}
\end{lstlisting}

\subsubsection{imply thread executed}
\todo[inline]{imply thread executed} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string imply (std::string var, std::string state)
{
  return assertion(implication(var, state));
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
// smtlib::Relational::imply_thread_executed -----------------------------------
//
// thread t executed an instruction (exec_k_t_pc):
// * update thread state accordingly
// * restore heap (or update upon a successful CAS)
// * unset exit flag iff neither an EXIT, nor a HALT
// * set exit code iff the instruction was an EXIT

void imply_thread_executed (uint k, uint t)
{
  for (uint pc = 0; pc < programs[t].size(); pc++)
    formula << imply(exec_var(k - 1, t, pc),
                     programs[t][pc].encode(k, t, pc)) << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (=> exec_0_0_0
            (and (= accu_1_0 (bvadd accu_0_0 #x0001))
                 (= mem_1_0 mem_0_0)
                 (= sb-adr_1_0 sb-adr_0_0)
                 (= sb-val_1_0 sb-val_0_0)
                 (= sb-full_1_0 sb-full_0_0)
                 (and (not stmt_1_0_0)
                           stmt_1_0_1
                      (not stmt_1_0_2)
                      (not stmt_1_0_3)
                      (not stmt_1_0_4))
                 (= block_1_0_0 (ite check_0_0 false block_0_0_0))
                 (= halt_1_0 halt_0_0)
                 (= heap_1 heap_0)
                 (not exit_1))))
\end{lstlisting}

\subsubsection{encode LOAD (relational)}
\todo[inline]{encode LOAD (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string activate (uint k, uint t, uint pc)
{
  std::vector<std::string> stmts;
  for (uint i = 0; i < programs[t].size(); i++)
    stmts.push_back(i == pc
                      ? stmt_var(k, t, pc)
                      : lnot(stmt_var(k, t, i)));
  return land(stmts);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string Load::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equality(accu_var(k, t),
                               encode(k, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode STORE (relational)}
\todo[inline]{encode STORE (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Store::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::sb_adr] = equality(sb_adr_var(k, t),
                                 encode(k, t, State::sb_adr));
  next[State::sb_val] = equality(sb_val_var(k, t),
                                 encode(k, t, State::sb_val));
  next[State::sb_full] = sb_full_var(k, t);
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode FENCE (relational)}
\todo[inline]{encode FENCE (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Fence::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode ADD (relational)}
\todo[inline]{encode ADD (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Add::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equality(accu_var(k, t),
                               encode(k, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode ADDI (relational)}
\todo[inline]{encode ADDI (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Addi::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equality(accu_var(k, t),
                               encode(k, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode SUB (relational)}
\todo[inline]{encode SUB (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Sub::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equality(accu_var(k, t),
                               encode(k, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode SUBI (relational)}
\todo[inline]{encode SUBI (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Subi::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equality(accu_var(k, t),
                               encode(k, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode MUL (relational)}
\todo[inline]{encode MUL (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Mul::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equality(accu_var(k, t),
                               encode(k, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode MULI (relational)}
\todo[inline]{encode MULI (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Muli::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equality(accu_var(k, t),
                               encode(k, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode CMP (relational)}
\todo[inline]{encode CMP (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Cmp::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equality(accu_var(k, t),
                               encode(k, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode JMP (relational)}
\todo[inline]{encode JMP (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jmp::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, arg);
  return next;
}
\end{lstlisting}

\subsubsection{encode JZ (relational)}
\todo[inline]{encode JZ (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string activate (uint k, uint t, uint pc, Instruction * jmp)
{
  std::vector<std::string> stmts;
  std::string condition = jmp->encode(k, t, State::stmt);
  for (uint i = 0; i < programs[t].size(); i++)
    {
      std::string stmt = stmt_var(k, t, i);
      if (i == jmp->arg)
        stmts.push_back(ite(condition, stmt, lnot(stmt)));
      else if (i == pc + 1)
        stmts.push_back(ite(condition, lnot(stmt), stmt));
      else
        stmts.push_back(lnot(stmt));
    }
  return land(stmts);
}
\end{lstlisting}

\begin{lstlisting}[style=c++]
std::string Jz::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

\subsubsection{encode JNZ (relational)}
\todo[inline]{encode JNZ (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jnz::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

\subsubsection{encode JS (relational)}
\todo[inline]{encode JS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Js::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

\subsubsection{encode JNS (relational)}
\todo[inline]{encode JNS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jns::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

\subsubsection{encode JNZNS (relational)}
\todo[inline]{encode JNZNS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Jnzns::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

\subsubsection{encode MEM (relational)}
\todo[inline]{encode MEM (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Mem::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equality(accu_var(k, t),
                               encode(k, t, State::accu));
  next[State::mem] = equality(mem_var(k, t),
                              encode(k, t, State::mem));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

\subsubsection{encode CAS (relational)}
\todo[inline]{encode CAS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Cas::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equality(accu_var(k, t),
                               encode(k, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  next[State::heap] = equality(heap_var(k),
                               encode(k, t, State::heap));
  return next;
}
\end{lstlisting}

\subsubsection{encode CHECK (relational)}
\todo[inline]{encode CHECK (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Check::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc + 1);
  std::vector<std::string> block_vars;
  for (const auto & [id, threads] : checkpoints)
    if (threads.find(t) != threads.end())
      block_vars.push_back(
        id == op.arg
          ? block_var(k, id, t)
          : reset(&block_var, &check_var, k, id, t));
  next[State::block] = land(block_vars);
  return state;
}
\end{lstlisting}

\subsubsection{encode HALT (relational)}
\todo[inline]{encode HALT (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Halt::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, -1);
  if (programs.size() > 1)
    {
      std::vector<std::string> args;
      for (uint thread = 0; thread < programs.size(); thread++)
        if (thread != t)
          args.push_back(halt_var(k, thread));
      next[State::halt] =
        land(halt_var(k, t),
             ite(land(args),
                 land(exit_flag_var(k),
                      equality(exit_code_var, to_hex(0))),
                 lnot(exit_flag_var(k))));
    }
  else
    next[State::halt] = land(halt_var(k, t),
                             exit_flag_var(k),
                             equality(exit_code_var, to_hex(0))));
  state.erase(state.find(State::exit));
  return state;
}
\end{lstlisting}

\subsubsection{encode EXIT (relational)}
\todo[inline]{encode EXIT (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
std::string Exit::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc + 1);
  next[State::exit] = exit_var(k);
  next[State::exit_code] = equality(exit_code_var,
                                    encode(t, k, State::exit_code));
  return state;
}
\end{lstlisting}

\subsubsection{imply thread not executed}
\todo[inline]{imply thread not executed} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
// imply_thread_not_executed
//
// thread t didn't execute an instruction (not thread_k_t):
// * preserve thread state
// * reset sb-full iff the thread's store buffer has been flushed

void imply_thread_not_executed (uint k, uint t)
{
  Next next(k, t);
  next[State::sb_full] = reset(&sb_full_var, &flush_var, k, t);
  std::vector<std::string> stmts;
  for (uint pc = 0; pc < programs.size(); pc++)
    stmts.push_back(restore(&stmt_var, k, t, pc));
  next[State::stmt] = land(stmts);
  next.erase(next.find(State::heap));
  next.erase(next.find(State::exit));

  formula << imply(lnot(thread_var(k - 1, t)), next) << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (=> (not thread_0_0)
            (and (= accu_1_0 accu_0_0)
                 (= mem_1_0 mem_0_0)
                 (= sb-adr_1_0 sb-adr_0_0)
                 (= sb-val_1_0 sb-val_0_0)
                 (= sb-full_1_0 (ite flush_0_0 false sb-full_0_0))
                 (and (= stmt_1_0_0 stmt_0_0_0)
                      (= stmt_1_0_1 stmt_0_0_1)
                      (= stmt_1_0_2 stmt_0_0_2)
                      (= stmt_1_0_3 stmt_0_0_3)
                      (= stmt_1_0_4 stmt_0_0_4))
                 (= block_1_0_0 (ite check_0_0 false block_0_0_0))
                 (= halt_1_0 halt_0_0))))
\end{lstlisting}

\subsubsection{imply thread flushed}
\todo[inline]{imply thread flushed} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
// imply_thread_flushed
//
// thread t flushed its store buffer (flush_k_t):
// * update heap
// * unset exit flag

void imply_thread_flushed (uint k, uint t)
{
  formula << imply(flush_var(k - 1, t),
                   land(equality(heap_var(k),
                                 store(heap_var(k - 1),
                                       sb_adr_var(k - 1, t),
                                       sb_val_var(k - 1, t)))
                        lnot(exit_flag_var(k)))) << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (=> flush_0_0
            (and (= heap_1 (store heap_0 sb-adr_0_0 sb-val_0_0))
                 (not exit_1))))
\end{lstlisting}

\subsubsection{imply machine exited}
\todo[inline]{imply machine exited} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
// imply_machine_exited
//
// machine exited (exit_k):
// * preserve exit flag
// * preserve heap
// * set exit code to zero iff machine never exited (step == bound)

void imply_machine_exited (uint k)
{
  formula << imply(exit_flag_var(k - 1),
                   land(restore(&heap_var, k),
                        exit_flag_var(k))) << eol;
  // set exit if machine didn't exit within bound
  if (k == bound)
    formula << imply(lnot(exit_flag_var(k)),
                     equality(exit_code_var, to_hex(0))) << eol;
}
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (=> exit_0 (and (= heap_1 heap_0) exit_1)))
\end{lstlisting}

\begin{lstlisting}[language=SMTLib]
(assert (=> exit_16 (and (= heap_17 heap_16) exit_17)))
(assert (=> (not exit_17) (= exit-code #x0000)))
\end{lstlisting}

\subsection{BTOR2}

\subsubsection{BTOR2 generator functions}
\todo[inline]{BTOR2 generator functions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
template <class ... T>
std::string expr (const std::string & nid, const T & ... args)
{
  std::string e = nid;
  (((e += ' ') += args), ...);
  auto & end = e.back();
  if (end == ' ')
    end = eol;
  else
    e += eol;
  return e;
}
\end{lstlisting}

\subsubsection{main encoding function}
\todo[inline]{main encoding function (smtlib)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void encode ()
{
  declare_sorts();
  declare_constants();
  define_mmap();
  declare_states();
  declare_inputs();
  define_transitions();
  define_constraints();
  define_states();
}
\end{lstlisting}

\subsubsection{declare sorts}
\todo[inline]{declare sorts} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void declare_sorts ()
{
  formula <<
    sort_bitvec(sid_bool = nid(), "1") <<
    sort_bitvec(sid_bv = nid(), std::to_string(word_size)) <<
    sort_array(sid_heap = nid(), "2", "2") <<
    eol;
}
\end{lstlisting}

\subsection{Replay}

