\section{Verification}

The main part of this work is implemented in the \texttt{solve} \CHANGE{mode},
% allowing the verification of concurrent assembly programs by bounded model checking based on register states in our abstract machine model.
% allowing bounded model checking of concurrent assembly programs based on register states in our abstract machine model.
% performing bounded model checking of concurrent software running on our abstract machine model.
allowing verification of concurrent software running on our abstract machine model by the means of bounded model checking \cite{ref:BMC}.
It takes an arbitrary number of programs plus the upper bound \CHANGE{$\BOUND$} as input and encodes them into a finite state machine, expressed as \CHANGE{an} SMT formula where each transition translates to the execution of a single thread.
{\SMTLIB} \cite{ref:SMT-Lib} and the novel {\BTOR} \cite{ref:BTOR2} word level model checking format can be generated, using the theories of arrays, uninterpreted functions and bit-vectors.
To simplify the definition of bad states directly in the program code, the possibility of encountering an exit code greater than zero is checked for per default, but custom properties \CHANGE{may} be defined in a separate file and added with the \texttt{-c} command line parameter.
The resulting formula is then evaluated by a state-of-the-art \CHANGE{SMT} solver.
If it is satisfiable, the corresponding execution trace is extracted from \CHANGE{a generated} model and stored for later inspection.

% \todo{intro
  % \begin{itemize}
    % \item submodule \texttt{solve}
    % \item verification of assembly programs by bounded model checking based on register states
    % \item property: there exists a trace in which $\mathbf{EG^?F^?}(\EXITCODE \neq 0)$ holds (exists globally)
    % \item using satisfiability modulo theories (arrays and bit-vectors)
    % \item problem defined by state and transition variables
    % \item one step corresponds to a specific thread's execution of a single instruction
  % \end{itemize}
% }

% \todo[inline]{Basic Definitions? sorts, functions, etc.}

\subsection{Basic Encoding Scheme}

Let $\BVSORT[n]$ be the fixed size bit-vector sort of width $n$ and $\ASORT[n]$ the array sort with index and element sorts $\BVSORT[n]$.
The following variables are used to encode the machine state at a particular step \CHANGE{$k \leq \BOUND$}, where $k = 0$ is the initial state.

% \renewcommand{\arraystretch}{1.5}
\setlength{\tabulinesep}{3pt}
\begin{longtabu}{llX}
  \firsthline
  % \textbf{Machine} &&\\
  % \hline
  $\HEAP^k$ & $\in \ASORT$ & shared memory \\
  $\EXIT^k$ & $\in \BVSORT[1]$ & exit flag \\
  $\EXITCODE^k$ & $\in \BVSORT$ & exit code \\
  \hline
  % \textbf{Threads} &&\\
  % \hline
  $\ACCU^k_t$ & $\in \BVSORT$ & accumulator register of thread $t$ \\
  $\MEM^k_t$ & $\in \BVSORT$ & \lstASM{CAS} memory register of thread $t$ \\
  $\SBADR^k_t$ & $\in \BVSORT$ & store buffer address register of thread $t$ \\
  $\SBVAL^k_t$ & $\in \BVSORT$ & store buffer value register of thread $t$ \\
  $\SBFULL^k_t$ & $\in \BVSORT[1]$ & store buffer full flag of thread $t$ \\
  $\STMT^k_{t, pc}$ & $\in \BVSORT[1]$ & activation flag for statement at $pc$ of thread $t$ \\
  $\BLOCK^k_{id, t}$ & $\in \BVSORT[1]$ & block flag for checkpoint $id$ of thread $t$ \\
  $\HALT^k_t$ & $\in \BVSORT[1]$ & halt flag of thread $t$ \\
  \lasthline
  \caption{State Variables}
  \label{tbl:states}
\end{longtabu}

\newcommand{\READ}{\texttt{read}}
\newcommand{\WRITE}{\texttt{write}}

% Shared memory is modelled using the array variable $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$ for updating the element at $adr \in \BVSORT$ with a given value $val \in \BVSORT$ in step $k$.
% Shared memory in step $k$ is modelled using the array variable $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving an element and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$, returning an updated version of the shared memory state array with the given element set to a specific value.
Shared memory states are modelled using the array variables $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving an element and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$ returning an updated version of the shared memory state array with the given element set to a specific value.
% Its initial state $\HEAP^0$ may contain input data according to a given memory map, but is assumed to be uninitialized in general.
Register states of a thread $t$ are determined by the bit-vector variables $\ACCU^k_t$, $\MEM^k_t$, $\SBADR^k_t$, $\SBVAL^k_t$ and the flag $\SBFULL^k_t$, signalling that the store buffer is full.
%, which are all initially set to zero.
% To aid solvers by reducing the formulas complexity, program flow is modelled without an explicit \CHANGE{program counter ``(PC)''}.
\CHANGE{To reduce the formula's complexity}, program flow is modelled without an explicit \CHANGE{program counter (``$pc$'')}.
Instead, an activation flag $\STMT^k_{t, pc}$ is added for every statement in the program of thread $t$, expressing that it is about to execute the statement at $pc$.
%To model the program flow without an explicit program counter, an activation flag $\STMT^k_{t, pc}$ is added for every statement in the program of thread $t$, expressing that it is about to execute the statement at $pc$.
Blocking a thread $t$ while it is waiting for all other threads to reach a checkpoint $id$ is achieved by a flag $\BLOCK^k_t$.
% Blocking a thread $t$ while waiting for all other threads to synchronize on a checkpoint $id$ is achieved by the $\BLOCK^k_{id, t}$ state flag.
Similarly, the flag $\HALT^k_t$ indicates that thread $t$ executed a \lstASM{HALT} instruction and is therefore also prevented from being scheduled.
% Termination due to an call to \texttt{EXIT}, or because all threads finished executing their programs, or \texttt{EXIT}  is captured by
Termination is captured by the flag $\EXIT^k$ and bit-vector variable $\EXITCODE^k$.

% The shared memory state array $\HEAP^0$ may be initialized with input data according to a given memory map, but is assumed to be uninitialized in general.
% All other states are initially set to zero, with the exception of the initial statement activation flag $\STMT^0_{t, 0}$ of every thread $t$.
All states are initially set to zero, except the initial statement activation flag $\STMT^0_{t, 0}$ of every thread $t$ and the shared memory state array $\HEAP^0$, which may be initialized with input data according to a given memory map, but is assumed to be uninitialized in general.

\bigskip

% Constraints for valid machine state transitions of the form $s_k \to^k s_{k + 1}$ are governed by the following variables.
Machine state transitions of the form $s_k \to^k s_{k + 1}$ are \CHANGE{encoded} by the following free variables.
% Machine state transitions of the form $s_k \to^k s_{k + 1}$ are governed by the free variables given in Table \ref{tbl:encoding:transitions}.
% Transitions $s_k \to^k s_{k + 1}$ of a state $s_k$ are governed by the following free variables and are allowed to be chosen non-deterministically.

\begin{longtabu}{llX}
  \firsthline
  $\THREAD^k_t$ & $\in \BVSORT[1]$ & thread $t$ is scheduled to execute an instruction in step $k$ \\
  $\FLUSH^k_t$ & $\in \BVSORT[1]$ & thread $t$ flushes its store buffer in step $k$ \\
  \lasthline
  \caption{Transition Variables}
  \label{tbl:encoding:transitions}
\end{longtabu}

% \todo[inline]{helper variables}
To simplify the definition of successor states, the following helper variables capture frequently used \CHANGE{conditions}.
% The following helper variables are introduced to simplify the latter definition of state transitions by capturing frequently used terms.

\begin{longtabu}{llX}
  \firsthline
  $\EXEC^k_{t, pc}$ & $\in \BVSORT[1]$ & thread $t$ is executing the statement at $pc$ in step $k$ \\
  $\CHECK^k_{id}$ & $\in \BVSORT[1]$ & all threads reached checkpoint $id$ in step $k$ \\
  \lasthline
  \caption{Helper Variables}
\end{longtabu}

% The statement execution variable $\EXEC^k_{t, pc}$,
The actual execution of a specific statement is encoded by $\EXEC^k_{t, pc}$ and
% The actual execution of a statement at $pc$ by thread $t$ in step $k$ is encoded by the execution variable $\EXEC^k_{t, pc}$ and
is defined as a conjunction of the corresponding statement and thread activation variables.

\[
  \EXEC^k_{t, pc} = \STMT^k_{t, pc} \land \THREAD^k_t
\]

\bigskip

Furthermore, we use $\CHECK^k_{id}$ to signal that all threads containing a call to checkpoint $id$ \CHANGE{(given in the set $C_{id} = \{ \, t \mid t \text{ contains \lstinline[style=asm]{CHECK} } id \, \}$)} have synchronized.% and the corresponding $\BLOCK^k_{id, t}$ flags set.
% from a set $C_{id}$ of threads containing a call to checkpoint $id$
\[
  \CHECK^k_{id} = \bigwedge_{t \in C_{id}} \BLOCK^k_{id, t}
\]

% \bigskip
\subsubsection*{Scheduling}

\newcommand{\CardLt}{\leq^1_n(x_1, \ldots, x_n)}
\newcommand{\CardLtSeq}{\text{LT}^{n, 1}_{\text{SEQ}}}

\newcommand{\ITE}{\texttt{ite}}
\newcommand{\ITEindent}{\;\;\;\;\;\;\;}

% Non-deterministic scheduling of a single thread per step is realized by a boolean cardinality constraint over all $\THREAD^k_t$ and $\FLUSH^k_t$ variables for a number of threads $n$.
Non-deterministic scheduling of at most one thread per step is realized by a boolean cardinality constraint over all transition variables and the exit flag $\EXIT^k$ to ensure satisfiability if the machine terminates in a step \CHANGE{$k < \BOUND$}.
Let $\CardLt$ be a predicate expressing that at most one out of $n$ variables is allowed to be true.
% The na\"{i}ve way of defining $\leq^1_n(x_1, \ldots, x_n)$ is by explicitly excluding all combinations of two variables being simultaneously true.
The intuitive way of encoding $\CardLt$ is by excluding all combinations of two variables being simultaneously true.
% The traditional way of defining such a constraint is by excluding all combinations of two variables being simultaneously true:
\[
  \bigwedge_{1 \leq i < j \leq n} (\neg x_i \lor \neg x_j)
\]
This na\"ive approach, however, consists of $\binom{n}{2}$ \CHANGE{binary} clauses.
% While this na\"ive approach consists of $\binom{n}{2}$ Horn clauses, a more compact formulation, based on a sequential counter circuit, is presented as $\text{LT}^{n, 1}_{\text{SEQ}}$ in \cite{ref:Sinz}.
A more compact formulation, based on a sequential counter circuit computing partial sums $s_i = \sum^i_{j = 1} x_j$ for increasing values of $i$ up to the final $i = n$, is presented as $\CardLtSeq$ in \cite{ref:Sinz} and defined as follows.
% It only requires $3n - 4$ clauses in contrast to the na\"ive approach
% It is based on a sequential counter circuit, only requiring $3n - 4$ clauses, but $n - 1$ additional auxiliary variables.
% Beside this na\"ive approach, consisting of $\binom{n}{2}$ Horn clauses, a more compact formulation with respect to the number of clauses is presented as $\text{LT}^{n, 1}_{\text{SEQ}}$ in \cite{ref:Sinz}.
% This approach consists of $\binom{n}{2}$ Horn clauses.
% consisting of $\binom{n}{2}$ Horn clauses.
% A more compact formulation in terms of the number of clauses, called , based on a sequential counter circuit, is  presented in \cite{ref:Sinz} as $\text{LT}^{n, 1}_{\text{SEQ}}$.
% Cardinality constraint predicate $\leq^1_n(x_1, \ldots, x_n)$ defined as:
\[
  (\neg x_1 \lor s_1) \land (\neg x_n \lor \neg s_{n-1}) \bigwedge_{1 < i < n} \big ( (\neg x_i \lor s_i) \land (\neg s_{i-1} \lor s_i) \land (\neg x_i \lor \neg s_{i-1}) \big )
\]
% $\CardLtSeq$ only requires $3n - 4$ Horn clauses and $n - 1$ additional auxiliary variables.
% It is therefore superior to the na\"ive encoding with regard to the number of clauses for all $n > 5$.
$\CardLtSeq$ is superior to the na\"ive encoding with regard to the number of clauses for all $n > 5$, as it only requires $3n - 4$ Horn clauses and $n - 1$ additional auxiliary variables.
% \todo[inline]{constraint selection}
% Since we need to include two times the number of threads plus one variables in the constraint, the actual definition of $\leq^1_n(x_1, \ldots, x_n)$ is therefore determined by the number of threads involved and the na\"ive encoding only used for up to two threads, $\CardLtSeq$ otherwise.
The actual definition of the at most one constraint predicate $\CardLt$ is therefore determined by the number of threads involved.
Since we have to include two times the number of threads plus one variables in the constraint, the na\"ive encoding is only used for up to two threads and $\CardLtSeq$ otherwise.
% \[
  % \leq^1_n(x_1, \ldots, x_n) \equiv
    % \begin{cases}
      % \CardLtSeq & \text{if } n > 5 \\
      % \text{na\"ive} & \text{otherwise}
    % \end{cases}
% \]
% \todo[inline]{exactly one constraint}
An at most one constraint alone is not sufficient, as we need exactly one transition variable or the exit flag to be true in every step.
\CHANGE{This is because} our generated formula \CHANGE{should} not \CHANGE{be} trivially satisfiable by never scheduling a single thread.
Thus, we define the exactly one constraint predicate $=^1_n\!(x_1, \ldots, x_n)$ by simply adding a disjunction over all variables.% to $\CardLt$.
% The required exactly one constraint predicate $=^1_n(x_1, \ldots, x_n)$ as a conjunction of $\leq^1_n(x_1, \ldots, x_n)$ with a disjunction over all variables
% Let $=^1_n(x_1, \ldots, x_n)$ therefore be an exactly one constraint predicate.
\[
  %=^1_n(x_1, \ldots, x_n) \equiv
  (x_1 \lor \ldots \lor x_n) \; \land \CardLt
  % \CardLt \land (x_1 \lor \ldots \lor x_n)
\]
% \todo[inline]{actual constraint added}
% If we now redeclare $n$ to be the number of threads, the exactly one constraint used for non-deterministic scheduling of a single thread in step $k$ looks as follows.
If we redeclare $n$ as the number of threads, non-deterministic scheduling of a single thread in step $k$ can now be encoded by the following constraint.
% We are now able to state the actual exactly one constraint added to our formula as follows.
\[
  =^1_{2n + 1}\!(\THREAD^k_0, \ldots, \THREAD^k_{n-1}, \FLUSH^k_0, \ldots, \FLUSH^k_{n-1}, \EXIT^k)
\]
% \todo[inline]{scheduling influenced by constraints}
% restrictions by our machine model.
% To comply with our machine model, the cardinality constraint influenced under certain conditions.
% The scheduling constraint is influenced by  certain transitions
% influenced by disabling transition variables under certain conditions.
% to comply with our machine model,
% This cardinality constraint is further influenced by explicitly disabling transitions from certain states in order to meet the requirements of our machine model.

This cardinality constraint is further influenced by explicitly disabling transitions from certain states that are prohibited by our machine model.
% \todo[inline]{store buffer constraints}
% Blocking a thread $t$ not performing a store operation.
% Flushing an empty store buffer of a thread $t$, not containing any barrier \todo{atomic?} operation, can be prevented by a simple implication.
Flushing an empty store buffer of a thread $t$ can be prevented by a simple \CHANGE{relational constraint}.
\[
  \FLUSH^k_t \implies \SBFULL^k_t
\]
% If thread $t$ contains a write together with a barrier operation, execution of the latter has to be restricted while the store is full.
In case thread $t$ containing a write, execution of any barrier operation has to be delayed while the store buffer is full.
% In this case, both mutually exclusive store buffer constraints are combined in a single expression by using
% Both store buffer constraints may be combined in a single expression by using $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$, a functional if-then-else, returning the $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$.
% If a write or barrier operation
% Otherwise,
Let $F_t$ be a set of statements requiring an empty store buffer
and $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$ be a functional if-then-else, returning $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$.
% Let $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$ be a functional if-then-else, returning $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$
\[
  \ITE(x, a, b) =
  \begin{cases}
    a \text{ if } x \text{ is } true \\
    b \text{ otherwise}
  \end{cases}
\]
% Blocking a thread $t$ about to execute a statement that requires the store buffer being empty.
% Set of statements requiring an empty store buffer $F_t$.
Since both store buffer related constraints mainly depend on mutually exclusive values of $\SBFULL^k_t$, we are able to encode them in a single expression.
\[
  \ITE(\SBFULL^k_t, ( \bigvee_{pc \in F_t} \STMT^k_{t, pc} \implies \lnot \THREAD^k_t \,), \lnot \FLUSH^k_t)
\]
% \todo[inline]{checkpoint constraints}
% Blocking a thread $t$, while it is waiting for all other threads reaching a checkpoint $id$ is expressed by a conjunction of the corresponding block flag $\BLOCK^k_{id, t}$ and helper variable $\CHECK^k_{id}$ implying a negated thread activation $\THREAD^k_t$.
Blocking a thread $t$, while it is waiting for all other threads reaching a checkpoint $id$ is implied by a conjunction of the corresponding block flag $\BLOCK^k_{id, t}$ and synchronization variable $\CHECK^k_{id}$.
% \todo[noline]{unsat if deadlock by CHECK}
\[
  \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id} \implies \lnot \THREAD^k_t
\]
% \todo[inline]{halt constraints}
% Finally, a halted thread $t$ is also excluded from the cardinality constraint by disabling its activation variable.% by a simple implication.
% If a thread $t$ has finally halted, it is also excluded from the cardinality constraint.
Finally, if a thread $t$ has halted, it must also be stopped from being scheduled.
\[
  \HALT^k_t \implies \lnot \THREAD^k_t
\]

\CHANGE{
% If any of these conditions are violated, this does not correspond to a valid execution.
The purpose of this conditions is to restrict transitions which do not correspond to a valid execution.
% Since these constraints are defined relationally, special care must be taken such that they do not result in an unsatisfiable formula due to a violation of the primary cardinality constraint.
Since these constraints are defined relationally, special care must be taken in order to prevent a violation of the cardinality constraint, causing the formula to be unsatisfiable if all included variables are falsified simultaneously.
% Considering the previously defined constraints, the only way this situation might occur is if every thread's store buffer is empty ($\lnot \SBFULL^k_t \implies \lnot \FLUSH^k_t$) and
% all threads that are still running have their block flags enabled in case all are waiting for different checkpoint,
% all running threads are waiting for a different checkpoint, causing a \emph{deadlock} i
% at least a single thread $t$ is still running in step $k$ ($\lnot \HALT^k_t \implies \lnot \EXIT^k$).
Considering the previously defined constraints, the only way this situation might occur is if a \emph{deadlock} is introduced by an unfortunate interleaving of different \lstinline[style=asm]{CHECK} instructions, resulting in each thread waiting for another.
% This problem, common for all synchronization primitives, leads to alternating block flags $\BLOCK^k_{t, id}$ being set, violating the conditions of corresponding synchronization variables $\CHECK^k_{id}$ and thread activation variables $\THREAD^k_t$ blocked by the associated constraint.
% In this case, alternating block flags $\BLOCK^k_{id, t}$ are enabled, falsifying the corresponding synchronization variables $\CHECK^k_{id}$ and every running thread's activation $\THREAD^k_t$ being explicitly disabled by the relevant checkpoint constraint.
% This leads to alternate block flags $\BLOCK^k_{id, t}$ being enabled, making it impossible to fulfill the condition of corresponding synchronization variables $\CHECK^k_{id, t}$.
% preventing the condition of corresponding synchronization variables $\CHECK^k_{id}$
% In this case, $\EXIT^k$ will be \emph{false} and since all running threads are prevented from being scheduled by having their activation variables $\THREAD^k_t$ disabled through each individual block state $\BLOCK^k_{t, id}$ being enabled, while none of the corresponding sync
% Let $T$ be the set of threads involved and $C$ the set of checkpoint IDs, then the condition (state) causing the formula to be unsatisfiable can be summarized as follows.
% In this case, let $T$ be the set of threads involved and $C$ the set of checkpoint IDs, then the condition causing
% the scheduling constraints to be violated
% the formula to be unsatisfiable
Let $T$ be the set of threads involved and $C$ the set of checkpoint IDs, then the condition causing unsatisfiability can be summarized as follows.
% \[
  % \exists \, k \leq \BOUND, \forall \, t \in T \,[\, \lnot \SBFULL^k_t \land \lnot \HALT^k_t \land \exists \, id \in C \,[\, \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id} \,]]
% \]
% \[
  % \exists \, k \leq \BOUND : \lnot \EXIT^k \land \forall \, t \in T : \lnot \SBFULL^k_t \land \lnot \HALT^k_t \land \exists \, id \in C : \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id}
% \]
% \begin{align*}
  % & \lnot \EXIT^k \\
  % & \land \exists \, k \leq \BOUND : \forall \, t \in T : \lnot \SBFULL^k_t \land \lnot \HALT^k_t \\
  % & \land \exists \, id \in C : \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id}
% \end{align*}
\begin{equation*}
  \begin{gathered}
  \exists \, k \leq \BOUND : \lnot \EXIT^k \\
  \land \\
  \forall \, t \in T : \lnot \SBFULL^k_t \land \lnot \HALT^k_t \\
  \land \\
  \exists \, id \in C : \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id}
  \end{gathered}
\end{equation*}
% \[
  % \lnot \SBFULL^k_t \land \lnot \HALT^k_t \land \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id} \implies \lnot \EXIT^k \land \lnot \FLUSH^k_t \land \lnot \THREAD^k_t
% \]
}

\subsubsection*{Memory Access}

% \newcommand{\READ}{\texttt{read}}
\newcommand{\LOAD}{\texttt{load}}

% Let $\READ^k: \BVSORT \to \BVSORT$ be a function, returning a given element from array $\HEAP^k$.
% Due to store forwarding in combination with indirect addressing, memory access can not be expressed by simple array lookups, but turns out to be the most complicated part in our encoding scheme.
Due store forwarding, memory access can not be expressed as simple array lookup, but is encoded by a separate function $\LOAD^k_t: \BVSORT \to \BVSORT$ for loading the shared memory element at address $adr \in \BVSORT$ with store forwarding from thread $t$. % and indirect addressing signalled by $indirect \in \BVSORT[1]$, being defined as follows.
\begin{align*}
  \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t \land \SBADR^k_t = adr, \\
  & \SBVAL^k_t, \\
  & \READ^k(adr))
\end{align*}
In case of indirect addressing, $\LOAD^k_t$ is redefined to prevent dependency on certain features of the target language or the use of additional auxiliary variables.
% \todo[noline]{repeated, iterative, recursive?}
\begin{align}
  \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t, \label{def:load:1} \\
  & \ITE(\SBADR^k_t = adr, \label{def:load:2} \\
  & \ITEindent \ITE(\SBVAL^k_t = adr, \label{def:load:3} \\
  & \ITEindent \ITEindent \SBVAL^k_t, \label{def:load:4} \\
  & \ITEindent \ITEindent \READ^k(\SBVAL^k_t)), \label{def:load:5} \\
  & \ITEindent \ITE(\SBADR^k_t = \READ^k(adr), \label{def:load:6} \\
  & \ITEindent \ITEindent \SBVAL^k_t, \label{def:load:7}\\
  & \ITEindent \ITEindent \READ^k(\READ^k(adr)))), \label{def:load:8} \\
  & \READ^k(\READ^k(adr))) \label{def:load:9}
\end{align}
% \todo[noline]{use tabbing evironment?}
First, we check if the store buffer contains an entry and store forwarding might apply (\ref{def:load:1}).
%, or the requested value can be directly retrieved from memory (\ref{def:load:9}).
If it is empty, the requested value has to be directly retrieved from memory (\ref{def:load:9}).
% Otherwise, if the immediate address can be forwarded (\ref{def:load:2}), we must further check if it is equal to the effective address (\ref{def:load:3}) and either both (\ref{def:load:4}), or just the immediate address is forwarded (\ref{def:load:5}).
Otherwise, if the store buffer contains an entry for the given address (\ref{def:load:2}), we must further check if it is equal to the effective address (\ref{def:load:3}) to determine if either both (\ref{def:load:4}), or just the given address can be forwarded (\ref{def:load:5}).
% Otherwise, if the store buffer contains an entry for the immediate address (\ref{def:load:2}), we check if it is equal to the effective address (\ref{def:load:3}) and either return the store buffer value (\ref{def:load:4}) or the element at
% Otherwise, if the store buffer contains an entry for the immediate address (\ref{def:load:2}) and
% Finally, in case the given address could not be forwarded, the store buffer might contain an entry
% Finally, in case the given address was not contained,
Finally, in case there is no entry for the given address,
%we test if and either the effective address can be forwarded (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
the effective address is fetched from memory and compared to the store buffer address (\ref{def:load:6}) to see if it
% can be forwarded (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
% might be subject to store forwarding (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
might be contained (\ref{def:load:7}), or nothing can be forwarded after all (\ref{def:load:8}).
% fetch the effective address from memory and
% or nothing after all.
% and nothing could be forwarded after all.
% If the immediate address cannot be forwarded,

% If store forwaring does not apply because either the store buffer being empty or it neither contains the immediate nor the effective address,
% In case of indirect addressing, we first need to check if the store buffer is full (\ref{def:load:indirect:sbfull}) and the given base address can be forwarded (\ref{def:load:indirect:sbadr}).
% If a value for the base address is contained in the store buffer, we then check if this value

% \begin{align}
  % \LOAD^k_t(adr, indirect) = \ITE(& indirect, \\
  % & \ITE(\SBFULL^k_t, \label{def:load:sbfull} \\
  % & \ITEindent \ITE(\SBADR^k_t = adr, \label{def:load:indirect:sbadr} \\
  % & \ITEindent \ITEindent \ITE(\SBVAL^k_t = adr, \\
  % & \ITEindent \ITEindent \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \ITEindent \ITEindent \READ^k(\SBVAL^k_t)), \\
  % & \ITEindent \ITEindent \ITE(\SBADR^k_t = \READ^k(adr), \\
  % & \ITEindent \ITEindent \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \ITEindent \ITEindent \READ^k(\READ^k(adr)))), \\
  % & \ITEindent \READ^k(\READ^k(adr))), \\
  % & \ITE(\SBFULL^k_t \land \SBADR^k_t = adr, \\
  % & \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \READ^k(adr)))
% \end{align}

% \begin{itemize}
  % \item Nested array lookups if the store buffer is empty and store forwarding does not apply alltogether, or neither the indirect, nor the effective address can be forwarded.
  % \item The value contained in the store buffer if either the effective or both addresses can be forwarded.
% \end{itemize}

% store buffer empty: nested lookup

% \begin{enumerate}
  % \item nothing can be forwarded
  % \item only the indirect address can be forwarded
  % \item only the effective address can be forwarded
  % \item both addresses can be forwarded
% \end{enumerate}

% \[
  % \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t \land \SBADR^k_t = adr, \SBVAL^k_t, \READ^k(adr)))
% \]

% \ref{def:load:sbfull}

% \paragraph{Store Forwarding:} $\sbfull \; \land \; \sbadr = adr \land \accu = \sbval \lor \lnot (\sbfull \land \sbadr = adr)$

% \bigskip

\subsubsection*{Frame Axioms}

\newcommand{\TRUE}{\textit{true}}
\newcommand{\FALSE}{\textit{false}}

\newcommand{\EFFECTIVE}{\texttt{effective}}
\newcommand{\MSB}{\texttt{msb}}

% The effect of a particular operation, determined by the transition variables $\FLUSH^k_t$ and $\EXEC^k_{t, pc}$
% The effect of a thread $t$ flushing its store buffer or executing the instruction at $pc$ in step $k$
Successor states of transitions for all possible types of operations, determined by $\FLUSH^k_t$ and $\EXEC^k_{t, pc}$, are defined by the frame axioms in the table below.
% \todo[inline]{block}
All state variables, not explicitly altered are assumed to be unchanged in the next step, except the block flags $\BLOCK^{k + 1}_{id, t}$, which are reset if all threads synchronized upon checkpoint $id$.
\[
  \BLOCK^{k + 1}_{id, t} = \ITE(\CHECK^k_{id}, \FALSE, \BLOCK^k_{id, t})
\]
To further simplify the definition of axioms, two additional functions are introduced:
% Let $\EFFECTIVE^k: \BVSORT \to \BVSORT$ be a function for transparently selecting the effective address during $\texttt{STORE}$ or $\texttt{CAS}$ instructions.
$\MSB: \BVSORT \to \BVSORT[1]$ for retrieving the most significant bit of a given bit-vector and $\EFFECTIVE^k: \BVSORT \to \BVSORT$ for transparently selecting the effective address during \lstASM{STORE} or \lstASM{CAS} instructions.
\vspace{-0.1cm}
\[
  \EFFECTIVE^k(adr) =
  \begin{cases}
    \READ^k(adr) \text{ if indirect} \\
    adr \text{ otherwise}
  \end{cases}
\]
% and $\MSB: \BVSORT \to \BVSORT[1]$ a function for retrieving the most significant bit of a given bit-vector.

% $\SLICE: \BVSORT \times \mathcal{N} \times \mathcal{N} \to \BVSORT[m]$

% \newcommand{\defaxiom}[1]{
    % \vspace{-0.4cm}
    % {\begin{align*}#1\end{align*}}
    % \vspace{-1.3cm}
% }
% \begin{longtabu}{lX[lm]}
  % \firsthline
    % \texttt{FLUSH} &
    % \vspace{-0.4cm}
    % {\begin{align*}
      % \HEAP^{k + 1} &= \WRITE^k(\SBADR^k_t, \SBVAL^k_t) \\
      % \SBFULL^{k + 1}_t &= false \\
    % \end{align*}}
    % \vspace{-1.3cm}
    % \\
  % \hline
  % \texttt{LOAD adr} &
    % \defaxiom{
      % \ACCU^{k + 1}_t &= \LOAD^k_t(\texttt{adr}) \\
      % \STMT^k_{t, pc} &= false \\
      % \STMT^k_{t, pc + 1} &= true \\
    % } \\
  % \hline
  % foo & bar \\
  % \lasthline
  % \caption{Frame Axioms}
  % \label{tbl:axioms}
% \end{longtabu}

% \doublerulesep=6pt
% \arrayrulewidth=1pt
% \doublerulesep=1.5 pt
% \everyrow{\hline\hline}

% \newcommand{\defaxiom}[2]{
  % \paragraph{#1} ~\\
  % \rule[0.5\baselineskip]{\textwidth}{0.1pt}\vspace{-1\baselineskip}\par\noindent
  % #2
% }

% \newpage
% \defaxiom
% {\texttt{FLUSH}}
% {
  % \begin{itemize}
    % \item[] $\HEAP^{k + 1} = \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$
    % \item[] $\SBFULL^{k + 1} = false$
  % \end{itemize}
% }

% \defaxiom
% {\texttt{LOAD arg}}
% {
  % \begin{itemize}
    % \item[] $\ACCU^{k + 1}_t = \LOAD^k_t(\texttt{adr})$
    % \item[] $\STMT^k_{t, pc} = false$
    % \item[] $\STMT^k_{t, pc + 1} = true$
  % \end{itemize}
% }

% \defaxiom
% {\texttt{STORE arg}}
% {
  % \begin{itemize}
    % \item[] $\SBADR^{k + 1}_t =
      % \begin{cases}
        % \READ^k(adr) \text{ if indirect} \\
        % adr \text{ otherwise}
      % \end{cases}$
    % \item[] $\SBVAL^{k + 1}_t = \ACCU^k_t$
    % \item[] $\STMT^k_{t, pc} = false$
    % \item[] $\STMT^k_{t, pc + 1} = true$
  % \end{itemize}
% }

% \newsavebox{\STORESBADRAXIOM}
% \savebox{\STORESBADRAXIOM}{
  % \hspace{-0.3cm}
  % $\begin{cases}
    % \READ^k(adr) \text{ if indirect} \\
    % adr \text{ otherwise}
  % \end{cases}$
% }

\newsavebox{\CASHEAPAXIOM}
\savebox{\CASHEAPAXIOM}{
  \hspace{-0.3cm}
  % $\begin{cases}
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
      % & \WRITE^k(\READ^k(\texttt{arg}), \ACCU^k_t), \\
      % & \HEAP^k)
    % \end{aligned}
    % \hspace{0.2cm}
    % \text{if indirect} \\
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
      % & \WRITE^k(\texttt{arg}, \ACCU^k_t), \\
      % & \HEAP^k)
    % \end{aligned}
    % \hspace{1.5cm}
    % \text{otherwise}
  % \end{cases}$
  $\begin{aligned}
    \ITE(& \MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), \\
    & \WRITE^k(\EFFECTIVE^k(\texttt{arg}), \ACCU^k_t), \\
    & \HEAP^k)
  \end{aligned}$
}

\newsavebox{\CASACCUAXIOM}
\savebox{\CASACCUAXIOM}{
  \hspace{-0.3cm}
  % $\begin{cases}
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
      % & 1, \\
      % & 0)
    % \end{aligned}
    % % \ITE(\MEM^k_t = \READ^k(\READ^k(\texttt{arg})), 1, 0)
    % \hspace{0.2cm}
    % \text{if indirect} \\
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
      % & 1, \\
      % & 0) \\
    % \end{aligned}
    % % \ITE(\MEM^k_t = \READ^k(\texttt{arg}), 1, 0)
    % \hspace{1.5cm}
    % \text{otherwise}
  % \end{cases}$
  % $\begin{aligned}
    % \ITE(& \MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), \\
    % & 1, \\
    % & 0)
  % \end{aligned}$
  $\ITE(\MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), 1, 0)$
}

% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\mybox} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
    % \lasthline
% \end{longtabu}

% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2}{*}{\texttt{FLUSH}}
    % & $\HEAP^{k + 1}$       & $= \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$ \\
    % & $\SBFULL^{k + 1}$     & $= false$ \\
  % \lasthline
% \end{longtabu}
% \vspace{-0.9cm}
% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{3}{*}{\texttt{LOAD adr}}
    % & $\ACCU^{k + 1}_t$     & $= \LOAD^k_t(\texttt{adr})$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  % \lasthline
% \end{longtabu}
% \vspace{-0.9cm}
% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\mybox} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  % \lasthline
% \end{longtabu}

% \setlength{\tabulinesep}{2pt}
% \setlength{\doublerulesep}{4pt}
\begin{longtabu}{llX[m]}
  \firsthline
  \multirow{2}{*}{\lstASM{FLUSH}}
    & $\HEAP^{k + 1}$   & $= \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$ \\
    & $\SBFULL^{k + 1}$ & $= \FALSE$ \\
  \hline
  % \hhline{===}
  % \tabucline[2pt off 2pt]{-}
  \multirow{3.05}{*}{\lstASM{LOAD arg}}
    & $\ACCU^{k + 1}_t$           & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \hhline{===}
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\STORESBADRAXIOM} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  \multirow{4}{*}{\lstASM{STORE arg}}
    & $\SBADR^{k + 1}_t$          & $= \EFFECTIVE^k(\texttt{arg})$ \\
    & $\SBVAL^{k + 1}_t$          & $= \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \hhline{===}
  \multirow{2}{*}{\lstASM{FENCE}}
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\lstASM{ADD arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t + \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\lstASM{ADDI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t + \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \newpage
  \hline
  \multirow{3.05}{*}{\lstASM{SUB arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\lstASM{SUBI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\lstASM{MUL arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t * \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\lstASM{MULI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t * \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3}{*}{\lstASM{CMP arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{2}{*}{\lstASM{JMP arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \TRUE)}$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \CHANGE{\ITE(pc \neq arg, \TRUE, \FALSE)}$ \\
  \hline
  \multirow{3}{*}{\lstASM{JZ arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \lnot \ACCU^k_t)}$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \lnot \ACCU^k_t$ \\
  \hline
  \multirow{3}{*}{\lstASM{JNZ arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \ACCU^k_t)}$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \ACCU^k_t$ \\
  \hline
  \multirow{3}{*}{\lstASM{JS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \MSB(\ACCU^k_t))}$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \MSB(\ACCU^k_t)$ \\
  \hline
  \newpage
  \hline
  \multirow{3}{*}{\lstASM{JNS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \lnot \MSB(\ACCU^k_t))}$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \lnot \MSB(\ACCU^k_t)$ \\
  \hline
  \multirow{3}{*}{\lstASM{JNZNS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \ACCU^k_t \land \lnot \MSB(\ACCU^k_t))}$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \ACCU^k_t \lor \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \ACCU^k_t \land \lnot \MSB(\ACCU^k_t)$ \\
  \hline
  \multirow{4}{*}{\lstASM{MEM arg}}
    & $\ACCU^{k + 1}_t$           & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\MEM^{k + 1}_t$            & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + k}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \multirow{2.35}{*}{\texttt{CAS arg}}
  \multirow{2.97}{*}{\lstASM{CAS arg}}
    & $\HEAP^{k + 1}$             & $=$ \usebox{\CASHEAPAXIOM} \\
    & $\ACCU^{k + 1}_t$           & $=$ \usebox{\CASACCUAXIOM} \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{2}{*}{\lstASM{HALT}}
    % & $\EXIT^{k + 1}_t$ & $= \HALT^{k + 1}_0 \land \ldots \land \HALT^{k + 1}_{n - 1}$ \\
    & $\EXIT^{k + 1}_t$       & $= \displaystyle \bigwedge^{n - 1}_{i = 0} \HALT^{k + 1}_i$ \\
    & $\HALT^{k + 1}_t$       & $= \TRUE$ \\
    & $\STMT^{k + 1}_{t, pc}$ & $= \FALSE$ \\
  \hline
  \multirow{3}{*}{\lstASM{EXIT arg}}
    & $\EXIT^{k + 1}_t$       & $= \TRUE$ \\
    & $\EXITCODE^k$           & \vspace{.15cm} $= \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$ & $= \FALSE$ \\
  \hline
  \multirow{3}{*}{\lstASM{CHECK arg}}
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
    & $\BLOCK^{k + 1}_{arg, t}$   & $= \TRUE$ \\
  \lasthline
  \caption{Frame Axioms}
  \label{tbl:axioms}
\end{longtabu}

% \vspace{0.2cm}
% \hlinE
% \VSPACE{0.1CM}
% \NOINDENT
% \BEGIN{TABU} TO \TEXTWIDTH {Lx[M]}
  % $\heap^{K + 1}$       & $= \write^K(\sbadr^K_T, \sbval^K_T)$ \\
  % $\sbfull^{K + 1}$     & $= FALSE$ \\
% \END{TABU}

% \PARAGRAPH{\TEXTTT{flush}}

% \VSPACE{0.2CM}
% \HLINE
% \VSPACE{0.1CM}
% \NOINDENT
% \BEGIN{TABU} TO \TEXTWIDTH {Lx[M]}
  % $\heap^{K + 1}$       & $= \write^K(\sbadr^K_T, \sbval^K_T)$ \\
  % $\sbfull^{K + 1}$     & $= FALSE$ \\
% \END{TABU}

% \[
% \texttt{compare}^k_t(adr) =
% \begin{cases}
  % \MEM^k_t = \READ^k(\READ^k(adr)) \text{ if indirect} \\
  % \MEM^k_t = \READ^k(adr) \text{ otherwise}
% \end{cases}
% \]

% $\HEAP^{k + 1} =
% \begin{cases}
  % \begin{aligned}
    % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
    % & \WRITE^k(\READ^k(\texttt{arg}), \ACCU^k_t) \\
    % & \HEAP^k)
  % \end{aligned}
  % \text{ if indirect} \\
  % \begin{aligned}
    % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
    % & \WRITE^k(\texttt{arg}, \ACCU^k_t) \\
    % & \HEAP^k)
  % \end{aligned}
  % \text{ otherwise}
% \end{cases}$

% Let $\texttt{define-accu}(k, t, pc)$ be the predicate defining the accumulator register state $\ACCU^k_t$ of thread $t$ in step $k$ and $pc$ the set of program counters, altering that state.% \todonote{refine}

% \paragraph{\texttt{LOAD adr}}

% \subsubsection{Statement Activation}

% \setlength{\tabulinesep}{2\lineskip}

\newpage
\subsection{{\SMTLIB}}

% We will now outline the actual encoding process for \SMTLIB.
% We will now outline the process of generating \SMTLIB formulas for our model checking problems, following the previously defined encoding scheme.
We will now outline a simplistic {\CPP} implementation for generating {\SMTLIB} formulas of our model checking problems, following the previously defined encoding scheme
and use the store buffer litmus test as an exemplary input for demonstration.
% We will now outline a simplistic {\CPP} implementation for generating our model checking problems in the \SMTLIB format, following the previously defined encoding scheme.
% Our store buffer litmus test is used as an example to demonstrate the output

\subsubsection*{Types}
% \todo[inline]{types} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To differentiate among particular machine states, we start by introducing:% an \lstCPP{enum} \lstCPP{State}.
% A \lstCPP{enum} \lstCPP{State} is used to differentiate among machine states

% \begin{lstlisting}[style=c++]
% typedef uint16_t word_t;
% \end{lstlisting}

\begin{lstlisting}[style=c++]
enum State
{
  heap,
  accu,
  mem,
  adr,
  val,
  full,
  stmt,
  block,
  halt,
  exit,
  exit_code
};
\end{lstlisting}
% All possible values contained in our machine's 16 bit registers are captured by the corresponding unsigned integer type \lstCPP{word_t}.
% \begin{lstlisting}[style=c++]
% using uint = unsigned;
% \end{lstlisting}
% Each available instruction is represented by it's own type, derived from an abstract class \lstCPP{Instruction}, capturing arguments and abolishing the need for lengthy case splits to determine the actual instruction at runtime by utilizing dynamic dispatch of member functions.
Each available instruction is represented by it's own type, derived from an abstract class \lstCPP{Instruction}, capturing arguments and abolishing the need for lengthy case splits by utilizing dynamic dispatch of virtual member functions for taking the appropriate action at runtime.%determine the type of instruction at runtime.
\begin{lstlisting}[style=c++]
struct Instruction
{
  uint arg;
  bool indirect;

  Instruction (uint a, bool i = false) : arg(a), indirect(i) {};

  virtual std::string encode (uint k, uint t, State state) = 0;
};
\end{lstlisting}
% virtual std::string encode (uint k, uint t, uint pc) = 0;

\subsubsection*{Globals}
% \todo[inline]{gobal variables} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Inputs and utility variables are given as globals to keep things simple and function signatures as small as possible.
Commonly used variables are given as globals to keep things simple and function signatures as small as possible.

\begin{table}[!h]
\small
\centering
% \begin{center}
\begin{tabu}{|c|c|c|}
  \firsthline
  % \begin{tabu}{c} \textbf{Thread 0} \end{tabu} &
  % \begin{tabu}{c} \textbf{Thread 1} \end{tabu} &
  % \begin{tabu}{c} \textbf{Thread 2} \end{tabu} \\
  \textbf{Thread 0} & \textbf{Thread 1} & \textbf{Thread 2} \\
  \hline
  \hline
  \begin{tabu}{ll}
    \lstASM{ADDI 1}   & $\STMT^k_{0, 0}$ \\
    \lstASM{STORE 0}  & $\STMT^k_{0, 1}$ \\
    \lstASM{LOAD 1}   & $\STMT^k_{0, 2}$ \\
    \lstASM{CHECK 0}  & $\STMT^k_{0, 3}$ \\
    \lstASM{HALT}     & $\STMT^k_{0, 4}$ \\
  \end{tabu}
  &
  \begin{tabu}{ll}
    \lstASM{ADDI 1}   & $\STMT^k_{1, 0}$ \\
    \lstASM{STORE 1}  & $\STMT^k_{1, 1}$ \\
    \lstASM{LOAD 0}   & $\STMT^k_{1, 2}$ \\
    \lstASM{CHECK 0}  & $\STMT^k_{1, 3}$ \\
    \lstASM{HALT}     & $\STMT^k_{1, 4}$ \\
  \end{tabu}
  &
  \begin{tabu}{ll}
    & \\
    & \\
    & \\
    & \\
    \lstASM{CHECK 0}        & $\STMT^k_{2, 0}$ \\
    \lstASM{ADD 0}          & $\STMT^k_{2, 1}$ \\
    \lstASM{ADD 1}          & $\STMT^k_{2, 2}$ \\
    \lstASM{JZ error}       & $\STMT^k_{2, 3}$ \\
    \lstASM{EXIT 0}         & $\STMT^k_{2, 4}$ \\
    \lstASM{error: EXIT 1}  & $\STMT^k_{2, 5}$ \\
  \end{tabu} \\
  \lasthline
\end{tabu}
\caption{Store buffer litmus test programs and their activation variables.}
\label{tbl:encoding:programs}
% \end{center}
\end{table}
% \vspace{-\baselineskip}
\noindent
Input programs are expressed as a list of instructions and initialized according to our store buffer litmus test, given in Table \ref{tbl:encoding:programs}.
% \begin{lstlisting}[style=c++]
% std::vector<std::vector<Instruction *>> programs;
% \end{lstlisting}
% \vspace{-\baselineskip}
% \begin{tabu} {XXX}
  % \texttt{\{\{} & & \\
  % \lstCPP{new Addi(1)}  & \lstCPP{new Addi(1)}  & \lstCPP{new Check(0)} \\
  % \lstCPP{new Store(0)} & \lstCPP{new Store(1)} & \lstCPP{new Add(0)} \\
  % \lstCPP{new Load(1)}  & \lstCPP{new Load(0)}  & \lstCPP{new Add(1)} \\
  % \lstCPP{new Check(0)} & \lstCPP{new Check(0)} & \lstCPP{new Jz(5)} \\
  % \texttt{\},} && \lstCPP{new Exit(0)} \\
  % && \lstCPP{new Exit(1)} \\
% \end{tabu}
% \vspace{.5\baselineskip}
  % {               {               {
    % new Store(0),   new Store(1),   new Add(0),
    % new Load(1),    new Load(0),    new Add(1),
    % new Check(0),   new Check(0),   new Jz(5),
    % new Halt()      new Halt()      new Exit(0),
  % },              },                new Exit(1)
                                  % }};
\begin{lstlisting}[style=c++]
std::vector<std::vector<Instruction *>> programs = {
  {
    new Addi(1),
    new Store(0),
    new Load(1),
    new Check(0),
    new Halt()
  },
  {
    new Addi(1),
    new Store(1),
    new Load(0),
    new Check(0),
    new Halt()
  },



  {
    new Check(0),
    new Add(0),
    new Add(1),
    new Jz(5),
    new Exit(0),
    new Exit(1)
  }
};
\end{lstlisting}
The initial memory layout in our example, given by the memory map in Listing \ref{lst:mmap:init.mmap}, is captured by the following variable.
\begin{lstlisting}[style=c++]
std::map<uint, uint> mmap = {{0, 0}, {1, 0}};
\end{lstlisting}
Last but not least, we define the upper bound of the resulting model checking problem as the final input variable.
\begin{lstlisting}[style=c++]
uint bound = 17;
\end{lstlisting}
% To increase readability by the use of compound statements, we use a string stream to store the generated formula.
The resulting formula is stored in a string stream to increase readability by the use of compound statements.
\begin{lstlisting}[style=c++]
std::ostringstream formula;
\end{lstlisting}
% The following utility variables are generated during a preprocessing step by analyzing the input programs and used to simplify the encoding process.
To simplify the encoding process, following utility variables are generated during a preprocessing step by analyzing the input programs.
% % by reducing the number of tests.
% \\~\\
% \noindent
% % Program counters of instructions, modifying a particular state are collected in a map to prevent repeated iteration of input programs for their detection.
% % A map, containing the program counters of instructions modifying a particular state.
% We use a map to collect the program counters of instructions, modifying a particular state, in order to reduce the number of tests inside our encoding loops.
\begin{itemize}
\item Program counters of instructions modifying a particular state.
\begin{lstlisting}[style=c++]
std::map<State, std::map<uint, std::vector<uint>>> updates = {
  {State::accu, {{0, {0, 2}}, {1, {0, 2}}, {2, {1, 2}}}},
  {State::adr,  {{0, {1}},    {1, {1}},    {2, {}}}},
  {State::val,  {{0, {1}},    {1, {1}},    {2, {}}}},
  {State::full, {{0, {1}},    {1, {1}},    {2, {}}}},
  {State::halt, {{0, {4}},    {1, {4}},    {2, {}}}},
  {State::exit, {{2, {4, 5}}}}
};
\end{lstlisting}

% Similarly, predecessors of each program statement are identified.
%, required for statement activation variable updates.
\item Predecessors of each statement.
\begin{lstlisting}[style=c++]
std::vector<std::map<uint, std::vector<uint>>> predecessors = {
  {{0, {}}, {1, {0}}, {2, {1}}, {3, {2}}, {4, {3}}},
  {{0, {}}, {1, {0}}, {2, {1}}, {3, {2}}, {4, {3}}},
  {{0, {}}, {1, {0}}, {2, {1}}, {3, {2}}, {4, {3}}, {5, {3}}}
};
\end{lstlisting}

% Program counters of barrier instructions, requiring an empty store buffer.
\item Program counters of memory barriers.
\begin{lstlisting}[style=c++]
std::map<uint, std::vector<uint>> barriers = {
  {0, {1, 4}},
  {1, {1, 4}}
};
\end{lstlisting}

% Program counters of \lstASM{CHECK} instructions per checkpoint and thread.
\item Program counters of \lstASM{CHECK} instructions per checkpoint and thread.
\begin{lstlisting}[style=c++]
std::map<uint, std::map<uint, std::vector<uint>>> checkpoints = {
  {0, {{0, {3}},
       {1, {3}},
       {2, {0}}}}
};
\end{lstlisting}
\end{itemize}

% \begin{lstlisting}[style=c++]
% // pcs of halt statements
% //
% // thread -> list of program counters
% //
% std::map<uint, std::vector<uint>> halts = {{0, {4}}, {1, {4}}};
% \end{lstlisting}

% \begin{lstlisting}[style=c++]
% // pcs of exit calls
% //
% // thread -> list of program counters
% //
% std::map<uint, std::vector<uint>> exits = {{2, {4, 5}}};
% \end{lstlisting}

% \newpage
\subsubsection*{{\SMTLIB} Generator Functions}
% \todo[inline]{smtlib generator functions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Valid \SMTLIB expressions are generated by a set of wrapper functions for each command used in our encoding.
%> \SMTLIB expressions are generated by a set of functions, based on two templates implementing the basic expressions generators.
% using parameter packs to define variadic template functions, implementing the basic expressions generators.
% We start by defining a variadic function template to implement generators for a fixed number of arguments.
% The first for generating functions with an arbitrary but fixed number of arguments.

%Based on the previously defined template functions, we are now able to define a set of wrapper functions for generating the commands used in our encoding.%, shown in Table \ref{tbl:encoding:generators}.

% \SMTLIB commands used during encoding are generated by a set of functions, shown in Table \ref{tbl:encoding:generators}.

% Frequently used \SMTLIB expressions are generated by a set of functions, each exposing overloads for every possible number of arguments supported by the command.
% Frequently used \SMTLIB expressions are generated by a set of functions, each exposing a number of overloads for commands accepting a variable number of
% Frequently used \SMTLIB expressions are generated by a set of functions, including overloads for commands accepting a variable number of arguments.
%providing overloads to match a specific arity.

Frequently used {\SMTLIB} expressions are generated by a set of functions, based on the following variadic function template as the basic expression generator.

\begin{lstlisting}[style=c++]
template <class ... T>
std::string expr (const std::string & op, const T & ... args)
{
  std::string e = '(' + op;
  (((e += ' ') += args), ...);
  return e += ')';
}
\end{lstlisting}

\noindent
% \SMTLIB commands supporting a variable number of arguments by being defined as either \lstSMTLIB{:left-assoc} or \lstSMTLIB{:right-assoc} (like \lstSMTLIB{and}, \lstSMTLIB{or}, etc.), also include two additional overloads.
Generator functions for {\SMTLIB} commands supporting a variable number of arguments by being defined as either \lstSMTLIB{:left-assoc}, \lstSMTLIB{:right-assoc} or \lstSMTLIB{:chainable} %(like conjunction, disjunction, etc.),
also include two additional overloads:
% A variadic version to support an arbitrary but fixed number of arguments, defined as a template identically to the previous expression generatore \lstCPP{expr}.
a variadic version for an arbitrary but fixed number of arguments, using the same template definition as the basic expression generator \lstCPP{expr}
% and another version, accepting arguments contained in an arbitrary STL container for handling a variable number of arguments at runtime, based on the following template.
% and another for handling a varying number of arguments at runtime by accepting an arbitrary STL container, based on the following template.
and another for handling a varying number of arguments at runtime, based on the following template accepting an arbitrary STL container.
% Both overloads handle calls containing only a single argument by directly returning it in order to emit syntactically correct \SMTLIB expressions.
In order to emit syntactically correct {\SMTLIB} expressions, both overloads handle calls containing only a single argument by directly returning it.

% A variadic version as a wrapper to the identically defined \lstCPP{expr} generator function for
% They also expose a variadic version, defined identically to the basic expression generator \lstCPP{expr} for an arbitrary but fixed number of arguments.
% One for generating commands with an arbitrary but fixed number of arguments,
% In order to generate commands with an arbitrary but fixed number of arguments, the according generator functions

% \todo[inline]{variable number of arguments}

\newpage

\begin{lstlisting}[style=c++]
template <template <class, class ...> class C>
std::string expr (const std::string & op, const C<std::string> & args)
{
  std::string e = '(' + op;
  for (const auto & a : args)
    (e += ' ') += a;
  return e += ')';
}
\end{lstlisting}

\noindent
Table \ref{tbl:encoding:generators} shows all generator function names and the corresponding {\SMTLIB} command they are creating.
% arity

\begin{table}[!h]
% \noindent
\begin{tabu} to \textwidth {|X|l|X|}
  \firsthline
  \lstCPP{declare_bool}   & declare boolean   & \lstSMTLIB{(declare-fun ...)} \\
  \lstCPP{declare_bv}     & declare bit-vector & \\%\lstSMTLIB{(declare-fun ... () (_ BitVec 16))} \\
  \lstCPP{declare_array}  & declare array     & \\%\lstSMTLIB{(declare-fun ... () (Array (_ BitVec 16) (_ BitVec 16)))} \\
  \hline
  \hline
  \lstCPP{assertion} & assertion & \lstSMTLIB{(assert ...)} \\
  \hline
  \hline
  \lstCPP{lnot}   & negation                  & \lstSMTLIB{(not ...)} \\
  \lstCPP{land}   & conjunction               & \lstSMTLIB{(and ...)} \\
  \lstCPP{lor}    & disjunction               & \lstSMTLIB{(or ...)} \\
  \lstCPP{lxor}   & exclusive disjunction     & \lstSMTLIB{(xor ...)} \\
  \lstCPP{imply}  & implication               & \lstSMTLIB{(=> ...)} \\
  \lstCPP{equal}  & equivalence               & \lstSMTLIB{(= ...)} \\
  \lstCPP{ite}    & functional if-then-else   & \lstSMTLIB{(ite ...)} \\
  \hline
  \hline
  \lstCPP{bvadd}  & bit-vector addition        & \lstSMTLIB{(bvadd ...)} \\
  \lstCPP{bvsub}  & bit-vector subtraction     & \lstSMTLIB{(bvsub ...)} \\
  \lstCPP{bvmul}  & bit-vector multiplication  & \lstSMTLIB{(bvmul ...)} \\
  \hline
  \hline
  \lstCPP{select}   & array read            & \lstSMTLIB{(select ...)} \\
  \lstCPP{store}    & array store           & \lstSMTLIB{(store ...)} \\
  \lstCPP{extract}  & bit-vector extraction  & \lstSMTLIB{(extract ...)} \\
  \lasthline
\end{tabu}
\caption{{\SMTLIB} \cite{ref:SMT-Lib} expression generator functions.}
\label{tbl:encoding:generators}
\end{table}

% \begin{longtabu}{|l|X|}
  % \firsthline
  % \lstCPP{assertion (std::string)} & \lstSMTLIB{(assert x)} \\
  % % lnot (std::string x) & foo \\
  % % land (std::string) & bar \\
  % \lstCPP{land (std::string)} & \lstSMTLIB{x} \\
  % % land (std::string, std::string ...args) & bar \\
  % \lstCPP{land (std::string, ...)} & \lstSMTLIB{(and x ...)} \\
  % % land (C<std::string>) & bar \\
  % \lstCPP{land (C<std::string>)} & \lstSMTLIB{(and x ...)} \\
  % \lasthline
% \end{longtabu}
% Functions for fixed number of arguments like \lstSMTLIB{or} use the following variadic function template, based on
% make use of \emph{parameter packs} to create a variadic function template
% \todo[inline]{arbitrary but fixed number of arguments}

% \begin{lstlisting}[style=c++]
% std::string assertion (std::string arg)
% {
  % return expr("assert", arg);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string lnot (std::string arg)
% {
  % return expr("not", arg);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string land (const std::string & arg) { return arg; }
%
% template <class ... T>
% std::string land (const std::string & arg, const T & ... args)
% {
  % return expr("and", arg, args...);
% }
%
% template <template<class, class...> class C>
% std::string land (const C<std::string> & args)
% {
  % return args.size() < 2 ? *args.begin() : expr("and", args);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string lor (const std::string & arg) { return arg; }
%
% template <class ... T>
% std::string lor (const std::string & arg, const T & ... args)
% {
  % return expr("or", arg, args...);
% }
%
% template <template<class, class...> class C>
% std::string lor (const C<std::string> & args)
% {
  % return args.size() < 2 ? *args.begin() : expr("or", args);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string lxor (const std::string & arg) { return arg; }
%
% template <class ... T>
% std::string lxor (const std::string & arg, const T & ... args)
% {
  % return expr("xor", arg, args...);
% }
%
% template <template<class, class...> class C>
% std::string lxor (const C<std::string> & args)
% {
  % return args.size() < 2 ? *args.begin() : expr("xor", args);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string implication (std::string antecedent, std::string consequent)
% {
  % return expr("=>", antecedent, consequent);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string equality (std::string var, std::string val)
% {
  % return expr("=", var, val);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string ite (std::string condition, std::string t, std::string f)
% {
  % return expr("ite", condition, t, f);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string bvadd (std::string a, std::string b)
% {
  % return expr("bvadd", a, b);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string bvsub (std::string a, std::string b)
% {
  % return expr("bvsub", a, b);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string bvmul (std::string a, std::string b)
% {
  % return expr("bvmul", a, b);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string select (std::string var, std::string idx)
% {
  % return expr("select", var, idx);
% }
% \end{lstlisting}

% \begin{lstlisting}[style=c++]
% std::string store (std::string var, std::string idx, std::string val)
% {
  % return expr("store", var, idx, val);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string extract (std::string msb, std::string lsb, std::string var)
% {
  % return expr(expr("_ extract", msb, lsb).c_str(), var);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string declare_bool_var (std::string name)
% {
  % // return "(declare-fun " + name + " () Bool)";
  % return expr("declare-fun", {name, "()", "Bool"});
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string declare_bv_var (std::string name)
% {
  % // return "(declare-fun " + name + " () (_ BitVec 16))";
  % return expr("declare-fun", {name, "()", "(_ BitVec 16)"});
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% std::string declare_array_var (std::string name)
% {
  % // return "(declare-fun "
  % //        + name
  % //        + " (Array (_ BitVec 16) (_ BitVec 16)))";
  % static const char * sort = "(_ BitVec 16)";
  % return expr("declare-fun", name, expr("Array", sort, sort));
% }
% \end{lstlisting}

\noindent
Finally, we introduce a function \lstCPP{std::string consth (uint val)} for generating hexadecimal bit-vector constants and a helper function to simplify variable assignments.

% \noindent
% Hexadecimal bit-vector constants are generated by the following function.
%
% \begin{lstlisting}[style=c++]
% std::string consth (uint val)
% {
  % std::ostringstream s;
  % s << "#x" << std::setfill('0') << std::setw(4) << std::hex << val;
  % return s.str();
% }
% \end{lstlisting}
%
% \noindent
% Finally, we also define a helper for assigning states to a specific value.

\begin{lstlisting}[style=c++]
std::string assign (std::string var, std::string val)
{
  return assertion(equal(var, val));
}
\end{lstlisting}

% \newpage

\subsubsection*{Common Encoding Functions}
% \todo[inline]{main encoding function (smtlib)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We will now give a top-down overview of the actual encoding process and start with the main encoding function defined below.
% \lstCPP{encode}.

\begin{lstlisting}[style=c++]
void encode ()
{
  formula << "(set-logic QF_AUFBV)\n";

  for (uint k = 0; k <= bound; k++)
    {
      declare_states(k);
      declare_transitions(k);
      define_transitions (k);

      if (k)
        define_states(k);
      else
        init_states();
    }
}
\end{lstlisting}

\noindent
After setting the appropriate logic (\lstSMTLIB{QF_AUFBV}), each individual step $k$ is encoded iteratively, starting with the declaration of state variables.
% At every step $k$, we start by declaring  variables

% \todo[inline]{declare states} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void declare_states (uint k)
{
  // thread states
  declare_accu(k);
  declare_mem(k);
  declare_adr(k);
  declare_val(k);
  declare_full(k);
  declare_stmt(k);
  declare_block(k);
  declare_halt(k);

  // machine states
  declare_heap(k);
  declare_exit(k);

  if (!k) declare_exit_code();
}
\end{lstlisting}

% \todo[inline]{declare accu} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% template <template<class, class...> class C>
% std::string var (std::string name, C<uint> attributes)
% {
  % for (const auto & attr : attributes)
    % (name += '_') += std::to_string(attr);
%
  % return name;
% }
% \end{lstlisting}

\noindent
Similarly to the generation of {\SMTLIB} commands, the following variadic function template serves as the basis for generating symbols, matching our established variable naming scheme.

\begin{lstlisting}[style=c++]
template <class ... T>
std::string var (const std::string & name, const T & ... attributes)
{
  return (((name += '_') += std::to_string(attributes)), ...);
}
\end{lstlisting}

\noindent
% The generator function for our accumulator register symbols $\ACCU^k_t$, for example, is given below and
This allows us to define a generator function for each variable as a simple wrapper, % to \lstCPP{var}.
like the one of our accumulator register variables $\ACCU^k_t$ given below.
% and for our accumulator register variable $\ACCU^k_t$, for example, created

% As an example, the generator function for accumulator register variables $\ACCU^k_t$ is given below.
% For example, the generator function of our accumulator register variables $\ACCU^k_t$ is given below.

% To further increase readability, we introduce a generator function for each variable.

% return "accu_" + std::to_string(k) + '_' + std::to_string(t);
\begin{lstlisting}[style=c++]
std::string accu (uint k, uint t) { return var("accu", k, t); }
\end{lstlisting}

\noindent
The declaration of accumulator register states for each thread $t$ in step $k$ is now appended to the formula by using the previously defined generator functions.
% The accumulator register state variable declaration for each thread $t$ in step $k$ is now appended to the formula by using the previously defined generator functions.
% The declaration of accumulator register state variables is now appended to the formula, using the previously defined generator expressions.
% Using the previously defined generator functions, the accumulator register state declarations  of a specific step $k$ are now appended to the formula.
% Declaration of all accumulator register variables for a specific step $k$

\begin{lstlisting}[style=c++]
void declare_accu (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    formula << declare_bv(accu(k, t)) << '\n';
}
\end{lstlisting}

\noindent
% Declaring accumulator register states for the initial step, required in our demo a, leads to the following output being produced.
% Executing \lstCPP{declare_accu} in the initial step $k = 0$ of our demo example would lead to the following declarations being appended to the formula.
% Calling \lstCPP{declare_accu} for the initial step $k = 0$ in our demo example would lead to the following register state variables being declared.
% Example output: \lstCPP{declare_accu(0)}.
\emph{Example:} \lstCPP{declare_accu(0)}

% \lstinputlisting[style=smtlib, linerange={9-12}]{../../examples/demo/formula.functional.smt2}
% \begin{lstlisting}[style=smtlib, caption={Example output \lstCPP{declare_accu(0)}}]
\begin{lstlisting}[style=smtlib]
(declare-fun accu_0_0 () (_ BitVec 16))
(declare-fun accu_0_1 () (_ BitVec 16))
(declare-fun accu_0_2 () (_ BitVec 16))
\end{lstlisting}

\noindent
% We skip the declaration functions of the remaining register states, as they are defined identically.
While the declarator functions of the remaining register states
% The declarator functions of the remaining register states
$\MEM^k_t$, $\SBADR^k_t$, $\SBVAL^k_t$ and $\SBFULL^k_t$
% \lstCPP{declare_mem},
% \lstCPP{declare_adr},
% \lstCPP{declare_val}
% and \lstCPP{declare_full}
are defined almost identically, except for the latter
% being declared as \lstSMTLIB{Bool},
changing the sort to \lstSMTLIB{Bool},
% we need to additionally iterate the program of each thread to declare the required number of statement activation variables.
% an additional nested loop is needed to declare the required number of statement activation variables for each thread.
% we need a nested loop to declare the required number of statement activation variables for each thread.
% we additionally need to iterate the program of each thread to declare the required number of statement activation variables.
% an additional nested loop is needed to declare the required number of statement activation variables for a given thread's program.
an additional nested loop is needed to declare an activation variable for each statement in a thread's program.
% a nested loop is required to declare an activation variable for each statement of the

% \todo[inline]{declare mem} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string mem_var (uint k, uint t)
% {
  % return var("mem", k, t);
% }
% \end{lstlisting}

% \begin{lstlisting}[style=c++]
% void declare_mem (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % formula << declare_bv_var(mem_var(k, t)) << eol;
  % formula << eol;
% }
% \end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% ; mem variables - mem_<step>_<thread>
% (declare-fun mem_0_0 () (_ BitVec 16))
% (declare-fun mem_0_1 () (_ BitVec 16))
% (declare-fun mem_0_2 () (_ BitVec 16))
% \end{lstlisting}

% \todo[inline]{declare adr} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string adr_var (uint k, uint t)
% {
  % return var("adr", k, t);
% }
% \end{lstlisting}

% \begin{lstlisting}[style=c++]
% void declare_adr (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % formula << declare_bv_var(adr_var(k, t)) << eol;
  % formula << eol;
% }
% \end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% ; store buffer address variables - adr_<step>_<thread>
% (declare-fun adr_0_0 () (_ BitVec 16))
% (declare-fun adr_0_1 () (_ BitVec 16))
% (declare-fun adr_0_2 () (_ BitVec 16))
% \end{lstlisting}

% \todo[inline]{declare val} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string val_var (uint k, uint t)
% {
  % return var("val", k, t);
% }
% \end{lstlisting}

% \begin{lstlisting}[style=c++]
% void declare_val (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % formula << declare_bv_var(val_var(k, t)) << eol;
  % formula << eol;
% }
% \end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% ; store buffer value variables - val_<step>_<thread>
% (declare-fun val_0_0 () (_ BitVec 16))
% (declare-fun val_0_1 () (_ BitVec 16))
% (declare-fun val_0_2 () (_ BitVec 16))
% \end{lstlisting}

% \todo[inline]{declare full} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string full_var (uint k, uint t)
% {
  % return var("full", k, t);
% }
% \end{lstlisting}

% \begin{lstlisting}[style=c++]
% void declare_full (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % formula << declare_bool_var(full_var(k, t)) << eol;
  % formula << eol;
% }
% \end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% ; store buffer full variables - full_<step>_<thread>
% (declare-fun full_0_0 () Bool)
% (declare-fun full_0_1 () Bool)
% (declare-fun full_0_2 () Bool)
% \end{lstlisting}

% \todo[inline]{declare stmt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string stmt_var (uint k, uint t, uint pc)
% {
  % return var("stmt", k, t, pc);
% }
% \end{lstlisting}

% \noindent
% according to Table \ref{tbl:encoding:programs}

\begin{lstlisting}[style=c++]
void declare_stmt (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    for (uint pc = 0; pc < programs[t].size(); pc++)
      formula << declare_bool(stmt(k, t, pc)) << '\n';
}
\end{lstlisting}

\newpage

\noindent
% According to our demo example programs, given in Table \ref{tbl:encoding:programs}, calling \lstCPP{declare_stmt} for the initial step $k = 0$ would lead to the following statement activation variables being declared.
% Example output: \lstCPP{declare_stmt(0)}.
\emph{Example:} \lstCPP{declare_stmt(0)}

\begin{lstlisting}[style=smtlib]
(declare-fun stmt_0_0_0 () Bool)
(declare-fun stmt_0_0_1 () Bool)
(declare-fun stmt_0_0_2 () Bool)
(declare-fun stmt_0_0_3 () Bool)
(declare-fun stmt_0_0_4 () Bool)

(declare-fun stmt_0_1_0 () Bool)
(declare-fun stmt_0_1_1 () Bool)
(declare-fun stmt_0_1_2 () Bool)
(declare-fun stmt_0_1_3 () Bool)
(declare-fun stmt_0_1_4 () Bool)

(declare-fun stmt_0_2_0 () Bool)
(declare-fun stmt_0_2_1 () Bool)
(declare-fun stmt_0_2_2 () Bool)
(declare-fun stmt_0_2_3 () Bool)
(declare-fun stmt_0_2_4 () Bool)
(declare-fun stmt_0_2_5 () Bool)
\end{lstlisting}

% \todo[inline]{declare block} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string block_var (uint k, uint id, uint t)
% {
  % return var("block", k, id, t);
% }
% \end{lstlisting}

\noindent
% Declaration of block flags uses the \lstCPP{checkpoints} map to
% Block flags are declared on the basis of the \lstCPP{checkpoints} map, created during
In order to prevent repeated iteration of input programs,
the precomputed utility variables are used to indicate the presence of certain instructions and other control flow related information.
% processing of variables  on certain instructions
% the precomputed utility variables are used for processing variables related to a certain type of instruction.
% Declaration of block flags therefore uses the \lstCPP{checkpoints} map to
% Declaration of block flags therefore boils down to simply iterating the
% Declaration of block flags can therefore be achieved by simply iterating the \lstCPP{checkpoints} map.
% Declaration of block flags, for example, can therefore be simplified by relying on the \lstCPP{checkpoints} map,
Declaration of block flags $\BLOCK^k_{id, t}$ can therefore be simplified by relying on the \lstCPP{checkpoints} map,
% containing the program counters of \lstASM{CHECK} instructions.
containing the list of threads eventually waiting for a specific checkpoint.

\begin{lstlisting}[style=c++]
void declare_block (uint k)
{
  for (const auto & [id, threads] : checkpoints)
    for (const auto & [t, _] : threads)
      formula << declare_bool(block(k, id, t)) << '\n';
}
\end{lstlisting}

\noindent
% Example output: \lstCPP{declare_block(0)}.
\emph{Example:} \lstCPP{declare_block(0)}

\begin{lstlisting}[style=smtlib]
(declare-fun block_0_0_0 () Bool)
(declare-fun block_0_0_1 () Bool)
(declare-fun block_0_0_2 () Bool)
\end{lstlisting}

% \todo[inline]{declare halt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string halt_var (uint k, uint t)
% {
  % return var("halt", k, t);
% }
% \end{lstlisting}

\noindent
Halt flags $\HALT^k_t$ are declared in a similar manner, based on the threads contained in the \lstCPP{updates} map's \lstCPP{State::halt} entry.

\newpage
\begin{lstlisting}[style=c++]
void declare_halt (uint k)
{
  for (const auto & [t, _] : updates[State::halt])
    formula << declare_bool(halt(k, t)) << '\n';
}
\end{lstlisting}

\noindent
% \textbf{Output:} \lstCPP{declare_halt(0)}
\emph{Example:} \lstCPP{declare_halt(0)}

\begin{lstlisting}[style=smtlib]
(declare-fun halt_0_0 () Bool)
(declare-fun halt_0_1 () Bool)
\end{lstlisting}

% \todo[inline]{declare heap} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string heap_var (uint k)
% {
  % return var("heap", k);
% }
% \end{lstlisting}

% \noindent
% With all thread states being declared, we continue with machine states, starting with our shared memory array $\HEAP^k$.

% \begin{lstlisting}[style=c++]
% void declare_heap (uint k)
% {
  % formula << declare_array(heap_var(k)) << "\n\n";
% }
% \end{lstlisting}

% \noindent
% Example output: \lstCPP{declare_heap(0)}.

% \begin{lstlisting}[style=smtlib]
% (declare-fun heap_0 () (Array (_ BitVec 16) (_ BitVec 16)))
% \end{lstlisting}

% \todo[inline]{declare exit-flag} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string exit_flag_var (uint k)
% {
  % return var("exit", k);
% }
% \end{lstlisting}

% Followed by the exit flag $\EXIT^k$, which is only added if the programs contain an uninterruptible infinite loop.

% \begin{lstlisting}[style=c++]
% void declare_exit_flag (uint k)
% {
  % if (halts.empty() && exits.empty())
    % return;
%
  % formula << declare_bool(exit_flag_var(k)) << eol << eol;
% }
% \end{lstlisting}

% \noindent
% Followed by the exit flag $\EXIT^k$.

% \begin{lstlisting}[style=c++]
% void declare_exit (uint k)
% {
  % formula << declare_bool(exit_flag_var(k)) << "\n\n";
% }
% \end{lstlisting}

% \noindent
% Example output: \lstCPP{declare_exit(0)}.

% \begin{lstlisting}[style=smtlib]
% (declare-fun exit_0 () Bool)
% \end{lstlisting}

% \todo[inline]{declare exit-code} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% With all thread state variables for the specific step being declared, machine states $\HEAP^k$, $\EXIT^k$ are next, appending the corresponding variable using the required sort.
% With all thread state variables for the specific step being declared, machine states $\HEAP^k$, $\EXIT^k$ are next.
% We omit the definition of the corresponding declarator functions as they are trivial and just add a single variable for each step using the appropriate sort.
% With all thread state variables being declared, machine states $\HEAP^k$, $\EXIT^k$ and $\EXITCODE^k$ are next.
Machine states $\HEAP^k$, $\EXIT^k$ and $\EXITCODE^k$ are declared next.
In contrast to our basic encoding scheme, only a single bit-vector variable representing the machine's final exit code is used and declared during the initial step.
We omit the definition of the corresponding declarator functions as they just add a single variable with the appropriate sort.

~\\
\noindent
\emph{Example:} \lstCPP{declare_heap(0)}

\begin{lstlisting}[style=smtlib]
(declare-fun heap_0 () (Array (_ BitVec 16) (_ BitVec 16)))
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{declare_exit(0)}.
% \textbf{Output:} \lstCPP{declare_exit(0)}

\begin{lstlisting}[style=smtlib]
(declare-fun exit_0 () Bool)
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{declare_exit_code()}

\begin{lstlisting}[style=smtlib]
(declare-fun exit-code () (_ BitVec 16))
\end{lstlisting}

% \noindent
% In contrast to our basic encoding scheme, we include only a single bit-vector variable representing the machine's final exit code, declared during the initial step.% $k = 0$.

% \begin{lstlisting}[style=c++]
% std::string exit_code_var = "exit-code";
%
% void declare_exit_code ()
% {
  % formula << declare_bv(exit_code_var) << "\n\n";
% }
% \end{lstlisting}
%
% \noindent
% \emph{Example:} \lstCPP{declare_exit_code()}
%
% \begin{lstlisting}[style=smtlib]
% (declare-fun exit-code () (_ BitVec 16))
% \end{lstlisting}

% ~\\
% \noindent
% \emph{Example:} \lstCPP{declare_heap(0), declare_exit(0), declare_exit_code()}
%
% \begin{lstlisting}[style=smtlib]
% (declare-fun heap_0 () (Array (_ BitVec 16) (_ BitVec 16)))
% (declare-fun exit_0 () Bool)
% (declare-fun exit-code () (_ BitVec 16))
% \end{lstlisting}

% \todo[inline]{declare transitions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% With all state variables being declared, we continue with transition variables.
% Declaration of the remaining transition and helper variables is performed by the following functions.
% Declaration of the remaining transition and helper variables is consolidated in the following function.
% Declaration of the remaining transition and helper variables is consolidated in the following function.
% The remaining variables
% Finally, the remaining transition and helper variables are declared.
Variable declaration is concluded by adding the required transition variables.

\begin{lstlisting}[style=c++]
void declare_transitions (uint k)
{
  declare_thread(k);
  declare_flush(k);
  declare_exec(k);
  declare_check(k);
}
\end{lstlisting}

% \todo[inline]{declare thread} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string thread_var (uint k, uint t)
% {
  % return var("thread", k, t);
% }
% \end{lstlisting}

\noindent
% Again, we skip further details about the declarator functions for $\THREAD^k$, $\EXEC^k_{t, pc}$ and $\FLUSH^k_t$, as they are based on the same principles used for declaring thread states.
% We skip further details about the declarator functions for $\THREAD^k$, $\EXEC^k_{t, pc}$ and $\FLUSH^k_t$, as they are again defined almost identically to those of register states and statement activation variables.
% We skip further details about the declarator functions for $\THREAD^k$, $\EXEC^k_{t, pc}$ and $\FLUSH^k_t$, as they are based on the same principles used for the declaration of register states and statement activation variables.
We skip further details about their declarator functions, as they are based on the same principles used for register states and statement activation variables, except $\CHECK^k_{id}$ which also refers to the identifiers stored in the \lstCPP{checkpoints} map.

% \begin{lstlisting}[style=c++]
% void declare_thread (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % formula << declare_bool(thread_var(k, t)) << '\n';
  % formula << eol;
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=smtlib]
% ; thread activation variables - thread_<step>_<thread>
% (declare-fun thread_0_0 () Bool)
% (declare-fun thread_0_1 () Bool)
% (declare-fun thread_0_2 () Bool)
% \end{lstlisting}

% \todo[inline]{declare exec} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string exec_var (uint k, uint t, uint pc)
% {
  % return var("exec", k, t, pc);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% void declare_exec (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % for (uint pc = 0; pc < programs[t].size(); pc++)
      % formula << declare_bool_var(exec_var(k, t, pc)) << eol;
  % formula << eol;
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=smtlib]
% ; statement execution variables - exec_<step>_<thread>_<pc>
% (declare-fun exec_0_0_0 () Bool)
% (declare-fun exec_0_0_1 () Bool)
% (declare-fun exec_0_0_2 () Bool)
% (declare-fun exec_0_0_3 () Bool)
% (declare-fun exec_0_0_4 () Bool)
%
% (declare-fun exec_0_1_0 () Bool)
% (declare-fun exec_0_1_1 () Bool)
% (declare-fun exec_0_1_2 () Bool)
% (declare-fun exec_0_1_3 () Bool)
% (declare-fun exec_0_1_4 () Bool)
%
% (declare-fun exec_0_2_0 () Bool)
% (declare-fun exec_0_2_1 () Bool)
% (declare-fun exec_0_2_2 () Bool)
% (declare-fun exec_0_2_3 () Bool)
% (declare-fun exec_0_2_4 () Bool)
% (declare-fun exec_0_2_5 () Bool)
% \end{lstlisting}

% \todo[inline]{declare flush} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{lstlisting}[style=c++]
% std::string flush_var (uint k, uint t)
% {
  % return var("flush", k, t);
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=c++]
% void declare_flush (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % formula << declare_bool_var(flush_var(k, t)) << eol;
  % formula << eol;
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=smtlib]
% ; store buffer flush variables - flush_<step>_<thread>
% (declare-fun flush_0_0 () Bool)
% (declare-fun flush_0_1 () Bool)
% (declare-fun flush_0_2 () Bool)
% \end{lstlisting}

% \todo[inline]{declare check} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string check_var (uint k, uint id)
% {
  % return var("check", k, id);
% }
% \end{lstlisting}

\begin{lstlisting}[style=c++]
void declare_check (uint k)
{
  for (const auto & [id, _] : checkpoints)
    formula << declare_bool(check(k, id)) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{declare_check(0)}

\begin{lstlisting}[style=smtlib]
(declare-fun check_0_0 () Bool)
\end{lstlisting}

% \todo[inline]{define transitions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \noindent
% Since the helper variables $\EXEC^k_{t, pc}$ and $\CHECK^k_{id}$ only depend on the transition variables, non-deterministically determined by our scheduling constraint, we are able to define them immediately.
% With all variables being declared, the actual encoding starts with the definition of helper variables.
% With all variables being declared, we are now able to start the actual encoding process by defining our helper variables.
%
% \begin{lstlisting}[style=c++]
% void define_helper (uint k)
% {
  % define_exec(k);
  % define_check(k);
% }
% \end{lstlisting}

% \todo[inline]{define constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% With all variables being declared, we are now able to start the actual encoding process by defining transition variables and scheduling constraints.
% With all variables being declared, we are now able to define transition variables and scheduling constraints.
% With all variables being declared, the actual encoding process is started by defining the transition variables according to our machine model's scheduling constraints.
With all variables being declared, the actual encoding process is started by defining helper variables and scheduling constraints according to our machine model.

\begin{lstlisting}[style=c++]
void define_transitions (uint k)
{
  define_exec(k);
  define_check(k);
  define_cardinality_constraints(k);
  define_store_buffer_constraints(k);
  define_checkpoint_constraints(k);
  define_halt_constraints(k);
}
\end{lstlisting}

% \todo[inline]{define exec} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
Execution variables $\EXEC^k_{t, pc}$ are defined as a conjunction of the corresponding statement and thread activation variables.

\begin{lstlisting}[style=c++]
void define_exec (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    for (uint pc = 0; pc < programs[t].size(); pc++)
      formula << assign(exec(k, t, pc),
                        land(stmt(k, t, pc),
                             thread(k, t))) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_exec(0)}

\begin{lstlisting}[style=smtlib]
(assert (= exec_0_0_0 (and stmt_0_0_0 thread_0_0)))
(assert (= exec_0_0_1 (and stmt_0_0_1 thread_0_0)))
(assert (= exec_0_0_2 (and stmt_0_0_2 thread_0_0)))
(assert (= exec_0_0_3 (and stmt_0_0_3 thread_0_0)))
(assert (= exec_0_0_4 (and stmt_0_0_4 thread_0_0)))

(assert (= exec_0_1_0 (and stmt_0_1_0 thread_0_1)))
(assert (= exec_0_1_1 (and stmt_0_1_1 thread_0_1)))
(assert (= exec_0_1_2 (and stmt_0_1_2 thread_0_1)))
(assert (= exec_0_1_3 (and stmt_0_1_3 thread_0_1)))
(assert (= exec_0_1_4 (and stmt_0_1_4 thread_0_1)))

(assert (= exec_0_2_0 (and stmt_0_2_0 thread_0_2)))
(assert (= exec_0_2_1 (and stmt_0_2_1 thread_0_2)))
(assert (= exec_0_2_2 (and stmt_0_2_2 thread_0_2)))
(assert (= exec_0_2_3 (and stmt_0_2_3 thread_0_2)))
(assert (= exec_0_2_4 (and stmt_0_2_4 thread_0_2)))
(assert (= exec_0_2_5 (and stmt_0_2_5 thread_0_2)))
\end{lstlisting}

% \todo[inline]{define check} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% Definition of $\CHECK^k_{id}$, signalling that all participating threads synchronized upon a given checkpoint, uses the lists of threads contained in the \lstCPP{checkpoint} map to create the required conjunction of block variables for every checkpoint.
Definition of checkpoint variables $\CHECK^k_{id}$ is again based on the threads stored in \lstCPP{checkpoints} to generate the list of corresponding block variables $\BLOCK^k_{id, t}$ for creating the required conjunction.

\begin{lstlisting}[style=c++]
void define_check (uint k)
{
  for (const auto & [id, threads] : checkpoints)
    {
      std::vector<std::string> args;
      for (const auto & [t, _] : threads)
        args.push_back(block(k, id, t));
      formula << assign(check(k, id), land(args)) << '\n';
    }
}
\end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% ; checkpoint variables - check_<step>_<id>
% (assert (not check_0_0))
% \end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_check(0)}

\begin{lstlisting}[style=smtlib]
(assert (= check_0_0 (and block_0_0_0 block_0_0_1 block_0_0_2)))
\end{lstlisting}

% \todo[inline]{define scheduling constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% std::string card_constraint_naive (std::vector<std::string> vars)
% {
%   switch (vars.size())
%     {
%     case 1: formula << assertion(vars.front()) << '\n'; return;
%     case 2: formula << assertion(lxor(vars)) << '\n'; return;
%     }
%
%   // >= 1 constraint
%   formula << assertion(lor(vars)) << '\n';
%
%   // <= 1 constraint
%   for (auto it1 = vars.begin(); it1 != vars.end(); ++it1)
%     for (auto it2 = it1 + 1; it2 != vars.end(); ++it2)
%       formula << assertion(lor(lnot(*it1), lnot(*it2))) << '\n';
% }
% \end{lstlisting}

\noindent
% We continue with the definition of scheduling constraints, restricting possible transitions from any given state.
% We continue with the definition of scheduling constraints, restricting possible transitions from any given state.
We continue with the cardinality constraint, based on the following functions implementing the different at-most-one predicates.
% Since the cardinality constraint, responsible for non-deterministic scheduling is based on
% If not more than two threads are present, the na\"ive combinatorial constraint is used if

\begin{lstlisting}[style=c++]
void cardinality_naive (const std::vector<std::string> & vars)
{
  for (auto i = vars.begin(); i != vars.end(); ++i)
    for (auto j = i + 1; j != vars.end(); ++j)
      formula << assertion(lor(lnot(*i), lnot(*j))) << '\n';
}
\end{lstlisting}

% \noindent
% Otherwise, if the number of variables is greater than five, Carsten Sinz's sequential counter constraint \cite{ref:Sinz} is used.
% Otherwise, we use Carsten Sinz's sequential counter constraint \cite{ref:Sinz} due to its superiority with respect to the number of clauses.

\begin{lstlisting}[style=c++]
void cardinality_sinz (const std::vector<std::string> & vars)
{
  std::vector<std::string> auxs;
  const auto end = --vars.end();
  for (auto i = vars.begin(); i != end; ++i)
    formula << declare_bool(auxs.emplace_back(*i + "_aux")) << '\n';
  auto var = vars.begin();
  auto aux = auxs.begin();
  formula << assertion(lor(lnot(*var), *aux)) << '\n';
  while (++var != end)
    {
      const std::string & prev = *aux++;
      formula << assertion(lor(lnot(*var), *aux)) << '\n'
              << assertion(lor(lnot(prev), *aux)) << '\n'
              << assertion(lor(lnot(*var), lnot(prev))) << '\n';
    }
  formula << assertion(lor(lnot(*var), lnot(*aux))) << '\n';
}
\end{lstlisting}

% \begin{lstlisting}[style=c++]
% void define_scheduling_constraints (uint k)
% {
%   std::vector<std::string> vars;
%
%   for (uint t = 0; t < programs.size(); t++)
%     {
%       vars.push_back(thread_var(k, t));
%       vars.push_back(flush_var(k, t));
%     }
%
%   if (!halts.empty() || !exits.empty())
%     vars.push_back(exit_flag_var(k));
%
%   formula << (use_sinz_constraint ? card_constraint_sinz(vars)
%                                   : card_constraint_naive(vars))
%           << eol;
% }
% \end{lstlisting}

% vars.insert(vars.end(), {thread_var(k, t), flush_var(k, t)});

\noindent
% adding the conjunction for expressing at-least-one constraint, followed by the .. depending on the number of variables.
The required exactly-one constraint can now be defined by collecting the relevant variables and selecting the appropriate at-most-one predicate after adding a disjunction expressing that at-least-one needs to be true.
% The exactly-one constraint can now be defined by collecting the relevant variables and adding the conjunction for expressing that at least one variable is required to be true, followed by selecting the appropriate at-most-one predicate depending on the number of variables.

\begin{lstlisting}[style=c++]
void define_cardinality_constraints (uint k)
{
  std::vector<std::string> vars;
  for (uint t = 0; t < programs.size(); t++)
    {
      vars.push_back(thread(k, t));
      vars.push_back(flush(k, t));
    }
  vars.push_back(exit(k));
  // >= 1 constraint
  formula << assertion(lor(vars)) << '\n';
  // <= 1 constraint
  if (vars.size() > 5)
    cardinality_sinz(vars);
  else
    cardinality_naive(vars);
}
\end{lstlisting}

\newpage

\noindent
\emph{Example:} \lstCPP{define_cardinality_constraints(0)}

\begin{lstlisting}[style=smtlib]
(assert (or thread_0_0 flush_0_0
            thread_0_1 flush_0_1
            thread_0_2 flush_0_2
            exit_0))

(declare-fun thread_0_0_aux () Bool)
(declare-fun flush_0_0_aux () Bool)
(declare-fun thread_0_1_aux () Bool)
(declare-fun flush_0_1_aux () Bool)
(declare-fun thread_0_2_aux () Bool)
(declare-fun flush_0_2_aux () Bool)

(assert (or (not thread_0_0) thread_0_0_aux))
(assert (or (not flush_0_0) flush_0_0_aux))
(assert (or (not thread_0_0_aux) flush_0_0_aux))
(assert (or (not flush_0_0) (not thread_0_0_aux)))
(assert (or (not thread_0_1) thread_0_1_aux))
(assert (or (not flush_0_0_aux) thread_0_1_aux))
(assert (or (not thread_0_1) (not flush_0_0_aux)))
(assert (or (not flush_0_1) flush_0_1_aux))
(assert (or (not thread_0_1_aux) flush_0_1_aux))
(assert (or (not flush_0_1) (not thread_0_1_aux)))
(assert (or (not thread_0_2) thread_0_2_aux))
(assert (or (not flush_0_1_aux) thread_0_2_aux))
(assert (or (not thread_0_2) (not flush_0_1_aux)))
(assert (or (not flush_0_2) flush_0_2_aux))
(assert (or (not thread_0_2_aux) flush_0_2_aux))
(assert (or (not flush_0_2) (not thread_0_2_aux)))
(assert (or (not exit_0) (not flush_0_2_aux)))
\end{lstlisting}

% \todo[inline]{define store buffer constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% Since the store buffer related constraints of a specific thread depend on the presence of barrier instructions,
% if a thread does not contain any barrier instruction and only
% Flushing an empty store buffer or execution of a barrier instruction while it is full is prevented on the basis
% we resort to their programm counters, given in the \lstCPP{barriers} map,
% for creating the list of corresponding statement activation variables to generate the implication preventing execution of a barrier instruction if its store buffer is full.
% Since the store buffer related constraints of each thread depend on the presence of memory barriers,
% Since the store buffer related constraints differ depending on the presence of memory barriers
% If the \lstCPP{barrier} map does not contain an entry for the given thread .
% Otherwise we use the list of program counters for creating the list of corresponding statement activation variables to generate the implication preventing execution of a barrier instruction if its store buffer is full.
% if the thread does not contain any memory barrier, flushing an empty store buffer is prevented by the according implication.
% Otherwise, we use the list of program counters store in the \lstCPP{barriers} map to create the list of corresponding statement activation variables for generating the implication preventing execution of a barrier instruction if its store buffer is full
% Due to the different store buffer constraints depending on the presence of memory barriers, we use the program counters stored in \lstCPP{barriers} to generate the required list of corresponding statement activation variables for delaying their execution while the store buffer is full.
% Depending on the presence of memory barriers, different store buffer constraints are defined
% Since the store buffer related constraints of each thread depend on the presence of memory barriers,
% \lstCPP{barriers} containing the program counters of memory barrier instructions to generate the list of corresponding statement activation variables required by the conjunction for preventing their execution while the store buffer is full.
% Since a thread's store buffer related constraints depend on the presence of memory barriers,
% an empty store buffer is not allowed to be flushed,
%
Depending on the presence of memory barriers, different store buffer related constraints are added for each thread.
% Otherwise, if the thread's programm contains a \emph{barrier} instruction,
Beside the common restriction of flushing an empty store buffer, %, common for each thread,
% we use the program counters of barrier instructions stored in \lstCPP{barriers} for generating the list of corresponding statement activation variables required to additionally delay their execution while the store buffer is full.
we resort to \lstCPP{barriers} containing the program counters of barrier instructions for generating the list of corresponding statement activation variables required to additionally delay their execution while the store buffer is full.
% we use \lstCPP{barriers} containing the program counters of barrier instructions for generating the list of corresponding statement activation variables required to additionally delay their execution while the store buffer is full.
% we resort to the relevant program counters stored in \lstCPP{barriers} for generating the list of corresponding statement activation variables required to additionally delay their execution while the store buffer is full.

\newpage

\begin{lstlisting}[style=c++]
void define_store_buffer_constraints (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    if (barriers.find(thread) != barriers.end())
      {
        std::vector<std::string> stmts;
        for (uint pc : barriers[t])
          stmts.push_back(stmt(k, t, pc));
        formula << assertion(ite(full(k, t),
                                 imply(lor(stmts),
                                       lnot(thread(k, t))),
                                 lnot(flush(k, t)))) << '\n';
      }
    else
      formula << assertion(imply(lnot(full(k, t)),
                                 lnot(flush(k, t)))) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_store_buffer_constraints(0)}

% \begin{lstlisting}[style=smtlib]
% (assert (ite full_1_0
             % (=> (or stmt_1_0_1 stmt_1_0_4) (not thread_1_0))
             % (not flush_1_0)))
% (assert (ite full_1_1
             % (=> (or stmt_1_1_1 stmt_1_1_4) (not thread_1_1))
             % (not flush_1_1)))
% (assert (=> (not full_1_2) (not flush_1_2)))
% \end{lstlisting}

\begin{lstlisting}[style=smtlib]
(assert (ite full_0_0
             (=> (or stmt_0_0_1 stmt_0_0_4) (not thread_0_0))
             (not flush_0_0)))
(assert (ite full_0_1
             (=> (or stmt_0_1_1 stmt_0_1_4) (not thread_0_1))
             (not flush_0_1)))
(assert (=> (not full_0_2) (not flush_0_2)))
\end{lstlisting}

% \todo[inline]{define checkpoint constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_checkpoint_constraints (uint k)
% {
  % for (const auto & [id, threads] : checkpoints)
    % {
      % for (const auto & [t, _] : threads)
        % {
          % formula
            % << assertion(implication(land(block_var(k, id, t),
                                          % lnot(check_var(k, id))),
                                     % lnot(thread_var(k, t))))
            % << eol;
        % }
      % formula << eol;
    % }
% }
% \end{lstlisting}

\noindent
% Checkpoint constraints are again based on the \tettt{checkpoints} map for generating the relevant $\BLOCK^k^{id, t}$ and $\CHECK^k_{id}$ variables to explicitly disable a thread's activation while it is waiting until all participants reached the checkpoint.
Checkpoint constraints are defined by using \lstCPP{checkpoints} to generate the relevant $\BLOCK^k_{id, t}$ and $\CHECK^k_{id}$ variables for explicitly disabling a thread's activation while it is waiting for all other participants to synchronize upon checkpoint $id$.

\begin{lstlisting}[style=c++]
void define_checkpoint_constraints (uint k)
{
  for (const auto & [id, threads] : checkpoints)
    for (const auto & [t, _] : threads)
      formula << assertion(imply(land(block(k, id, t),
                                      lnot(check(k, id))),
                                 lnot(thread(k, t)))) << '\n';
}
\end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% (assert (=> (and block_1_0_0 (not check_1_0)) (not thread_1_0)))
% (assert (=> (and block_1_0_1 (not check_1_0)) (not thread_1_1)))
% (assert (=> (and block_1_0_2 (not check_1_0)) (not thread_1_2)))
% \end{lstlisting}

\newpage
\noindent
\emph{Example:} \lstCPP{define_checkpoint_constraints(0)}

\begin{lstlisting}[style=smtlib]
(assert (=> (and block_0_0_0 (not check_0_0)) (not thread_0_0)))
(assert (=> (and block_0_0_1 (not check_0_0)) (not thread_0_1)))
(assert (=> (and block_0_0_2 (not check_0_0)) (not thread_0_2)))
\end{lstlisting}

% \todo[inline]{define halt constraints} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_halt_constraints (uint k)
% {
  % if (halts.empty())
    % return;
%
  % for (const auto & [t, _] : halts)
    % formula << assertion(implication(halt_var(k, t),
                                     % lnot(thread_var(k, t))))
            % << eol;
%
  % formula << eol;
% }
% \end{lstlisting}

\noindent
% The definition of scheduling constraints is concluded by preventing halted threads from being scheduled.
The definition of scheduling constraints is concluded by stopping halted threads, based on the entries contained in the \lstCPP{updates} map.

\begin{lstlisting}[style=c++]
void define_halt_constraints (uint k)
{
  for (const auto & [t, _] : updates[State::halt])
    formula << assertion(imply(halt(k, t),
                               lnot(thread(k, t)))) << '\n';
}
\end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% (assert (=> halt_1_0 (not thread_1_0)))
% (assert (=> halt_1_1 (not thread_1_1)))
% \end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_halt_constraints(0)}

\begin{lstlisting}[style=smtlib]
(assert (=> halt_0_0 (not thread_0_0)))
(assert (=> halt_0_1 (not thread_0_1)))
\end{lstlisting}

% \todo[inline]{init states} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
Encoding of each particular step ends with the definition of machine states,
% Finally, encoding of each step if finalized by the definition of machine states,
starting with their initialization in the first step $k = 0$.

\begin{lstlisting}[style=c++]
void init_states ()
{
  init_accu();
  init_mem();
  init_adr();
  init_val();
  init_full();
  init_stmt();
  init_block();
  init_halt();

  init_heap();
  init_exit();
}
\end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% \end{lstlisting}

% \todo[inline]{init accu} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% Similar to their declaration, we start by requiring all initial accumulator register states to be zero.
We begin by setting each thread's initial accumulator register state to zero.

\begin{lstlisting}[style=c++]
void init_accu ()
{
  for (uint t = 0; t < programs.size(); t++)
    formula << assign(accu(0, t), consth(0)) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{init_accu()}

\begin{lstlisting}[style=smtlib]
(assert (= accu_0_0 #x0000))
(assert (= accu_0_1 #x0000))
(assert (= accu_0_2 #x0000))
\end{lstlisting}

% \todo[inline]{init mem} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void init_mem ()
% {
  % for (uint t = 0; t < programs.size(); t++)
    % formula << assign(mem_var(k, t), to_hex(0)) << '\n';
% }
% \end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% ; mem variables - mem_<step>_<thread>
% (assert (= mem_0_0 #x0000))
% (assert (= mem_0_1 #x0000))
% (assert (= mem_0_2 #x0000))
% \end{lstlisting}

% \todo[inline]{init adr} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void init_adr ()
% {
  % for (uint t = 0; t < programs.size(); t++)
    % formula << assign(adr_var(k, t), to_hex(0)) << eol;
  % formula << eol;
% }
% \end{lstlisting}
%
% \begin{lstlisting}[style=smtlib]
% ; store buffer address variables - adr_<step>_<thread>
% (assert (= adr_0_0 #x0000))
% (assert (= adr_0_1 #x0000))
% (assert (= adr_0_2 #x0000))
% \end{lstlisting}

% \todo[inline]{init val} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void init_val ()
% {
  % for (uint t = 0; t < programs.size(); t++)
    % formula << assign(val_var(k, t), to_hex(0)) << eol;
  % formula << eol;
% }
% \end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% ; store buffer value variables - val_<step>_<thread>
% (assert (= val_0_0 #x0000))
% (assert (= val_0_1 #x0000))
% (assert (= val_0_2 #x0000))
% \end{lstlisting}

% \todo[inline]{init full} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void init_full ()
% {
  % for (uint t = 0; t < programs.size(); t++)
    % formula << assertion(lnot(full_var(k, t))) << eol;
  % formula << eol;
% }
% \end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% ; store buffer full variables - full_<step>_<thread>
% (assert (not full_0_0))
% (assert (not full_0_1))
% (assert (not full_0_2))
% \end{lstlisting}

% \todo[inline]{init stmt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \hline
% ~\\
% \noindent
% \texttt{init_stmt}
% \vspace{.3\baselineskip}
% \hline
% ~\\
\noindent
Similar to their declaration, we skip the initialization functions of the remaining register states as they are again defined almost identical and continue with the activation of every thread's initial statement $\STMT^0_{t, 0}$.
% Similar to their declaration, we skip the initialization functions of the remaining register states as they are again defined almost identical and continue by activating the initial statement $\STMT^0_{t, 0}$ of every thread $t$.
% \\
% \hline
\begin{lstlisting}[style=c++]
void init_stmt ()
{
  for (uint t = 0; t < programs.size(); t++)
    for (uint pc = 0; t < programs[t].size(); t++)
      formula << assertion(pc ? lnot(stmt(0, t, pc))
                              : stmt(0, t, pc)) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{init_stmt()}

\begin{lstlisting}[style=smtlib]
(assert stmt_0_0_0)
(assert (not stmt_0_0_1))
(assert (not stmt_0_0_2))
(assert (not stmt_0_0_3))
(assert (not stmt_0_0_4))

(assert stmt_0_1_0)
(assert (not stmt_0_1_1))
(assert (not stmt_0_1_2))
(assert (not stmt_0_1_3))
(assert (not stmt_0_1_4))

(assert stmt_0_2_0)
(assert (not stmt_0_2_1))
(assert (not stmt_0_2_2))
(assert (not stmt_0_2_3))
(assert (not stmt_0_2_4))
(assert (not stmt_0_2_5))
\end{lstlisting}
% \hline

% \todo[inline]{init block} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ~\\
\noindent
% Initialization of block flags $\BLOCK^k_{0, t}$ is uses the
% Block flags $\BLOCK^0_{id, t}$ are initially disabled on the basis of the \lstCPP{checkpoints} map.
% Block flags $\BLOCK^0_{id, t}$ of every checkpoint $id$ and thread $t$ are initially disabled by simply asserting their negation.
% Block flags $\BLOCK^0_{id, t}$ for every checkpoint $id$ and thread $t$ are initially disabled by iterating the corresponding \lstCPP{checkpoints} map.
% Block flags $\BLOCK^0_{id, t}$ are initially disabled by
% Scheduling related thread states $\BLOCK^0_{id, t}$, $\HALT^0_t$ and $\EXIT_0$ are initially disabled.
% Block flags $\BLOCK^0_{id, t}$ are initially disabled based on the entries given in the \lstCPP{checkpoints} map.
Block flags $\BLOCK^0_{id, t}$ are initially disabled by relying on the entries given in the \lstCPP{checkpoints} map.
% Scheduling related thread states $\BLOCK^0_{id, t}$ and $\HALT^0_t$ are initialized by iterating the corresponding utility variables.

\newpage

\begin{lstlisting}[style=c++]
void init_block ()
{
  for (const auto & [id, threads] : checkpoints)
    for (const auto & [t, _] : threads)
      formula << assertion(lnot(block(0, id, t))) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{init_block()}

\begin{lstlisting}[style=smtlib]
(assert (not block_0_0_0))
(assert (not block_0_0_1))
(assert (not block_0_0_2))
\end{lstlisting}

% \todo[inline]{init halt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% Halt flags $\HALT^0_t$ are initially disabled on the basis of the corresponding entry in the \lstCPP{updates} map.
Halt flags $\HALT^0_t$ are initialized in a similar manner, using the relevant entry in the \lstCPP{updates} map.

\begin{lstlisting}[style=c++]
void init_halt ()
{
  for (const auto & [t, _] : updates[State::halt])
    formula << assertion(lnot(halt(0, t))) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{init_halt()}

\begin{lstlisting}[style=smtlib]
(assert (not halt_0_0))
(assert (not halt_0_1))
\end{lstlisting}

% \todo[inline]{init heap} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% Although the machine's memory is considered to be uninitialized in general, relevant cells are initialized according to the presence of a memory map.
Although the machine's memory is considered to be uninitialized in general, input data is assigned according to the entries of a given memory map.

\begin{lstlisting}[style=c++]
void init_heap ()
{
  for (const auto & [adr, val] : mmap)
    formula << assign(select(heap(0), consth(adr)),
                      consth(val)) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{init_heap()}

\begin{lstlisting}[style=smtlib]
(assert (= (select heap_0 #x0000) #x0000))
(assert (= (select heap_0 #x0001) #x0000))
\end{lstlisting}

% \todo[inline]{init exit-flag} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
Finally, the initial exit flag $\EXIT_0$ is disabled to enforce execution.
% Finally, execution of is enforced by disabling the initial exit flag $\EXIT_0$.

\begin{lstlisting}[style=c++]
void init_exit()
{
  formula << assertion(lnot(exit(0))) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{init_exit()}

\begin{lstlisting}[style=smtlib]
(assert (not exit_0))
\end{lstlisting}

% \todo[inline]{encoding instructions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \todo[inline]{encode LOAD} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% Memory access is implemented by the following helper according to the previously defined $\LOAD^k_t$ function.
Memory access, according to the previously defined $\LOAD^k_t$, is implemented by the following helper function.

\begin{lstlisting}[style=c++]
std::string load (uint k, uint t, uint adr, bool indirect = false)
{
  std::string address = consth(adr);
  std::string adr_var = adr(k, t);
  std::string val_var = val(k, t);
  std::string full_var = full(k, t);
  std::string heap_var = heap(k);

  if (indirect)
    return
      ite(full_var,
          ite(equal(adr_var, address),
              ite(equal(val_var, address),
                  val_var,
                  select(heap_var, val_var)),
              ite(equal(adr_var, select(heap_var, address)),
                  val_var,
                  select(heap_var, select(heap_var, address)))),
          select(heap_var, select(heap_var, address)));
  else
    return
      ite(land(full_var, equal(adr_var, address)),
          val_var,
          select(heap_var, address));
}
\end{lstlisting}

\noindent
% Definition of common encoding functions is concluded by introducing the implementation of virtual member function \lstCPP{Instruction::encode(uint, uint, State)} for all instructions, based on the frame axioms.
% Common encoding functions are concluded by introducing the virtual member functions implementing \lstinline[style=c++, basicstyle=\normalsize\ttfamily]{Instruction::encode(uint, uint, State)}, returning the successor of a given state after executing the specific instruction, expect for the statement activation variables $\STMT^k_{t, pc}$, which are handeled seperately.
% Common encoding functions are concluded by implementing the virtual member function \lstinline[style=c++, basicstyle=\normalsize\ttfamily]{Instruction::encode(uint, uint, State)} of all descendants, returning the successor of a given state after executing the specific instruction, expect for the statement activation variables $\STMT^k_{t, pc}$, which are handeled seperately.
Common encoding functions are concluded by introducing implementations for \lstCPP{Instruction::encode(uint, uint, State)}, returning the successor of a given state after executing the specific instruction expect for the statement activation variables $\STMT^k_{t, pc}$, which are handeled seperately and only jump conditions being generated this way.
% Statement activation variables $\STMT^k_{t, pc}$ are handeled seperately and only the positive
Implementations for \lstASM{FENCE}, \lstASM{JMP} and \lstASM{HALT} instructions are omitted, as they just return an empty \lstCPP{std::string}.

\newpage

% \newcommand{\defencode}[1]{
  % \par\noindent
  % #1
  % \par\noindent
  % \rule[0.5\baselineskip]{\textwidth}{0.1pt}\vspace{-1.3\baselineskip}%\par%\noindent
  % % #2
% }

\newcommand{\defencode}[1]{
  \vfill
  \par\noindent
  % {\small #1}
  #1
  \par\noindent
  \rule[0.5\baselineskip]{\textwidth}{0.1pt}%\par%\noindent
  % #2
}

\newlength{\encodeskip}
\setlength{\encodeskip}{.5\baselineskip}

\lstdefinestyle{encode}{aboveskip=-\encodeskip, belowskip=\encodeskip}

% \newcommand{\defencode}[1]{
  % \par\noindent
  % #1
  % \par\noindent\makebox[\textwidth]{\rule[.5\baselineskip]{\textwidth}{0.1pt}}\par\noindent
  % \vspace{-2.4\baselineskip}
  % % \rule[0.5\baselineskip]{\textwidth}{0.1pt}\vspace{-1.3\baselineskip}%\par%\noindent
  % % #2
% }

% \lstset{belowskip=\baselineskip}

\defencode{\lstASM{LOAD arg}}
% \begin{lstlisting}[style=c++,aboveskip=-\encodeskip,belowskip=\encodeskip]
\begin{lstlisting}[style=c++, style=encode]
std::string Load::encode (uint k, uint t, State state)
{
  return load(k, t, arg, indirect);
}
\end{lstlisting}

% \todo[inline]{encode STORE} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{STORE arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Store::encode (uint k, uint t, State state)
{
  switch (state)
    {
    case State::adr: return indirect ? load(k, arg) : consth(arg);
    case State::val: return accu(k, t);
    }
}
\end{lstlisting}

% \todo[inline]{encode ADD} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{ADD arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Add::encode (uint k, uint t, State state)
{
  return bvadd(accu(k, t), load(k, arg, indirect));
}
\end{lstlisting}

% \todo[inline]{encode ADDI} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{ADDI arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Addi::encode (uint k, uint t, State state)
{
  return bvadd(accu(k, t), consth(arg));
}
\end{lstlisting}

% \todo[inline]{encode SUB} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{SUB arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Sub::encode (uint k, uint t, State state)
{
  return bvsub(accu(k, t), load(k, arg, indirect));
}
\end{lstlisting}

% \todo[inline]{encode SUBI} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{SUBI arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Subi::encode (uint k, uint t, State state)
{
  return bvsub(accu(k, t), consth(arg));
}
\end{lstlisting}

% \todo[inline]{encode MUL} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{MUL arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Mul::encode (uint k, uint t, State state)
{
  return bvmul(accu(k, t), load(k, arg, indirect));
}
\end{lstlisting}

% \todo[inline]{encode MULI} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{MULI arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Muli::encode (uint k, uint t, State state)
{
  return bvmul(accu(k, t), consth(arg));
}
\end{lstlisting}

% \todo[inline]{encode CMP} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{CMP arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Cmp::encode (uint k, uint t, State state)
{
  return bvsub(accu(k, t), load(k, arg, indirect));
}
\end{lstlisting}

% \todo[inline]{encode JMP} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \defencode{\lstASM{JMP arg}}
% \begin{lstlisting}[style=c++, style=encode]
% std::string Jmp::encode (uint k, uint t, State state) { return ""; }
% \end{lstlisting}

% \todo[inline]{encode JZ} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JZ arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jz::encode (uint k, uint t, State state)
{
  return equal(accu(k, t), consth(0));
}
\end{lstlisting}

% \todo[inline]{encode JNZ} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JNZ arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jnz::encode (uint k, uint t, State state)
{
  return lnot(equal(accu(k, t), consth(0)));
}
\end{lstlisting}

% \todo[inline]{encode JS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \todo[noline]{instroduce global std::string msb = "15"?}
\defencode{\lstASM{JS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Js::encode (uint k, uint t, State state)
{
  return equal("#b1", extract("15", "15", accu(k, t)));
}
\end{lstlisting}

% \todo[inline]{encode JNS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{JNS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jns::encode (uint k, uint t, State state)
{
  return equal("#b0", extract("15", "15", accu(k, t)));
}
\end{lstlisting}

% \todo[inline]{encode JNZNS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JNZNS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jnzns::encode (uint k, uint t, State state)
{
  return land(lnot(equal(accu(k, t), consth(0))),
              equal("#b0", extract("15", "15", accu(k, t))));
}
\end{lstlisting}

% \todo[inline]{encode MEM} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{MEM arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Mem::encode (uint k, uint t, State state)
{
  return load(k, arg, indirect);
}
\end{lstlisting}

% \todo[inline]{encode CAS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{CAS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Cas::encode (uint k, uint t, State state)
{
  auto heap_var = heap(k);
  auto address = indirect ? select(heap_var, consth(arg))
                          : consth(arg);
  auto condition = equal(mem(k, t), select(heap_var, address));
  switch (state)
    {
    case State::accu: return ite(condition, consth(1), consth(0));
    case State::heap: return ite(condition,
                                store(heap_var,
                                      address,
                                      accu(k, t)),
                                heap_var);
    }
}
\end{lstlisting}

% \todo[inline]{encode HALT} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \defencode{\lstASM{HALT}}
% \begin{lstlisting}[style=c++, style=encode]
% std::string Halt::encode (uint k, uint t, State state) { return ""; }
% \end{lstlisting}

% \todo[inline]{encode EXIT} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{EXIT arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Exit::encode (uint k, uint t, State state)
{
  return consth(arg);
}
\end{lstlisting}

% \newpage
\subsubsection*{Functional Next State Logic}

% \todo[inline]{define states (functional)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[noline]{Next State Functions?}\noindent
% deterministically
% functional encoding scheme, static single assignment to determine the successor of each state individually
% functional encoding scheme, based on static single assignments for determining the successor of each state individually.
% We will now introduce the main state update scheme according to our model's frame axioms, generated using the \texttt{-e smtlib} command line parameter.
We will now introduce our primary state update scheme, generated by using the \texttt{-e smtlib} command line parameter,
% This functional encoding relies on \lstCPP{ite} cascades to perform \emph{static single assignments} for determining the successor of each state individually and aids the solver by simplifying the deduction process.
relying on \lstCPP{ite} cascades to perform \emph{static single assignments} for determining the successor of each state explicitly in a functional manner.% and aids the solver by simplifying the deduction process.
% in order to aid the solver by simplifying the deduction process and minimizing the size of the generated formula.

\todo[noline]{symbolic simulation}

\begin{lstlisting}[style=c++]
void define_states (uint k)
{
  define_accu(k);
  define_mem(k);
  define_adr(k);
  define_val(k);
  define_full(k);
  define_stmt(k);
  define_block(k);
  define_halt(k);
  define_heap(k);
  define_exit(k);

  if (k == bound)
    define_exit_code();
}
\end{lstlisting}

% \todo[inline]{define accu} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% \begin{itemize}
  % \item recursively
  % \item starts with base case of preserving its value
  % \item for each statement altering $\ACCU^k_t$
% \end{itemize}
% starting with the preservation of it's previous state $\ACCU^{k - 1}_t$, the
% starting with the base case of preserving it's previous state $\ACCU^{k - 1}_t$, the
% State update expressions for every thread's accumulator register $\ACCU^k_t$ are initialized with the predecessor $\ACCU^{k - 1}_t$
% Starting with the accumulator registers $\ACCU^k_t$, each update expression is generated by adding an \lstCPP{ite} for every program statement altering the accumulator
% Starting with the accumulator registers $\ACCU^k_t$, each thread's update expression is initialized with it's predecessor $\ACCU^{k - 1}_t$, forming the base case of preserving the previous state.
% Each program statement altering the accumulator then adds an \lstCPP{ite}, returning the successor generated by the \lstinline[style=c++, basicstyle=\normalsize\ttfamily]{Instruction::encode(uint, uint, State)} function
% Starting with the accumulator registers $\ACCU^k_t$, each thread's update expression is built by introducing an \lstCPP{ite} for every program statement altering the accumulator, returning the corresponding successor according to the previously defined implementations of \lstinline[style=c++, basicstyle=\normalsize\ttfamily]{Instruction::encode(uint, uint, State)}.
% Starting with the base case of preserving the previous value, each accumulator register's state update expression is initialized with it's predecessor $\ACCU^{k - 1}_t$.
% Every program statement altering the accumulator then adds an \lstCPP{ite}, returning the according successor state depending on it's execution given by the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ and...
% >>>
% Starting with the accumulator registers $\ACCU^k_t$, each update expression is initialized with it's predecessor $\ACCU^{k - 1}_t$, forming the base case of preserving the previous state.
% >>>
% Every program statement altering the accumulator then adds an \lstCPP{ite} for choosing the successor given by the instruction's \lstinline[style=c++, basicstyle=\normalsize\ttfamily]{Instruction::encode(uint, uint, State)} depending on the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$,   , embedding the current update expression in the \emph{else} branch.
% >>>
% We then add an \lstCPP{ite} for every program statement altering the accumulator to choose the successor state depending on the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ %, given by the instruction's \lstinline[style=c++, basicstyle=\normalsize\ttfamily]{Instruction::encode(uint, uint, State)}
% , utilizing the \lstCPP{Instruction} class's dynamic dispatch mechanism
% and embedding the current update expression in the \emph{else} branch as a fall back in case the statement has not been executed.
% >>>
% ~\\
% ~\\
% $\ACCU^{k - 1}_t$
Starting with the accumulator registers $\ACCU^k_t$, each update expression is initialized with it's predecessor $\ACCU^{k - 1}_t$, forming the base case of preserving the previous state.
% The final expression assigned to $\ACCU^k_t$ is then built by adding an $\ITE$ for every program statement altering the accumulator, choosing the successor state depending on the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$.
% >>>
% Starting with the accumulator registers $\ACCU^k_t$, each update expression is initialized with it's predecessor to preserve the previous state.
% Any program statement altering the accumulator then embeds the expression's current value in the \emph{else} branch of an $\ITE$ setting the successor state by encoding the corresponding instruction, depending on the execution variable $\EXEC^{k - 1}_{t, pc}$.
% Any program statement altering the accumulator then extends the update expression by embedding it's current value in the \emph{else} branch of an $\ITE$, setting the successor state according to the encoded instruction, depending on the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$.
% Any program statement altering the accumulator then extends the expression by embedding it's current value in the \emph{else} branch of an $\ITE$, using the \lstCPP{encode} implementation of the corresponding instruction to set the successor state depending on the execution variable $\EXEC^{k - 1}_{t, pc}$.
Any program statement altering the accumulator then extends the expression by embedding it's current value in the \emph{else} branch of an $\ITE$, using the corresponding instruction's \lstCPP{encode} implementation to set the successor state
depending on the
% according to it's
execution variable $\EXEC^{k - 1}_{t, pc}$.
% execution signalled by $\EXEC^{k - 1}_{t, pc}$.
% in case it has been executed signalled by $\EXEC^{k - 1}_{t, pc}$.
% in case of it's execution signalled by $\EXEC^{k - 1}_{t, pc}$.
% >>>
% To increase readability of the generated \SMTLIB expressions, we use a reverse iterator to create the $\ite$ cascade in program order.

% \begin{lstlisting}[style=c++]
% void define_accu (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % {
      % std::string expr = accu_var(k - 1, t);
      % const auto & stmts = updates[State::accu][t];
      % for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        % expr = ite(exec_var(k - 1, t, *pc),
                   % program[t][*pc]->encode(k - 1, t, State::accu),
                   % expr);
      % formula << assign(accu_var(k, t), expr) << '\n';
    % }
% }
% \end{lstlisting}
%
% \noindent
% \emph{Example:} \lstCPP{define_accu(1)}
%
% \begin{lstlisting}[style=smtlib]
% (assert (= accu_1_0
           % (ite exec_0_0_0
                % (bvadd accu_0_0 #x0001)
                % (ite exec_0_0_2
                     % (ite (and full_0_0 (= adr_0_0 #x0001))
                          % val_0_0
                          % (select heap_0 #x0001))
                     % accu_0_0))))
% (assert (= accu_1_1
           % (ite exec_0_1_0
                % (bvadd accu_0_1 #x0001)
                % (ite exec_0_1_2
                     % (ite (and full_0_1 (= adr_0_1 #x0000))
                          % val_0_1
                          % (select heap_0 #x0000))
                     % accu_0_1))))
% (assert (= accu_1_2
           % (ite exec_0_2_1
                % (bvadd accu_0_2
                       % (ite (and full_0_2 (= adr_0_2 #x0000))
                            % val_0_2
                            % (select heap_0 #x0000)))
                % (ite exec_0_2_2
                     % (bvadd accu_0_2
                            % (ite (and full_0_2
                                      % (= adr_0_2 #x0001))
                                 % val_0_2
                                 % (select heap_0 #x0001)))
                     % accu_0_2))))
% \end{lstlisting}

\begin{lstlisting}[style=c++]
void define_accu (uint k)
{
  for (const auto & [t, stmts] : updates[State::accu])
    {
      std::string next = accu(k - 1, t);
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        next = ite(exec(k - 1, t, *pc),
                   program[t][*pc]->encode(k - 1, t, State::accu),
                   next);
      formula << assign(accu(k, t), next) << '\n';
    }
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_accu(1)}

\begin{lstlisting}[style=smtlib]
(assert (= accu_1_0
           (ite exec_0_0_0
                (bvadd accu_0_0 #x0001)
                (ite exec_0_0_2
                     (ite (and full_0_0 (= adr_0_0 #x0001))
                          val_0_0
                          (select heap_0 #x0001))
                     accu_0_0))))
(assert (= accu_1_1
           (ite exec_0_1_0
                (bvadd accu_0_1 #x0001)
                (ite exec_0_1_2
                     (ite (and full_0_1 (= adr_0_1 #x0000))
                          val_0_1
                          (select heap_0 #x0000))
                     accu_0_1))))
(assert (= accu_1_2
           (ite exec_0_2_1
                (bvadd accu_0_2
                       (ite (and full_0_2 (= adr_0_2 #x0000))
                            val_0_2
                            (select heap_0 #x0000)))
                (ite exec_0_2_2
                     (bvadd accu_0_2
                            (ite (and full_0_2
                                      (= adr_0_2 #x0001))
                                 val_0_2
                                 (select heap_0 #x0001)))
                     accu_0_2))))
\end{lstlisting}

% \todo[inline]{define mem} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% State update functions of the remaining register states $\MEM^k_t$, $\SBADR^k_t$ and $\SBVAL^k_t$ are again defined almost identically and only differ by using the appropriate \lstCPP{State} entries and variable generators.
We omit the implementation of state update functions for the remaining register states $\MEM^k_t$, $\SBADR^k_t$ and $\SBVAL^k_t$, as they only differ by using the appropriate \lstCPP{State} entries and variable generators, but include their output in order to visualize the state updates generated for our demo example.

% \begin{lstlisting}[style=c++]
% void define_mem (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % {
      % std::string val = mem_var(k - 1, t);
      % const auto & stmts = updates[State::mem][t];
      % for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        % val = ite(exec_var(k - 1, t, *pc),
                  % program[t][*pc].encode(k - 1, t, State::mem),
                  % val);
      % formula << assign(mem_var(k, t), val) << '\n';
    % }
% }
% \end{lstlisting}

~\\
\noindent
\emph{Example:} \lstCPP{define_mem(1)}

\begin{lstlisting}[style=smtlib]
(assert (= mem_1_0 mem_0_0))
(assert (= mem_1_1 mem_0_1))
(assert (= mem_1_2 mem_0_2))
\end{lstlisting}

% \todo[inline]{define adr} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_adr (uint k)
% {
  % for (const auto & [t, stmts] : alters[State::adr])
    % {
      % std::string val = adr_var(k - 1, t);
      % for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        % val = ite(exec_var(k - 1, t, *pc),
                  % program[t][*pc].encode(k, t, State::adr),
                  % val);
      % formula << assign(adr_var(k, t), val) << eol;
    % }
  % formula << eol;
% }
% \end{lstlisting}

\newpage

\noindent
\emph{Example:} \lstCPP{define_adr(1)}

\begin{lstlisting}[style=smtlib]
(assert (= adr_1_0 (ite exec_0_0_1 #x0000 adr_0_0)))
(assert (= adr_1_1 (ite exec_0_1_1 #x0001 adr_0_1)))
(assert (= adr_1_2 adr_0_2))
\end{lstlisting}

% \todo[inline]{define val} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_val (uint k)
% {
  % for (const auto & [t, stmts] : alters[State::val])
    % {
      % std::string val = val_var(k - 1, t);
      % for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        % val = ite(exec_var(k - 1, t, *pc),
                  % program[t][*pc].encode(k, t, State::val),
                  % val);
      % formula << assign(val_var(k, t), val) << eol;
    % }
  % formula << eol;
% }
% \end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_val(1)}

\begin{lstlisting}[style=smtlib]
(assert (= val_1_0 (ite exec_0_0_1 accu_0_0 val_0_0)))
(assert (= val_1_1 (ite exec_0_1_1 accu_0_1 val_0_1)))
(assert (= val_1_2 val_0_2))
\end{lstlisting}

% \todo[inline]{define full} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% collection the execution variables $\EXEC^{k - 1}_{t, pc}$ of \lstASM{STORE} instructions and the predecessor $\SBFULL^{k - 1}_t$ to preserve it's state.
% Successors of store buffer full flags are defined by a single
Store buffer full flags $\SBFULL^k_t$ are defined by a single
% Store buffer full states $\SBFULL^k_t$ are defined by a single
% $\ITE$, either resetting the state in case the store buffer has been flushed,
$\ITE$, either falsifying the state in case the store buffer has been flushed,
% or setting it by building a conjunction over the previously collected variables.
or assigning a conjunction over all execution variables $\EXEC^{k - 1}_{t, pc}$ of \lstASM{STORE} instructions to set it if an entry was added, as well as the predecessor $\SBFULL^{k - 1}_t$ for preserving it's state otherwise.

\begin{lstlisting}[style=c++]
void define_full (uint k)
{
  for (const auto & [t, stmts] : updates[State::full])
    {
      std::vector<std::string> args {full(k - 1, t)};
      for (uint pc : stmts)
        args.push_back(exec(k - 1, t, pc));
      formula << assign(full(k, t),
                        ite(flush(k - 1, t),
                            "false",
                            lor(args))) << '\n';
    }
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_full(1)}

\begin{lstlisting}[style=smtlib]
(assert (= full_1_0 (ite flush_0_0
                            false
                            (or full_0_0 exec_0_0_1))))
(assert (= full_1_1 (ite flush_0_1
                            false
                            (or full_0_1 exec_0_1_1))))
(assert (= full_1_2 (ite flush_0_2 false full_0_2)))
\end{lstlisting}

\newpage
\noindent
% \todo[inline]{define stmt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \newpage
% \noindent
% Definition of statement activation flags $\STMT^k_{t, pc}$ relies on the predecessors identified during preprocessing
% Definition of statement activation flags $\STMT^k_{t, pc}$ is based on the execution of preceding instructions, given in the \lstCPP{predecessors} map identified during preprocessing,
% Definition of statement activation flags $\STMT^k_{t, pc}$ relies on the following activation rules, based on the execution of preceding instructions, given in the \lstCPP{predecessors} map identified during preprocessing.
% \begin{itemize}
  % \item if the statement has no predecessor, or none of them is activated (\emph{reactivation}), assign it’s previous value if it’s hasn’t been executed
    % \[
      % \STMT^k_{t, pc} = \STMT^{k - 1}_{t, pc} \land \lnot \EXEC^{k - 1}_{t, pc}
    % \]
  % \item if any predecessor is activated, assign it’s execution variable’s value, otherwise follow the rule for statements without a predecessors
    % \[
      % \STMT^k_{t, pc} = \ITE(\STMT^{k - 1}_{t, pre}, \EXEC^{k - 1}_{t, pre}, \STMT^{k - 1}_{t, pc} \land \lnot \EXEC^{k - 1}_{t, pc})
    % \]
  % \item in the case of a jump, use the conjunction of the jump’s execution variable exec_k_t_pc and it’s condition to activate it’s target
    % \[
    % \]
% \end{itemize}
% Definition of statement activation flags $\STMT^k_{t, pc}$ is based on the execution of preceding instructions, given in the \lstCPP{predecessors} map identified during preprocessing.
% In order to either explicitly deactivate it if or otherwise preserve it's previous state (\emph{reactivation}), the corresponding update expression
% In order to either preserve the activation flag's previous state (\emph{reactivation}), or explicit deactivation in case of its execution, the corresponding update expression is initialized with a conjunction containing or deavtivate it in case of it's execution, the corresponding update expression is initialized with a conjunction
% If the corresponding statement is the initial program instruction, or none of it's predecessors was activated, assign
% Instead of another costly cardinality constraint, definition of statement activation variables $\STMT^k_{t, pc}$ is based on the execution of the corresponding instruction or any of it's preceding program statements to determine their successor by
% Instead of another costly cardinality constraint, definition of statement activation variables $\STMT^k_{t, pc}$ is based on the previous execution of the corresponding instruction and preceding program statements to either deactivate or activate them in the current step.
% To do so, each statement activation variables update expression is initialized with a conjunction containing it's previous state $\STMT^{k - 1}_{t, pc}$ together with the negation of the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ in order to deactivate it in case of it's execution or preserve it's state otherwise.
% >>>
In order to correctly model our symbolic program counters, individual state updates must ensure that at most one statement is activated in any step.
% >>>
% In order to correctly model our symbolic program counters, individual state updates are based on the previous execution of the corresponding statement as well as preceding program instructions to ensure that at most one statement is activated in every step.
% In order to correctly model our symbolic program counters, individual updates of statement activation flags $\STMT^k_{t, pc}$ are based on their previous execution or preceding program instructions to ensure that at most one statement is activated in every step.
% In order to correctly model our symbolic program counters, individual updates of statement activation flags $\STMT^k_{t, pc}$ are based on the previous execution of the corresponding instruction as well as preceding program instructions to ensure that at most one statement is activated in every step.
% In order to correctly model our symbolic program counters, individual state updates of statement activation variables $\STMT^k_{t, pc}$ must ensure that at most one is activated in every step.
% \newpage
% \noindent
% $\STMT^{k - 1}_{t, pc}$t
% Instead of another costly cardinality constraint, the update expression of each statement activation variable $\STMT^k_{t, pc}$ is initialized with a conjunction containing it's previous activation and the negation of the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ for explicitly deactivating the statement in case of it's execution, while preserving it's state otherwise.
% Instead of another costly cardinality constraint, the update expression of each statement activation variable $\STMT^k_{t, pc}$ is initialized with a conjunction containing it's previous activation and the negation of the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ for explicitly deactivating the statement if it has been executed or preserving it's state otherwise.
% >>>
We do so by initializing the update expression of each statement activation variable $\STMT^k_{t, pc}$ with a conjunction containing it's previous activation and the negation of the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ for explicitly deactivating the statement if it has been executed while preserving it's state otherwise.
% >>>
% Each preceding instruction in the thread's program then adds an $\ITE$, setting the successor state to the predecessor's execution
% Similar to defining the successor of register states, each preceding instruction in the thread's program then embeds the expression's current value in the \emph{else} branch of an $\ITE$, activating the statement depending on the particular predecessor's execution.
% Similar to defining the successor of register states, each preceding program statement then embeds the expression's current value in the \emph{else} branch of an $\ITE$, either enabling or disabling the statement activation variable according to the predecessors execution in case it was activated.
% Similar to defining the successor of register states, each preceding program statement then embeds the expression's current value in the \emph{else} branch of an $\ITE$, either enabling or disabling the statement activation variable according to the predecessor's execution.
% Similar to defining the successor of register states, each preceding program statement then embeds the expression's current value in the \emph{else} branch of an $\ITE$, either enabling the statement activation variable depending to the predecessor's execution or keeping it disabled.
Similar to defining the successor of register states, each preceding program statement then embeds the expression's current value in the \emph{else} branch of an $\ITE$, activating the statement depending on the predecessor's execution.
% In case of the predecessor being a conditional jump, identified by \lstCPP{bool is_jump (Instruction *)},
% In case of the statement being the target of a jump,
% Conditional jumps, detected by \lstCPP{is_jump}
% In case of the predecessor being a conditional jump, identified by \lstCPP{is_jump},
% Special care must be taken in case of the predecessor being a conditional jump, identified by \lstCPP{is_jump}, to either activate the target of a successfull jump using a conjunction of it's execution variable and condition, generated by the relevant \lstCPP{encode} implementation, or the negation thereof if it failed.
Special care must be taken in case of the predecessor being a conditional jump, identified by \lstCPP{is_jump}, to either activate the target using a conjunction of it's execution variable and condition, generated by the relevant \lstCPP{encode} implementation, or the next statement by negating the condition in case of a failed jump.

% using a conjunction of the jump's execution variable together with it's condition, generated by the relevant \lstCPP{encode} implementation, or it's negation.
% >>>
% >>>

% preserve state
% deactivate in case of it's execution

% \todo[noline]{introduce anonymous is_jump function}

% \begin{lstlisting}[style=c++]
% void define_stmt (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % for (uint pc = 0; pc < programs[t].size(); pc++)
      % {
        % // statement reactivation
        % std::string expr = land(stmt_var(k - 1, t, pc),
                              % lnot(exec_var(k - 1, t, pc)));
        % // activation by predecessor
        % const auto & stmts = predecessors[t][pc];
        % for (auto pre = stmts.rbegin(); pre != stmts.rend(); ++pre)
          % {
            % std::string exec = exec_var(k - 1, t, *pre);
            % Instruction * op = programs[t][*pre];
            % // add condition if predecessor is a jump
            % if (is_jump(op))
              % {
                % std::string cond = op->encode(k - 1, t, State::stmt);
                % if (!cond.empty())
                  % exec = land(exec,
                              % // negate condition for failed jumps
                              % *pre == pc - 1 && op.arg != pc
                                % ? lnot(cond)
                                % : cond);
              % }
            % expr = ite(stmt_var(k - 1, t, *pre), exec, expr);
          % }
        % formula << assign(stmt_var(k, t, pc), expr) << '\n';
      % }
% }
% \end{lstlisting}

\begin{lstlisting}[style=c++]
void define_stmt (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    for (uint pc = 0; pc < programs[t].size(); pc++)
      {
        // statement reactivation
        std::string next = land(stmt(k - 1, t, pc),
                              lnot(exec(k - 1, t, pc)));
        // activation by predecessor
        const auto & stmts = predecessors[t][pc];
        for (auto pre = stmts.rbegin(); pre != stmts.rend(); ++pre)
          {
            std::string val = exec(k - 1, t, *pre);
            Instruction * op = programs[t][*pre];
            // add condition if predecessor is a jump
            if (is_jump(op))
              {
                std::string cond = op->encode(k - 1, t, State::stmt);
                val = land(val, op->arg == pc ? cond : lnot(cond));
              }
            next = ite(stmt(k - 1, t, *pre), val, next);
          }
        formula << assign(stmt(k, t, pc), next) << '\n';
      }
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_stmt(1)}

\newpage

\begin{lstlisting}[style=smtlib]
(assert (= stmt_1_0_0 (and stmt_0_0_0 (not exec_0_0_0))))
(assert (= stmt_1_0_1 (ite stmt_0_0_0
                           exec_0_0_0
                           (and stmt_0_0_1 (not exec_0_0_1)))))
(assert (= stmt_1_0_2 (ite stmt_0_0_1
                           exec_0_0_1
                           (and stmt_0_0_2 (not exec_0_0_2)))))
(assert (= stmt_1_0_3 (ite stmt_0_0_2
                           exec_0_0_2
                           (and stmt_0_0_3 (not exec_0_0_3)))))
(assert (= stmt_1_0_4 (ite stmt_0_0_3
                           exec_0_0_3
                           (and stmt_0_0_4 (not exec_0_0_4)))))
(assert (= stmt_1_1_0 (and stmt_0_1_0 (not exec_0_1_0))))
(assert (= stmt_1_1_1 (ite stmt_0_1_0
                           exec_0_1_0
                           (and stmt_0_1_1 (not exec_0_1_1)))))
(assert (= stmt_1_1_2 (ite stmt_0_1_1
                           exec_0_1_1
                           (and stmt_0_1_2 (not exec_0_1_2)))))
(assert (= stmt_1_1_3 (ite stmt_0_1_2
                           exec_0_1_2
                           (and stmt_0_1_3 (not exec_0_1_3)))))
(assert (= stmt_1_1_4 (ite stmt_0_1_3
                           exec_0_1_3
                           (and stmt_0_1_4 (not exec_0_1_4)))))
(assert (= stmt_1_2_0 (and stmt_0_2_0 (not exec_0_2_0))))
(assert (= stmt_1_2_1 (ite stmt_0_2_0
                           exec_0_2_0
                           (and stmt_0_2_1 (not exec_0_2_1)))))
(assert (= stmt_1_2_2 (ite stmt_0_2_1
                           exec_0_2_1
                           (and stmt_0_2_2 (not exec_0_2_2)))))
(assert (= stmt_1_2_3 (ite stmt_0_2_2
                           exec_0_2_2
                           (and stmt_0_2_3 (not exec_0_2_3)))))
(assert (= stmt_1_2_4 (ite stmt_0_2_3
                           (and exec_0_2_3 (not (= accu_0_2
                                                   #x0000)))
                           (and stmt_0_2_4 (not exec_0_2_4)))))
(assert (= stmt_1_2_5 (ite stmt_0_2_3
                           (and exec_0_2_3 (= accu_0_2 #x0000))
                           (and stmt_0_2_5 (not exec_0_2_5)))))
\end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% (assert (= stmt_1_0_0 (and stmt_0_0_0 (not exec_0_0_0))))
% (assert (= stmt_1_0_1 (ite stmt_0_0_0
                           % exec_0_0_0
                           % (and stmt_0_0_1 (not exec_0_0_1)))))
% (assert (= stmt_1_0_2 (ite stmt_0_0_1
                           % exec_0_0_1
                           % (and stmt_0_0_2 (not exec_0_0_2)))))
% (assert (= stmt_1_0_3 (ite stmt_0_0_2
                           % exec_0_0_2
                           % (and stmt_0_0_3 (not exec_0_0_3)))))
% (assert (= stmt_1_0_4 (ite stmt_0_0_3
                           % exec_0_0_3
                           % (and stmt_0_0_4 (not exec_0_0_4)))))
% ...
% (assert (= stmt_1_2_0 (and stmt_0_2_0 (not exec_0_2_0))))
% (assert (= stmt_1_2_1 (ite stmt_0_2_0
                           % exec_0_2_0
                           % (and stmt_0_2_1 (not exec_0_2_1)))))
% (assert (= stmt_1_2_2 (ite stmt_0_2_1
                           % exec_0_2_1
                           % (and stmt_0_2_2 (not exec_0_2_2)))))
% (assert (= stmt_1_2_3 (ite stmt_0_2_2
                           % exec_0_2_2
                           % (and stmt_0_2_3 (not exec_0_2_3)))))
% (assert (= stmt_1_2_4 (ite stmt_0_2_3
                           % (and exec_0_2_3 (not (= accu_0_2
                                                   % #x0000)))
                           % (and stmt_0_2_4 (not exec_0_2_4)))))
% (assert (= stmt_1_2_5 (ite stmt_0_2_3
                           % (and exec_0_2_3 (= accu_0_2 #x0000))
                           % (and stmt_0_2_5 (not exec_0_2_5)))))
% \end{lstlisting}

% \todo[inline]{define block} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% Block flags $\BLOCK^k_{id, t}$ are defined by a single $\ITE$, either unblocking the thread by resetting the state if all threads synchronized upon the corresponding checkpoint $id$ in the previous step, or assigning a conjunction including all execution variables $\EXEC^{k - 1}_{t, pc}$ of related \lstASM{CHECK id} instructions to enable it, as well as the predecessor $\BLOCK^{k - 1}_{id, t}$ for preserving it's state.
Block flags $\BLOCK^k_{id, t}$ are defined by a single $\ITE$, unblocking the thread by resetting the state if all threads synchronized upon the corresponding checkpoint $id$ in the previous step. %$k - 1$.
Otherwise, it assigns a disjunction including all execution variables $\EXEC^{k - 1}_{t, pc}$ of related \lstASM{CHECK id} instructions enabling the state, as well as the predecessor $\BLOCK^{k - 1}_{id, t}$ to presere it's value.
%signalled by $\CHECK^{k - 1}_{id}$

\begin{lstlisting}[style=c++]
void define_block (uint k)
{
  for (const auto & [id, threads] : checkpoints)
    for (const auto & [t, stmts] : threads)
      {
        std::vector<std::string> args {block(k - 1, id, t)};
        for (uint pc : stmts)
          args.push_back(exec(k - 1, t, pc));
        formula << assign(block(k, id, t),
                          ite(check(k - 1, id),
                              "false",
                              lor(args))) << '\n';
      }
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_block(1)}

\begin{lstlisting}[style=smtlib]
(assert (= block_1_0_0 (ite check_0_0
                            false
                            (or block_0_0_0 exec_0_0_3))))
(assert (= block_1_0_1 (ite check_0_0
                            false
                            (or block_0_0_1 exec_0_1_3))))
(assert (= block_1_0_2 (ite check_0_0
                            false
                            (or block_0_0_2 exec_0_2_0))))
\end{lstlisting}

% \todo[inline]{define halt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_halt (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % {
      % if (halts.find(thread) != halts.end())
        % {
          % std::vector<std::string> args;
          % for (const auto pc : halts[t])
            % args.push_back(exec_var(k - 1, t, pc));
          % args.push_back(halt_var(k - 1, t));
          % formula << assign(halt_var(k, t), lor(args)) << eol;
        % }
      % else
        % formula << assign(halt_var(k, t), "false") << eol;
    % }
  % formula << eol;
% }
% \end{lstlisting}

\newpage

\noindent
% Since there is no way of restarting a halted thread, halt flags $\Halt^k_t$ are enabled by a disjunction including the execution variables $\EXEC^{k - 1}_{t, pc}$ of \lstASM{HALT} instructions.
Since halt flags $\HALT^k_t$ cannot be reset once a thread has been stopped, they are defined by a simple disjunction including the execution variables $\EXEC^{k - 1}_{t, pc}$ of \lstASM{HALT} instructions and the previous state $\HALT^{k - 1}_t$ to preserve their value.

\begin{lstlisting}[style=c++]
void define_halt (uint k)
{
  for (const auto & [t, stmts] : updates[State::halt])
    {
      std::vector<std::string> args {halt(k - 1, t)};
      for (uint pc : stmts)
        args.push_back(exec(k - 1, t, pc));
      formula << assign(halt(k, t), lor(args)) << '\n';
    }
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_halt(1)}

\begin{lstlisting}[style=smtlib]
(assert (= halt_1_0 (or halt_0_0 exec_0_0_4)))
(assert (= halt_1_1 (or halt_0_1 exec_0_1_4)))
\end{lstlisting}

% \todo[inline]{define heap} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% Definition of the global heap array $\HEAP^k$ again starts by initializing the update expression with it's predecessor $\HEAP^{k - 1}$, preserving the previous state.
Definition of our shared memory array $\HEAP^k$ again starts by initializing the update expression with it's previous state $\HEAP^{k - 1}$.
% Each thread then embeds the expression in the \emph{else} branch an $\ITE$, storing the store buffer's entry in case it was flushed.
% Each thread then extends the expression by embedding it's current value in the \emph{else} branch an $\ITE$, storing the store buffer's entry in case it was flushed.
% Each thread then extends the expression by embedding it in an $\ITE$, storing the store buffer's entry in case it was flushed.
% Each thread then extends the expression by embedding it in an $\ITE$ for every atomic write, modifying the array according to the instruction's \lstCPP{encode} implementation in case of its execution, as well as storing the store buffer entry if it was flushed.
% Each thread then extends the expression by embedding it in an $\ITE$ for every atomic write, modifying the array according to the instruction's \lstCPP{encode} implementation in case of its execution and storing the store buffer entry if it was flushed.
Each thread then extends the expression by embedding it in an $\ITE$ for every atomic write, modifying the array according to the instruction's \lstCPP{encode} implementation, followed by a final one to store the store buffer entry in case it was flushed.
% Each thread then extends the expression by embedding it in an $\ITE$ for every atomic write, modifying the array according to the instruction's \lstCPP{encode} implementation in case of its execution and another one to store the store buffer entry if it was flushed.
%
% Furthermore, if the contains a statement atomically writing to memory, another $\ITE$, modifying array according to the instruction's \lstCPP{encode} implementation is added.
% Furthermore, if the contains a statement atomically writing to memory, another $\ITE$, modifying array according to the instruction's \lstCPP{encode} implementation is added.
% The actual update expression is then built by iteratively embeding it's previous value in the \emph{else} branch of an $\ITE$, storing the

\begin{lstlisting}[style=c++]
void define_heap (uint k)
{
  std::string next = heap(k - 1);
  for (int t = programs.size() - 1; t >= 0; t--)
    {
      const auto & stmts = updates[State::heap];
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        next = ite(exec(k - 1, t, *pc),
                   programs[t][*pc].encode(k - 1, t, State::heap),
                   next);
      next = ite(flush(k - 1, t),
                 store(heap(k - 1),
                       adr(k - 1, t),
                       val(k - 1, t)),
                 next);
    }
  formula << assign(heap(k, t), next) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_heap(1)}

\begin{lstlisting}[style=smtlib]
(assert (= heap_1
           (ite flush_0_0
                (store heap_0 adr_0_0 val_0_0)
                (ite flush_0_1
                     (store heap_0 adr_0_1 val_0_1)
                     (ite flush_0_2
                          (store heap_0 adr_0_2 val_0_2)
                          heap_0)))))
\end{lstlisting}

% \todo[inline]{define exit-flag} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_exit_flag (uint k)
% {
  % if (halts.empty() && exits.empty())
    % return;
%
  % std::vector<std::string> args {exit_flag_var(k - 1)};
%
  % if (!halts.empty())
    % {
      % std::vector<std::string> halt;
      % for (uint t = 0; t < programs.size(); t++)
        % halt.push_back(halt_var(k, t));
      % args.push_back(land(halt));
    % }
%
  % if (!exits.empty())
    % for (const auto & [t, stmts] : exits)
      % for (const auto pc : stmts)
        % args.push_back(exec_var(k - 1, t, pc));
%
  % formula << assign(exit_flag_var(k), lor(args)) << eol << eol;
% }
% \end{lstlisting}

\noindent
% In order to enable the exit flag $\EXIT^k$ according to our termination criteria, we define it as a disjunction containing the execution variables $\EXEC^{k - 1}_{t, pc}$ of every \lstASM{EXIT} statement, a conjunction over all halt variables $\HALT^k_t$ to stop the machine if no more thread is running and the previous state $\EXIT^{k - 1}$, preserving it's value.
In order to enable the exit flag $\EXIT^k$ according to our termination criteria, we define it as a disjunction containing the execution variables $\EXEC^{k - 1}_{t, pc}$ of every \lstASM{EXIT} statement, a conjunction over all halt variables $\HALT^k_t$ stopping the machine if no more thread is running and the previous state $\EXIT^{k - 1}$ to preserve it's value.

\begin{lstlisting}[style=c++]
void define_exit(uint k)
{
  std::vector<std::string> halts;
  for (const auto & [t, _] : updates[State::halt])
    halts.push_back(halt(k, t));
  std::vector<std::string> args {exit(k - 1), land(halts)};
  for (const auto & [t, stmts] : updates[State::exit])
    for (uint pc : stmts)
      args.push_back(exec(k - 1, t, pc));
  formula << assign(exit(k), lor(args)) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_exit(1)}

\begin{lstlisting}[style=smtlib]
(assert (= exit_1
           (or exit_0
               (and halt_1_0 halt_1_1)
               exec_0_2_4
               exec_0_2_5)))
\end{lstlisting}

% \todo[inline]{define exit-code} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_exit_code ()
% {
  % std::string expr = consth(0);
  % if (!exits.empty())
    % for (uint k = 0; k <= bound; k++)
      % for (int t = programs.size() - 1; t >= 0; t--)
          % for (const auto & pc : exits[t])
            % expr = ite(exec_var(k, t, pc),
                      % programs[t][pc].encode(k, t, State::exit),
                      % expr);
  % formula << assign(exit_code_var, expr) << '\n';
% }
% \end{lstlisting}

\noindent
% Our functional encoding scheme is concluded by the definition of the machine's exit code $\EXITCODE$.
% Our functional encoding scheme is concluded by defining the machine's exit code $\EXITCODE$.
Our functional encoding scheme is concluded by setting the machine's exit code during the final step.
% >>>
% Since it is only assigned once, \emph{static single assignments} allow us to reduce the total number of variables by introducing only a single state
%, defined by an $\ITE$ cascade over all steps $k \in [0, bound]$
% for all steps $k \in [0, bound]$
% >>>
% Since it is unique in every execution, \emph{static single assignments} allow us to reduce the total number of variables by introducing only a single state for all $k \in [0, bound]$.
Since it is unique in every execution, explicit unrolling allows us to reduce the total number of variables by introducing only a single state $\EXITCODE$, %for all steps $k \in [0, bound]$.
% Since it is unique in every execution, the total number of variables can be reduced by introducing only a single state in our unrolled model checking problem,
% Since it is unique in every execution, unrolling our model checking problem for each step $k \in [0, bound]$ allows us to reduce the total number of variables by introducing only a single state for all $k \in [0, bound]$,
% assigned during the final step $k = bound$.
% The defining expression is initialized with zero and extended by embedding it in an $\ITE$
% embedding it in an $\ITE$, covering the execution of any \lstASM{EXIT} statement by assigning the according value, depending on
defined by an expression initialized with zero and embedded in an $\ITE$
for each step $k \in [0, bound]$ and \lstASM{EXIT} statement, assigning the corresponding exit code in case of its execution.
% >>>
% In order to reduce the total number of variables, only a single state is used in
% update expression initialized with the default exit code.

\begin{lstlisting}[style=c++]
void define_exit_code ()
{
  std::string next = consth(0);
  for (uint k = 0; k <= bound; k++)
    for (const auto & [t, stmts] : updates[State::exit])
      for (uint pc : stmts)
        next = ite(exec(k, t, pc),
                   programs[t][pc].encode(k, t, State::exit),
                   next);
  formula << assign(exit_code, next) << '\n';
}
\end{lstlisting}

\begin{lstlisting}[style=smtlib]
(assert (= exit-code
           (ite exec_17_2_5
                #x0001
                (ite exec_17_2_4
                     #x0000
                     ...
                     (ite exec_0_2_5
                          #x0001
                          (ite exec_0_2_4
                               #x0000
                               #x0000))))))
\end{lstlisting}

\newpage

\subsubsection*{Relational Next State Logic}

% > show difference in terms of runtime
% State of the art SAT and SMT solvers are able to exploit certain structures in the problem formulation, increasing performance in terms of runtime.
% Different encodings may therefore exhibit a rather drastical impact on the relative hardness of the resulting formula.
Since state of the art SAT and SMT solvers are able to exploit certain structures in the problem formulation, the relative hardness of different semantically equivalent encodings may vary quite drastically.
% State of the art SAT and SMT solvers  their performance partly by exploiting the structure of a given problem.
% structural changes in the problem formulation
% In order to show the differences of structural
% semantically equivalent encodings in terms of the
% generated by using the \texttt{-e smtlib-relational} command line parameter.
% better for combinatorial problems and small domains
% To highlight these differences, we include another encoding using a relational next state logic, sought to be more suitable for large combinatorial problems and small domains, generated by using the \texttt{-e smtlib-relational} command line parameter.
% relational next state logic
% requireing order of magnitude more time to solve than our previous functional approach, leading to a tree-like/hierarchical structure
% > highlight differences
% > next states fully implied by each transition
To highlight these differences,
we included another variant using a relational next state logic,
generated with the \texttt{-e smtlib-relational} command line parameter, % and
% based on states being fully implied by each transition.
% based on implying the complete set of successors for each transition.
based on implying the successors for each possible transition.
% > flat encoding sought of being more suitable for combinatorial problems and small domains
% > order of magnitude more time to solve compared to functional approach, resulting in a hierarchical structure | expression tree
% > simplified by term rewriting during the solver's preprocessing stage
Although this flat encoding scheme tends to work well with large combinatorial problems and small domains, it requires an order of magnitude more time to solve compared to our functional approach, which can be radically simplified by clever term rewriting due to its strictly hierarchical nature. %structure.

% \todo[inline]{define states (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_states (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    {
      imply_thread_executed(k, t);
      imply_thread_not_executed(k, t);
      imply_thread_flushed(k, t);
    }
  imply_machine_exited(k);
}
\end{lstlisting}

\noindent
We begin by defining variadic template functions for simplifying the generation of frequently reoccurring expressions, used to restore a state's previous value and additionally reset flags depending on a given condition.
% conditionally reset flags.
%for generating a frequently reoccuring pattern

% \begin{lstlisting}[style=c++, belowskip=\medskipamount]
\begin{lstlisting}[style=c++]
template <class R, class ... T>
R restore (R (*var) (uint k, T ... args), uint k, T ... args)
{
  return equal(var(k, args...), var(k - 1, args...));
}
\end{lstlisting}

\begin{lstlisting}[style=c++, aboveskip=0pt]
template <class R, class ... T>
R reset (R (*var) (uint k, uint x, T ... args),
         R (*cond) (uint k, uint x),
         uint k, uint x, T ... args)
{
  return equal(var(k, x, args...),
               ite(cond(k - 1, x),
                   "false",
                   var(k - 1, x, args...)));
}
\end{lstlisting}

\noindent
% Definition of successor states depending on the execution of a certain thread is simplified by introducing the following custom map,
% consolidating the next state expressions
% initialized with the common next state expressions
% Implying the successor states according to the execution of a certain thread requires m
% In order to minimize the effort when defining the successors for each possible instruction, we introduce the following custom map
% >>>
% Implying the whole set of states influenced by executing any instruction leads to most of them being unchanged and required to be preserved in the next step.
% Implying the whole set of states that may be influenced by executing any kind of instruction leads to most of them being unchanged and required to be preserved in the next step.
% Implying all states that might be influenced by executing a certain thread, leads to most of them being unchanged by any specific instruction.
Implying a common set of states that might be influenced by executing a certain thread
% leads to most of them being unchanged by any specific statement.
results in most of them being unchanged by any specific statement.
% Implying a common set of states for each statement that might be executed by a certain thread
% Since most states remain unchanged when executing a certain instruction, implying
% >>>
% To reduce the effort when implementing the next state functions of every instruction, we introduce the following custom map,
% To reduce the implementation effort for a particular instruction's encoding function, we introduce the following custom map,
% >>>
% To reduce the effort during the implementation of each instruction's encoding function, we introduce the following custom map,
% To reduce the implementation effort for each instruction's encoding function, we introduce the following custom map,
% To reduce the effort involved in implementing the next state function of each instruction, we introduce the following map, % !
% containing the default expressions for restoring the previous value of this common set of states,
% containing the common set of states, initialized with the default expression for restoring their value,
% initialized with the default expressions for restoring this common set of states in the current step,
% aggregating all relevant states and initializing them with the corresponding state-preserving expression, % !
% containing the common set of states, initialized with the default expression for restoring their value,
% >>>
% initialized the update expression of all common states
% thus requiring only the entries of states actually being altered to be replaced.
% in order to set only the states that actually change.
% such that only the ones set by the specific instruction needs to be overwritten
% thus requiring only the entries of states which are actually altered to be replaced. % !
% >>>
% We introduce the following next state map to reduce the effort involved in implementing the encoding function of each instruction by aggregating all relevant states and initializing them with the corresponding state-preserving expression, thus requiring only the entries of states which are actually altered to be replaced.
% >>>
% Furthermore, it offers an implicit \lstCPP{std::string} conversion operator, returning a conjunction to define the successors of all contained states at once.
% Furthermore, it offers an implicit \lstCPP{std::string} conversion operator, returning a conjunction to define the successors of all contained states at once.
% >>>
% In order to reduce the effort involved in implementing the encoding function of each instruction we introduce the following map, aggregating all relevant states and provide an implicit \lstCPP{std::string} conversion operator returning a conjunction to define the successors of all contained states at once.
In order to reduce the effort involved in implementing the encoding function of each instruction, we introduce the following map,
using the previously defined template functions to initialize it with the corresponding state-preserving expressions,
% and provide an implicit \lstCPP{std::string} conversion operator returning a conjunction to define the successors of all contained states at once.
thus requiring only the entries of states which are actually altered to be replaced
and provide an implicit \lstCPP{std::string} conversion operator returning a conjunction to define all successors at once.
% By using the previously defined template functions, we are able to add a constructor to initialize them with the corresponding state-preserving expressions for a given step and thread, thus requiring only the entries of states which are actually altered to be replaced.
% Furthermore, they are initialized with corresponding state-preserving expressions, thus requiring only the entries of states which are actually altered to be replaced.

% \todo[inline]{map containing next state expressions to simplify definition of successor states that depend on the execution of a certain thread}
% \todo[inline]{replace entries with the required next state expressions}
% \todo[inline]{implicit \lstCPP{std::string} conversion operator: returning a conjunction defining the successors for all states contained}
% \todo[inline]{used by \lstCPP{imply_thread_*executed}}

% // restore block
% if (!checkpoints.empty())
%   {
%     std::vector<std::string> block_vars;
%     for (const auto & [id, threads] : checkpoints)
%       if (threads.find(t) != threads.end())
%         block_vars.push_back(reset(&block_var,
%                                    &check_var,
%                                    k, id, t));
%     (*this)[State::block] = land(block_vars);
%   }
\begin{lstlisting}[style=c++]
struct Next : std::map<State, std::string>
{
  Next (k, t)
    {
      (*this)[State::accu] = restore(&accu, k, t);
      (*this)[State::mem] = restore(&mem, k, t);
      (*this)[State::adr] = restore(&adr, k, t);
      (*this)[State::val] = restore(&val, k, t);
      (*this)[State::full] = restore(&full, k, t);
      (*this)[State::halt] = restore(&halt, k, t);
      (*this)[State::heap] = restore(&heap, k);
      (*this)[State::exit] = lnot(exit(k, t));
      std::vector<std::string> block_vars;
      for (const auto & [id, threads] : checkpoints)
        if (threads.find(t) != threads.end())
          block_vars.push_back(reset(&block,
                                     &check,
                                     k, id, t));
      if (!block_vars.empty())
        (*this)[State::block] = land(block_vars);
    }

  operator std::string () const
    {
      std::vector<std::string> args;
      for (const auto & [_, expr] : *this)
        if (!expr.empty())
          args.push_back(expr);
      return land(args);
    }
};
\end{lstlisting}

% \todo[inline]{changed by every instruction and therefore not included in the next state map}
% \todo[inline]{requires setting all statement activation variables of a given thread}
% \todo[inline]{helper functions for activating a certain statement}

\newpage
\noindent
Since the statement activation variables $\STMT^k_{t, pc}$ of each thread must be fully defined for every possible transition, we include helper functions to generate the required conjunctions.

\begin{lstlisting}[style=c++]
std::string activate (uint k, uint t, uint pc)
{
  std::vector<std::string> stmts;
  for (uint i = 0; i < programs[t].size(); i++)
    stmts.push_back(i == pc ? stmt(k, t, pc)
                            : lnot(stmt(k, t, i)));
  return land(stmts);
}
\end{lstlisting}

% \todo[inline]{overload to be used by jump instructions, either activating the successor statement or jump target depending on its condition}
\noindent
% In terms of jump instructions, we define another overload for either activating the successor statement or the target, depending on the corresponding condition.
In case of jump instructions, another overload either activates the target or successor statement, depending on the corresponding condition.
% Another overload handles jump instructions by either activating the successor statement or the target, depending on the corresponding condition.

% \begin{lstlisting}[style=c++, aboveskip=0pt]
\begin{lstlisting}[style=c++]
std::string activate (uint k, uint t, uint pc, Instruction * jmp)
{
  std::vector<std::string> stmts;
  std::string condition = jmp->encode(k - 1, t, State::stmt);
  for (uint i = 0; i < programs[t].size(); i++)
    {
      std::string stmt_var = stmt(k, t, i);
      if (i == jmp->arg)
        stmts.push_back(ite(condition, stmt_var, lnot(stmt_var)));
      else if (i == pc + 1)
        stmts.push_back(ite(condition, lnot(stmt_var), stmt_var));
      else
        stmts.push_back(lnot(stmt_var));
    }
  return land(stmts);
}
\end{lstlisting}

% \todo[inline]{add another virtual member to \lstCPP{Instruction} class to dynamically dispatch encoding functions}

\noindent
% The next state functions, responsible for defining the successors when executing a certain instruction, are implemented by including yet another virtual member function to the \lstCPP{Instruction} class.
% Analogously to the encoding functions responsible for defining a specific next state
% by dynamically dispatching the according encoding function.
% Generating the next state for each possible instruction
% Encoding the common set of next states for every possible instruction
% Generating the common set of successor states for every possible instruction according to our relational encoding scheme
Generating a common set of successor states for every possible instruction %according to our relational encoding scheme
% according to our relational logic
% again relies on
is again based on
dynamically dispatched virtual member functions of concrete \lstCPP{Instruction} class instantiations.
% dispatched member functions achieved by adding the following virtual member function to the \lstCPP{Instruction} class
% We therefore introduce
Therefore, we introduce the following overload including the current program counter for activating the next statement. % and their actual implementations given below.

% \todo[inline]{adding the following virtual member function to the \lstCPP{Instruction} class and their concrete implementations given below}
% \todo[inline]{including its program counter to activate successor statements}

% \lstCPP{virtual std::string Instruction::encode (uint t, uint k, uint pc) = 0;}
\begin{lstlisting}[style=c++]
virtual std::string Instruction::encode (uint t, uint k, uint pc) = 0;
\end{lstlisting}

% \todo[inline]{encode LOAD (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
By using the previously defined helper constructs, the actual implementations can be simplfified quite drastically and are given below. % of every instruction's encoding function
% The actual implementations are given below and can be simplified quite drastically by using the previously defined helper constructs.
% The actual implementations can be simplified quite drastically by using the previously defined helper constructs and are given below.

\newpage

\defencode{\lstASM{LOAD arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Load::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode STORE (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{STORE arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Store::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::adr] = equal(adr(k, t), encode(k - 1, t, State::adr));
  next[State::val] = equal(val(k, t), encode(k - 1, t, State::val));
  next[State::full] = full(k, t);
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode FENCE (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{FENCE}}
\begin{lstlisting}[style=c++, style=encode]
std::string Fence::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode ADD (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{ADD arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Add::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode ADDI (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{ADDI arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Addi::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode SUB (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{SUB arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Sub::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode SUBI (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{SUBI arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Subi::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode MUL (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{MUL arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Mul::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode MULI (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{MULI arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Muli::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode CMP (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{CMP arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Cmp::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JMP (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JMP arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jmp::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, arg);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JZ (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JZ arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jz::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JNZ (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{JNZ arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jnz::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Js::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JNS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JNS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jns::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JNZNS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JNZNS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jnzns::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode MEM (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{MEM arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Mem::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::mem] = equal(mem(k, t), encode(k - 1, t, State::mem));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode CAS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{CAS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Cas::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  next[State::heap] = equal(heap(k),
                            encode(k - 1, t, State::heap));
  return next;
}
\end{lstlisting}

% \todo[inline]{encode CHECK (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{CHECK arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Check::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc + 1);
  std::vector<std::string> blocks;
  for (const auto & [id, threads] : checkpoints)
    if (threads.find(t) != threads.end())
      blocks.push_back(id == op.arg
                         ? block(k, id, t)
                         : reset(&block, &check, k, id, t));
  next[State::block] = land(blocks);
  return state;
}
\end{lstlisting}

\noindent
Since the might be multiple checkpoints per thread, the encode function
has to enable the corresponding blocking flag $\BLOCK^k_{id, t}$, while preserving or resetting any other.

% \todo[inline]{encode HALT (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{HALT}}
\begin{lstlisting}[style=c++, style=encode]
std::string Halt::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, -1);
  if (programs.size() > 1)
    {
      std::vector<std::string> args;
      for (uint thread = 0; thread < programs.size(); thread++)
        if (thread != t)
          args.push_back(halt(k, thread));
      next[State::halt] =
        land(halt(k, t),
             ite(land(args),
                 land(exit(k), equal(exit_code, consth(0))),
                 lnot(exit(k))));
    }
  else
    next[State::halt] = land(halt(k, t),
                             exit(k),
                             equal(exit_code, consth(0))));
  state.erase(state.find(State::exit));
  return state;
}
\end{lstlisting}

\noindent
% Setting a thread's halt flag $\HALT^k_t$
% Stopping the machine if all halt flags $\HALT^k_t$ are set, we have to distinguish between single and multi threaded programs.
Stopping the machine if all threads halted is achieved by an $\ITE$, enabling the exit flag $\EXIT^k$ and assigning the default exit code if all halt flags $\HALT^k_t$ are set.
Otherwise, the exit flag is disabled to continue execution.
% In case only a single thread is running, the exit variables can be
Since the exit flag is now already contained in the \lstCPP{State::halt} entry, we have to erase \lstCPP{State::exit} to prevent conflicts due to its falsification. %, leading to a conflict.

% \todo[inline]{encode EXIT (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{EXIT arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Exit::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, -1);
  next[State::exit] = exit(k);
  next[State::exit_code] = equal(exit_code,
                                 encode(t, k, State::exit_code));
  return state;
}
\end{lstlisting}

\newpage

% \todo[inline]{imply thread executed} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \noindent
% Before we continue with the main functions, implying the next states for each transition,
% wrapper used to generate the assertions for implying the next states of a given transition.

% \begin{lstlisting}[style=c++]
% std::string imply_next (std::string var, std::string state)
% {
  % return assertion(imply(var, state));
% }
% \end{lstlisting}

\noindent
% With all utility constructs and instruction related encoding functions being defined, we are now able to generate the actual implications, starting with the successor states after executing any given statement.
With all utility constructs and instruction related encoding functions defined, we are now able to imply the next states for all transitions, starting with the execution of any given statement.
% Execution of a certain statement, signalled by $\EXEC^{k - 1}_{t, pc}$,
% Starting with the implication of successor states of
% using the previously defined enconding functions.

% // smtlib::Relational::imply_thread_executed -----------------------------------
% //
% // thread t executed an instruction (exec_k_t_pc):
% // * update thread state accordingly
% // * restore heap (or update upon a successful CAS)
% // * unset exit flag iff neither an EXIT, nor a HALT
% // * set exit code iff the instruction was an EXIT
\begin{lstlisting}[style=c++]
void imply_thread_executed (uint k, uint t)
{
  for (uint pc = 0; pc < programs[t].size(); pc++)
    formula << assertion(imply(exec(k - 1, t, pc),
                               programs[t][pc]->encode(k, t, pc)))
            << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{imply_thread_executed(1, 0)}

\begin{lstlisting}[style=smtlib]
(assert (=> exec_0_0_0 ; ADDI 1
            (and (= accu_1_0 (bvadd accu_0_0 #x0001))
                 (= mem_1_0 mem_0_0)
                 (= adr_1_0 adr_0_0)
                 (= val_1_0 val_0_0)
                 (= full_1_0 full_0_0)
                 (and (not stmt_1_0_0)
                           stmt_1_0_1
                      (not stmt_1_0_2)
                      (not stmt_1_0_3)
                      (not stmt_1_0_4))
                 (= block_1_0_0 (ite check_0_0 false block_0_0_0))
                 (= halt_1_0 halt_0_0)
                 (= heap_1 heap_0)
                 (not exit_1))))
(assert (=> exec_0_0_1 ; STORE 0
            (and (= accu_1_0 accu_0_0)
                 (= mem_1_0 mem_0_0)
                 (= adr_1_0 #x0000)
                 (= val_1_0 accu_0_0)
                 full_1_0
                 (and (not stmt_1_0_0)
                      (not stmt_1_0_1)
                      stmt_1_0_2
                      (not stmt_1_0_3)
                      (not stmt_1_0_4))
                 (= block_1_0_0 (ite check_0_0 false block_0_0_0))
                 (= halt_1_0 halt_0_0)
                 (= heap_1 heap_0)
                 (not exit_1)))) ...
\end{lstlisting}

% \todo[inline]{imply thread not executed} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% In case a thread was not executed, all local states must be preserved, except the store
% In case a thread is not executed, it still might flush it's store buffer, % or have a block flag reset by another thread executing the corresponding checkpoint's final \lstASM{CHECK} instruction.
% or is released from a checkpoint if another thread just executed the corresponding \lstASM{CHECK} instruction.
% All local thread states are therefore preserved, while the store buffer full flag $\SBFULL^k_t$ and any block flag $\BLOCK^k_{id, t}$ might be reset.
% while preserving all local states.
% >>>
% In case a thread was not executed in the previous step, all local states must be preserved, while the store buffer full flag $\SBFULL^k_t$ and block flags $\BLOCK^k_{id, t}$ might be reset by a store buffer flush or due to being released from a checkpoint if another thread executed the corresponds \lstASM{CHECK} instruction.
In case a thread was not executed in the previous step, all local states must be preserved except the store buffer full flag $\SBFULL^k_t$ and block flags $\BLOCK^k_{id, t}$, as they might be reset by a store buffer flush, or due to being released from a checkpoint if another thread executed the corresponds \lstASM{CHECK} instruction.

% // imply_thread_not_executed
% //
% // thread t didn't execute an instruction (not thread_k_t):
% // * preserve thread state
% // * reset full iff the thread's store buffer has been flushed
\begin{lstlisting}[style=c++]
void imply_thread_not_executed (uint k, uint t)
{
  Next next(k, t);
  next[State::full] = reset(&full, &flush, k, t);
  std::vector<std::string> stmts;
  for (uint pc = 0; pc < programs.size(); pc++)
    stmts.push_back(restore(&stmt, k, t, pc));
  next[State::stmt] = land(stmts);
  next.erase(next.find(State::heap));
  next.erase(next.find(State::exit));

  formula << assertion(imply(lnot(thread(k - 1, t)), next)) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{imply_thread_not_executed(1, 0)}

\begin{lstlisting}[style=smtlib]
(assert (=> (not thread_0_0)
            (and (= accu_1_0 accu_0_0)
                 (= mem_1_0 mem_0_0)
                 (= adr_1_0 adr_0_0)
                 (= val_1_0 val_0_0)
                 (= full_1_0 (ite flush_0_0 false full_0_0))
                 (and (= stmt_1_0_0 stmt_0_0_0)
                      (= stmt_1_0_1 stmt_0_0_1)
                      (= stmt_1_0_2 stmt_0_0_2)
                      (= stmt_1_0_3 stmt_0_0_3)
                      (= stmt_1_0_4 stmt_0_0_4))
                 (= block_1_0_0 (ite check_0_0 false block_0_0_0))
                 (= halt_1_0 halt_0_0))))
\end{lstlisting}

% \todo[inline]{imply thread flushed} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\noindent
% Since all thread states are already handeled,
With all local thread states already being set,
% Since resetting the store buffer full flag $\SBFULL^k_t$ is already handeled by the previous function,
% a thread flushing it's store buffer only needs to set the relevant global machine states, namely writing the heap array $\HEAP^k$ and disabling the exit flag $\EXIT^k$ to continue execution.
% a thread flushing it's store buffer
a store buffer flush
% only needs to write the heap array $\HEAP^k$ and disable the exit flag $\EXIT^k$ to continue executing.
% just writes the heap array $\HEAP^k$ and disables the exit flag $\EXIT^k$ to continue execution.
just needs to write the heap array $\HEAP^k$ and disable the exit flag $\EXIT^k$ to continue execution.
% continue execution by disabling the exit flag $\EXIT^k$.

% // imply_thread_flushed
% //
% // thread t flushed its store buffer (flush_k_t):
% // * update heap
% // * unset exit flag
\begin{lstlisting}[style=c++]
void imply_thread_flushed (uint k, uint t)
{
  formula << assertion(imply(flush(k - 1, t),
                             land(equal(heap(k),
                                        store(heap(k - 1),
                                              adr(k - 1, t),
                                              val(k - 1, t)))
                                  lnot(exit(k))))) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{imply_thread_flushed(1, 0)}

\begin{lstlisting}[style=smtlib]
(assert (=> flush_0_0
            (and (= heap_1 (store heap_0 adr_0_0 val_0_0))
                 (not exit_1))))
\end{lstlisting}

% \todo[inline]{imply machine exited} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
Finally, to keep the model consistent if the machine terminated in a step $k < bound$, the heap array $\HEAP^{k - 1}$ must be preserved.
% On the other hand, if the machine still has not exited in the final step, the exit code needs to be set since it would remain undefined.
On the other hand, if the machine is still running in the final step,
% the exit code needs to be set since it would remain undefined.
we need to set the default exit code as it would otherwise remain undefined.

% // imply_machine_exited
% //
% // machine exited (exit_k):
% // * preserve exit flag
% // * preserve heap
% // * set exit code to zero iff machine never exited (step == bound)
\begin{lstlisting}[style=c++]
void imply_machine_exited (uint k)
{
  formula << assertion(imply(exit(k - 1),
                             land(restore(&heap, k),
                                  exit(k)))) << '\n';
  if (k == bound)
    formula << assertion(imply(lnot(exit(k)),
                               equal(exit_code, consth(0))))
            << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{imply_machine_exited(1, 0)}

\begin{lstlisting}[style=smtlib]
(assert (=> exit_0 (and (= heap_1 heap_0) exit_1)))
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{imply_machine_exited(17, 0)}

\begin{lstlisting}[style=smtlib]
(assert (=> exit_16 (and (= heap_17 heap_16) exit_17)))
(assert (=> (not exit_17) (= exit-code #x0000)))
\end{lstlisting}

\subsection{BTOR2}

% We also included the possibility to generate the novel word level model checking format \BTOR \cite{ref:BTOR2}, providing a sequential extensions for specifying word-level model checking problems with registers and memories.
We also included the possibility to generate the word level model checking format {\BTOR} \cite{ref:BTOR2}, using the \texttt{-e btor2} command line parameter.
% providing a \emph{sequential extension} for specifying % register and array states in combination with a transition function,
% By providing a \emph{sequential extension} for specifying % register and array states in combination with a transition function,
It provides a \emph{sequential extension} for specifying % register and array states in combination with a transition function,
states in combination with their transition functions,
which are automatically unrolled via symbolic substitution by the accompanying bounded model checker BtorMC.
% the generated formulas size remains constant with respect to the upper bound, compared to the linear growth of our {\SMTLIB} encodings.
% it produces constant sized formulas with respect to the upper bound
% In contrast to \SMTLIB, which requires manual unrolling, \BTOR produces constant sized formulas with respect to the upper bound.
% Automatic unrolling via symbolic substitution by the accompanying bounded model checker BtorMC
% >>>
In contrast to the linear growth of our {\SMTLIB} encodings, the generated formulas size therefore remains constant for any given bound. % with respect to the upper bound.
% The generated formulas size therefore remains constant with respect to the upper bound, compared to the linear growth of our {\SMTLIB} encodings.
% In contrast to {\SMTLIB}, which requires manual unrolling, it produces constant sized formulas with respect to the upper bound by providing a \emph{sequential extension} for specifying states in combination with their transition functions.
% states in combination with their transition functions.
% symbolicly substituting current state expressions into next state functions and incremental SMT solving.
% Its line based syntax on the other hand requires more housekeeping, leading to a slightly more complex encoding process.
% We omit an outline of the encoding process, as it is semantically equivalent to the {\SMTLIB} formulas using our functional next state logic and a bit more tedious due to the line based syntax.
% We omit an outline of the encoding process, as it is semantically equivalent to the previous one using our functional next state logic and a bit more tedious due to the line based syntax.
We omit further details about the encoding process, as it is more or less identical to the previous using our functional next state logic, but a bit more tedious due to the line based syntax.

% \todo[inline]{BTOR2 - word level model checking format \cite{ref:BTOR2}}
% \todo[inline]{provides sequential extensions for specifying word-level model checking problems with registers and memories}
% \todo[inline]{implicit unrolling using symbolic simulation}
% \todo[inline]{solver BtorMC}
% \todo[inline]{constant formula size w.r.t. the upper bound}
% \todo[inline]{generated by using the \texttt{-e btor2} command line parameter}

% \subsubsection{BTOR2 generator functions}
% \todo[inline]{BTOR2 generator functions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{lstlisting}[style=c++]
% template <class ... T>
% std::string expr (const std::string & nid, const T & ... args)
% {
  % std::string e = nid;
  % (((e += ' ') += args), ...);
  % auto & end = e.back();
  % if (end == ' ')
    % end = eol;
  % else
    % e += eol;
  % return e;
% }
% \end{lstlisting}
%
% \todo[inline]{main encoding function (smtlib)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{lstlisting}[style=c++]
% void encode ()
% {
  % declare_sorts();
  % declare_constants();
  % define_mmap();
  % declare_states();
  % declare_inputs();
  % define_transitions();
  % define_constraints();
  % define_states();
% }
% \end{lstlisting}
%
% \todo[inline]{declare sorts} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{lstlisting}[style=c++]
% void declare_sorts ()
% {
  % formula <<
    % sort_bitvec(sid_bool = nid(), "1") <<
    % sort_bitvec(sid_bv = nid(), std::to_string(word_size)) <<
    % sort_array(sid_heap = nid(), "2", "2") <<
    % eol;
% }
% \end{lstlisting}

\subsection{Replay}

In order to validate the correctness of our encodings, we included a \texttt{replay} \CHANGE{mode} for reevaluating the execution sequence of a given trace by the virtual machine used for simulation.
If a mismatch is found, it returns the first step in which the results start to differ and prints the corresponding states of both execution traces for comparison.
% prints the states of the first step in which the results start to differ and returns
% printing the first step in which the traces start to differ
% returning step in which the resulting models start to differ and print
