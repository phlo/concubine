% \section{Bounded Model Checking}
\section{Encoding Scheme}

The main part of this work is implemented in the \texttt{solve} \CHANGE{mode},
% allowing the verification of concurrent assembly programs by bounded model checking based on register states in our abstract machine model.
% allowing bounded model checking of concurrent assembly programs based on register states in our abstract machine model.
% performing bounded model checking of concurrent software running on our abstract machine model.
allowing verification of concurrent software running on our abstract machine model by the means of bounded model checking \cite{ref:BMC}.
It takes an arbitrary number of programs plus the upper bound \CHANGE{$\BOUND$} as input and encodes them into a finite state machine, expressed as \CHANGE{an} SMT formula where each transition translates to the execution of a single thread.
{\SMTLIB} \cite{ref:SMT-Lib} and the novel {\BTOR} \cite{ref:BTOR2} word level model checking format can be generated, using the theories of arrays, uninterpreted functions and bit-vectors.
To simplify the definition of bad states directly in the program code, the possibility of encountering an exit code greater than zero is checked for per default, but custom properties \CHANGE{may} be defined in a separate file and added with the \texttt{-c} command line parameter.
The resulting formula is then evaluated by a state-of-the-art \CHANGE{SMT} solver.
If it is satisfiable, the corresponding execution trace is extracted from \CHANGE{a generated} model and stored for later inspection.

% \todo{intro
  % \begin{itemize}
    % \item submodule \texttt{solve}
    % \item verification of assembly programs by bounded model checking based on register states
    % \item property: there exists a trace in which $\mathbf{EG^?F^?}(\EXITCODE \neq 0)$ holds (exists globally)
    % \item using satisfiability modulo theories (arrays and bit-vectors)
    % \item problem defined by state and transition variables
    % \item one step corresponds to a specific thread's execution of a single instruction
  % \end{itemize}
% }

% \todo[inline]{Basic Definitions? sorts, functions, etc.}

% \subsection*{Basic Encoding Scheme}
\subsection*{Formal Model}

Let $\BVSORT[n]$ be the fixed size bit-vector sort of width $n$ and $\ASORT[n]$ the array sort with index and element sorts $\BVSORT[n]$.
The following variables are used to encode the machine state at a particular step \CHANGE{$k \leq \BOUND$}, where $k = 0$ is the initial state.

% \renewcommand{\arraystretch}{1.5}
\setlength{\tabulinesep}{3pt}
\begin{longtabu}{llX}
  \firsthline
  % \textbf{Machine} &&\\
  % \hline
  $\HEAP^k$ & $\in \ASORT$ & shared memory \\
  $\EXIT^k$ & $\in \BVSORT[1]$ & exit flag \\
  $\EXITCODE^k$ & $\in \BVSORT$ & exit code \\
  \hline
  % \textbf{Threads} &&\\
  % \hline
  $\ACCU^k_t$ & $\in \BVSORT$ & accumulator register of thread $t$ \\
  $\MEM^k_t$ & $\in \BVSORT$ & \lstASM{CAS} memory register of thread $t$ \\
  $\SBADR^k_t$ & $\in \BVSORT$ & store buffer address register of thread $t$ \\
  $\SBVAL^k_t$ & $\in \BVSORT$ & store buffer value register of thread $t$ \\
  $\SBFULL^k_t$ & $\in \BVSORT[1]$ & store buffer full flag of thread $t$ \\
  $\STMT^k_{t, pc}$ & $\in \BVSORT[1]$ & activation flag for statement at $pc$ of thread $t$ \\
  $\BLOCK^k_{id, t}$ & $\in \BVSORT[1]$ & block flag for checkpoint $id$ of thread $t$ \\
  $\HALT^k_t$ & $\in \BVSORT[1]$ & halt flag of thread $t$ \\
  \lasthline
  \caption{State Variables}
  \label{tbl:states}
\end{longtabu}

\newpage

\newcommand{\READ}{\texttt{read}}
\newcommand{\WRITE}{\texttt{write}}

% Shared memory is modelled using the array variable $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$ for updating the element at $adr \in \BVSORT$ with a given value $val \in \BVSORT$ in step $k$.
% Shared memory in step $k$ is modelled using the array variable $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving an element and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$, returning an updated version of the shared memory state array with the given element set to a specific value.
Shared memory states are modelled using the array variables $\HEAP^k$ in combination with the functions $\READ^k \colon \BVSORT \mapsto \BVSORT$ for retrieving an element and $\WRITE^k \colon \BVSORT \times \BVSORT \mapsto \ASORT$ returning an updated version of the shared memory state array with the given element set to a specific value.
% Its initial state $\HEAP^0$ may contain input data according to a given memory map, but is assumed to be uninitialized in general.
Register states of a thread $t$ are determined by the bit-vector variables $\ACCU^k_t$, $\MEM^k_t$, $\SBADR^k_t$, $\SBVAL^k_t$ and the flag $\SBFULL^k_t$, signalling that the store buffer is full.
%, which are all initially set to zero.
% To aid solvers by reducing the formulas complexity, program flow is modelled without an explicit \CHANGE{program counter ``(PC)''}.
\CHANGE{To reduce the formula's complexity}, program flow is modelled without an explicit \CHANGE{program counter (``$pc$'')}.
Instead, an activation flag $\STMT^k_{t, pc}$ is added for every statement in the program of thread $t$, expressing that it is about to execute the statement at $pc$.
%To model the program flow without an explicit program counter, an activation flag $\STMT^k_{t, pc}$ is added for every statement in the program of thread $t$, expressing that it is about to execute the statement at $pc$.
Blocking a thread $t$ while it is waiting for all other threads to reach a checkpoint $id$ is achieved by a flag $\BLOCK^k_t$.
% Blocking a thread $t$ while waiting for all other threads to synchronize on a checkpoint $id$ is achieved by the $\BLOCK^k_{id, t}$ state flag.
Similarly, the flag $\HALT^k_t$ indicates that thread $t$ executed a \lstASM{HALT} instruction and is therefore also prevented from being scheduled.
% Termination due to an call to \texttt{EXIT}, or because all threads finished executing their programs, or \texttt{EXIT}  is captured by
Termination is captured by the flag $\EXIT^k$ and bit-vector variable $\EXITCODE^k$.

% The shared memory state array $\HEAP^0$ may be initialized with input data according to a given memory map, but is assumed to be uninitialized in general.
% All other states are initially set to zero, with the exception of the initial statement activation flag $\STMT^0_{t, 0}$ of every thread $t$.
All states are initially set to zero, except the initial statement activation flag $\STMT^0_{t, 0}$ of every thread $t$ and the shared memory state array $\HEAP^0$, which may be initialized with input data according to a given memory map, but is assumed to be uninitialized in general.

\bigskip

% Constraints for valid machine state transitions of the form $s_k \to^k s_{k + 1}$ are governed by the following variables.
Machine state transitions of the form $s_k \to^k s_{k + 1}$ are \CHANGE{encoded} by the following free variables.
% Machine state transitions of the form $s_k \to^k s_{k + 1}$ are governed by the free variables given in Table \ref{tbl:encoding:transitions}.
% Transitions $s_k \to^k s_{k + 1}$ of a state $s_k$ are governed by the following free variables and are allowed to be chosen non-deterministically.

\begin{longtabu}{llX}
  \firsthline
  $\THREAD^k_t$ & $\in \BVSORT[1]$ & thread $t$ is scheduled to execute an instruction in step $k$ \\
  $\FLUSH^k_t$ & $\in \BVSORT[1]$ & thread $t$ flushes its store buffer in step $k$ \\
  \lasthline
  \caption{Transition Variables}
  \label{tbl:encoding:transitions}
\end{longtabu}

% \todo[inline]{helper variables}
To simplify the definition of successor states, the following helper variables capture frequently used \CHANGE{conditions}.
% The following helper variables are introduced to simplify the latter definition of state transitions by capturing frequently used terms.

\begin{longtabu}{llX}
  \firsthline
  $\EXEC^k_{t, pc}$ & $\in \BVSORT[1]$ & thread $t$ is executing the statement at $pc$ in step $k$ \\
  $\CHECK^k_{id}$ & $\in \BVSORT[1]$ & all threads reached checkpoint $id$ in step $k$ \\
  \lasthline
  \caption{Helper Variables}
\end{longtabu}

% The statement execution variable $\EXEC^k_{t, pc}$,
The actual execution of a specific statement is encoded by $\EXEC^k_{t, pc}$ and
% The actual execution of a statement at $pc$ by thread $t$ in step $k$ is encoded by the execution variable $\EXEC^k_{t, pc}$ and
is defined as a conjunction of the corresponding statement and thread activation variables.

\[
  \EXEC^k_{t, pc} = \STMT^k_{t, pc} \land \THREAD^k_t
\]

\bigskip

Furthermore, we use $\CHECK^k_{id}$ to signal that all threads containing a call to checkpoint $id$ \CHANGE{(given in the set $C_{id} = \{ \, t \mid t \text{ contains \lstASM{CHECK} } id \, \}$)} have synchronized.% and the corresponding $\BLOCK^k_{id, t}$ flags set.
% from a set $C_{id}$ of threads containing a call to checkpoint $id$
\[
  \CHECK^k_{id} = \bigwedge_{t \in C_{id}} \BLOCK^k_{id, t}
\]

% \bigskip
\subsubsection*{Scheduling}

\newcommand{\CardLt}{\leq^1_n(x_1, \ldots, x_n)}
\newcommand{\CardLtSeq}{\text{LT}^{n, 1}_{\text{SEQ}}}

\newcommand{\ITE}{\texttt{ite}}
\newcommand{\ITEindent}{\;\;\;\;\;\;\;}

% Non-deterministic scheduling of a single thread per step is realized by a boolean cardinality constraint over all $\THREAD^k_t$ and $\FLUSH^k_t$ variables for a number of threads $n$.
Non-deterministic scheduling of at most one thread per step is realized by a boolean cardinality constraint over all transition variables and the exit flag $\EXIT^k$ to ensure satisfiability if the machine terminates in a step \CHANGE{$k < \BOUND$}.
Let $\CardLt$ be a predicate expressing that at most one out of $n$ variables is allowed to be true.
% The na\"{i}ve way of defining $\leq^1_n(x_1, \ldots, x_n)$ is by explicitly excluding all combinations of two variables being simultaneously true.
The intuitive way of encoding $\CardLt$ is by excluding all combinations of two variables being simultaneously true.
% The traditional way of defining such a constraint is by excluding all combinations of two variables being simultaneously true:
\[
  \bigwedge_{1 \leq i < j \leq n} (\neg x_i \lor \neg x_j)
\]
This na\"ive approach, however, consists of $\binom{n}{2}$ \CHANGE{binary} clauses.
% While this na\"ive approach consists of $\binom{n}{2}$ Horn clauses, a more compact formulation, based on a sequential counter circuit, is presented as $\text{LT}^{n, 1}_{\text{SEQ}}$ in \cite{ref:Sinz}.
A more compact formulation, based on a sequential counter circuit computing partial sums $s_i = \sum^i_{j = 1} x_j$ for increasing values of $i$ up to the final $i = n$, is presented as $\CardLtSeq$ in \cite{ref:Sinz} and defined as follows.
% It only requires $3n - 4$ clauses in contrast to the na\"ive approach
% It is based on a sequential counter circuit, only requiring $3n - 4$ clauses, but $n - 1$ additional auxiliary variables.
% Beside this na\"ive approach, consisting of $\binom{n}{2}$ Horn clauses, a more compact formulation with respect to the number of clauses is presented as $\text{LT}^{n, 1}_{\text{SEQ}}$ in \cite{ref:Sinz}.
% This approach consists of $\binom{n}{2}$ Horn clauses.
% consisting of $\binom{n}{2}$ Horn clauses.
% A more compact formulation in terms of the number of clauses, called , based on a sequential counter circuit, is  presented in \cite{ref:Sinz} as $\text{LT}^{n, 1}_{\text{SEQ}}$.
% Cardinality constraint predicate $\leq^1_n(x_1, \ldots, x_n)$ defined as:
\[
  (\neg x_1 \lor s_1) \land (\neg x_n \lor \neg s_{n-1}) \bigwedge_{1 < i < n} \big ( (\neg x_i \lor s_i) \land (\neg s_{i-1} \lor s_i) \land (\neg x_i \lor \neg s_{i-1}) \big )
\]
% $\CardLtSeq$ only requires $3n - 4$ Horn clauses and $n - 1$ additional auxiliary variables.
% It is therefore superior to the na\"ive encoding with regard to the number of clauses for all $n > 5$.
$\CardLtSeq$ is superior to the na\"ive encoding with regard to the number of clauses for all $n > 5$, as it only requires $3n - 4$ Horn clauses and $n - 1$ additional auxiliary variables.
% \todo[inline]{constraint selection}
% Since we need to include two times the number of threads plus one variables in the constraint, the actual definition of $\leq^1_n(x_1, \ldots, x_n)$ is therefore determined by the number of threads involved and the na\"ive encoding only used for up to two threads, $\CardLtSeq$ otherwise.
The actual definition of the at most one constraint predicate $\CardLt$ is therefore determined by the number of threads involved.
Since we have to include two times the number of threads plus one variables in the constraint, the na\"ive encoding is only used for up to two threads and $\CardLtSeq$ otherwise.
% \[
  % \leq^1_n(x_1, \ldots, x_n) \equiv
    % \begin{cases}
      % \CardLtSeq & \text{if } n > 5 \\
      % \text{na\"ive} & \text{otherwise}
    % \end{cases}
% \]
% \todo[inline]{exactly one constraint}
An at most one constraint alone is not sufficient, as we need exactly one transition variable or the exit flag to be true in every step.
\CHANGE{This is because} our generated formula \CHANGE{should} not \CHANGE{be} trivially satisfiable by never scheduling a single thread.
Thus, we define the exactly one constraint predicate $=^1_n\!(x_1, \ldots, x_n)$ by simply adding a disjunction over all variables.% to $\CardLt$.
% The required exactly one constraint predicate $=^1_n(x_1, \ldots, x_n)$ as a conjunction of $\leq^1_n(x_1, \ldots, x_n)$ with a disjunction over all variables
% Let $=^1_n(x_1, \ldots, x_n)$ therefore be an exactly one constraint predicate.
\[
  %=^1_n(x_1, \ldots, x_n) \equiv
  (x_1 \lor \ldots \lor x_n) \; \land \CardLt
  % \CardLt \land (x_1 \lor \ldots \lor x_n)
\]
% \todo[inline]{actual constraint added}
% If we now redeclare $n$ to be the number of threads, the exactly one constraint used for non-deterministic scheduling of a single thread in step $k$ looks as follows.
If we redeclare $n$ as the number of threads, non-deterministic scheduling of a single thread in step $k$ can now be encoded by the following constraint.
% We are now able to state the actual exactly one constraint added to our formula as follows.
\[
  =^1_{2n + 1}\!(\THREAD^k_0, \ldots, \THREAD^k_{n-1}, \FLUSH^k_0, \ldots, \FLUSH^k_{n-1}, \EXIT^k)
\]
% \todo[inline]{scheduling influenced by constraints}
% restrictions by our machine model.
% To comply with our machine model, the cardinality constraint influenced under certain conditions.
% The scheduling constraint is influenced by  certain transitions
% influenced by disabling transition variables under certain conditions.
% to comply with our machine model,
% This cardinality constraint is further influenced by explicitly disabling transitions from certain states in order to meet the requirements of our machine model.

This cardinality constraint is further influenced by explicitly disabling transitions from certain states that are prohibited by our machine model.
% \todo[inline]{store buffer constraints}
% Blocking a thread $t$ not performing a store operation.
% Flushing an empty store buffer of a thread $t$, not containing any barrier \todo{atomic?} operation, can be prevented by a simple implication.
Flushing an empty store buffer of a thread $t$ can be prevented by a simple \CHANGE{relational constraint}.
\[
  \FLUSH^k_t \implies \SBFULL^k_t
\]
% If thread $t$ contains a write together with a barrier operation, execution of the latter has to be restricted while the store is full.
In case thread $t$ containing a write, execution of any barrier operation has to be delayed while the store buffer is full.
% In this case, both mutually exclusive store buffer constraints are combined in a single expression by using
% Both store buffer constraints may be combined in a single expression by using $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$, a functional if-then-else, returning the $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$.
% If a write or barrier operation
% Otherwise,
Let $F_t$ be a set of statements requiring an empty store buffer
and $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$ be a functional if-then-else, returning $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$.
% Let $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$ be a functional if-then-else, returning $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else $b \in \BVSORT[n]$
\[
  \ITE(x, a, b) =
  \begin{cases}
    a \text{ if } x \text{ is } true \\
    b \text{ otherwise}
  \end{cases}
\]
% Blocking a thread $t$ about to execute a statement that requires the store buffer being empty.
% Set of statements requiring an empty store buffer $F_t$.
Since both store buffer related constraints mainly depend on mutually exclusive values of $\SBFULL^k_t$, we are able to encode them in a single expression.
\[
  \ITE(\SBFULL^k_t, ( \bigvee_{pc \in F_t} \STMT^k_{t, pc} \implies \lnot \THREAD^k_t \,), \lnot \FLUSH^k_t)
\]
% \todo[inline]{checkpoint constraints}
% Blocking a thread $t$, while it is waiting for all other threads reaching a checkpoint $id$ is expressed by a conjunction of the corresponding block flag $\BLOCK^k_{id, t}$ and helper variable $\CHECK^k_{id}$ implying a negated thread activation $\THREAD^k_t$.
Blocking a thread $t$, while it is waiting for all other threads reaching a checkpoint $id$ is implied by a conjunction of the corresponding block flag $\BLOCK^k_{id, t}$ and synchronization variable $\CHECK^k_{id}$.
% \todo[noline]{unsat if deadlock by CHECK}
\[
  \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id} \implies \lnot \THREAD^k_t
\]
% \todo[inline]{halt constraints}
% Finally, a halted thread $t$ is also excluded from the cardinality constraint by disabling its activation variable.% by a simple implication.
% If a thread $t$ has finally halted, it is also excluded from the cardinality constraint.
Finally, if a thread $t$ has halted, it must also be stopped from being scheduled.
\[
  \HALT^k_t \implies \lnot \THREAD^k_t
\]

\CHANGE{
% If any of these conditions are violated, this does not correspond to a valid execution.
The purpose of this conditions is to restrict transitions which do not correspond to a valid execution.
% Since these constraints are defined relationally, special care must be taken such that they do not result in an unsatisfiable formula due to a violation of the primary cardinality constraint.
Since these constraints are defined relationally, special care must be taken in order to prevent a violation of the cardinality constraint, causing the formula to be unsatisfiable if all included variables are falsified simultaneously.
% Considering the previously defined constraints, the only way this situation might occur is if every thread's store buffer is empty ($\lnot \SBFULL^k_t \implies \lnot \FLUSH^k_t$) and
% all threads that are still running have their block flags enabled in case all are waiting for different checkpoint,
% all running threads are waiting for a different checkpoint, causing a \emph{deadlock} i
% at least a single thread $t$ is still running in step $k$ ($\lnot \HALT^k_t \implies \lnot \EXIT^k$).
Considering the previously defined constraints, the only way this situation might occur is if a \emph{deadlock} is introduced by an unfortunate interleaving of different \lstASM{CHECK} instructions, resulting in each thread waiting for another.
% This problem, common for all synchronization primitives, leads to alternating block flags $\BLOCK^k_{t, id}$ being set, violating the conditions of corresponding synchronization variables $\CHECK^k_{id}$ and thread activation variables $\THREAD^k_t$ blocked by the associated constraint.
% In this case, alternating block flags $\BLOCK^k_{id, t}$ are enabled, falsifying the corresponding synchronization variables $\CHECK^k_{id}$ and every running thread's activation $\THREAD^k_t$ being explicitly disabled by the relevant checkpoint constraint.
% This leads to alternate block flags $\BLOCK^k_{id, t}$ being enabled, making it impossible to fulfill the condition of corresponding synchronization variables $\CHECK^k_{id, t}$.
% preventing the condition of corresponding synchronization variables $\CHECK^k_{id}$
% In this case, $\EXIT^k$ will be \emph{false} and since all running threads are prevented from being scheduled by having their activation variables $\THREAD^k_t$ disabled through each individual block state $\BLOCK^k_{t, id}$ being enabled, while none of the corresponding sync
% Let $T$ be the set of threads involved and $C$ the set of checkpoint IDs, then the condition (state) causing the formula to be unsatisfiable can be summarized as follows.
% In this case, let $T$ be the set of threads involved and $C$ the set of checkpoint IDs, then the condition causing
% the scheduling constraints to be violated
% the formula to be unsatisfiable
Let $T$ be the set of threads involved and $C$ the set of checkpoint IDs, then the condition causing unsatisfiability can be summarized as follows.
% \[
  % \exists \, k \leq \BOUND, \forall \, t \in T \,[\, \lnot \SBFULL^k_t \land \lnot \HALT^k_t \land \exists \, id \in C \,[\, \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id} \,]]
% \]
% \[
  % \exists \, k \leq \BOUND : \lnot \EXIT^k \land \forall \, t \in T : \lnot \SBFULL^k_t \land \lnot \HALT^k_t \land \exists \, id \in C : \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id}
% \]
% \begin{align*}
  % & \lnot \EXIT^k \\
  % & \land \exists \, k \leq \BOUND : \forall \, t \in T : \lnot \SBFULL^k_t \land \lnot \HALT^k_t \\
  % & \land \exists \, id \in C : \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id}
% \end{align*}
\begin{equation*}
  \begin{gathered}
  \exists \, k \leq \BOUND : \lnot \EXIT^k \\
  \land \\
  \forall \, t \in T : \lnot \SBFULL^k_t \land \lnot \HALT^k_t \\
  \land \\
  \exists \, id \in C : \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id}
  \end{gathered}
\end{equation*}
% \[
  % \lnot \SBFULL^k_t \land \lnot \HALT^k_t \land \BLOCK^k_{id, t} \land \lnot \CHECK^k_{id} \implies \lnot \EXIT^k \land \lnot \FLUSH^k_t \land \lnot \THREAD^k_t
% \]
}

\subsubsection*{Memory Access}

% \newcommand{\READ}{\texttt{read}}
\newcommand{\LOAD}{\texttt{load}}

% Let $\READ^k: \BVSORT \to \BVSORT$ be a function, returning a given element from array $\HEAP^k$.
% Due to store forwarding in combination with indirect addressing, memory access can not be expressed by simple array lookups, but turns out to be the most complicated part in our encoding scheme.
Due store forwarding, memory access can not be expressed as simple array lookup, but is encoded by a separate function $\LOAD^k_t: \BVSORT \to \BVSORT$ for loading the shared memory element at address $adr \in \BVSORT$ with store forwarding from thread $t$. % and indirect addressing signalled by $indirect \in \BVSORT[1]$, being defined as follows.
\begin{align*}
  \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t \land \SBADR^k_t = adr, \\
  & \SBVAL^k_t, \\
  & \READ^k(adr))
\end{align*}
In case of indirect addressing, $\LOAD^k_t$ is redefined to prevent dependency on certain features of the target language or the use of additional auxiliary variables.
% \todo[noline]{repeated, iterative, recursive?}
\begin{align}
  \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t, \label{def:load:1} \\
  & \ITE(\SBADR^k_t = adr, \label{def:load:2} \\
  & \ITEindent \ITE(\SBVAL^k_t = adr, \label{def:load:3} \\
  & \ITEindent \ITEindent \SBVAL^k_t, \label{def:load:4} \\
  & \ITEindent \ITEindent \READ^k(\SBVAL^k_t)), \label{def:load:5} \\
  & \ITEindent \ITE(\SBADR^k_t = \READ^k(adr), \label{def:load:6} \\
  & \ITEindent \ITEindent \SBVAL^k_t, \label{def:load:7}\\
  & \ITEindent \ITEindent \READ^k(\READ^k(adr)))), \label{def:load:8} \\
  & \READ^k(\READ^k(adr))) \label{def:load:9}
\end{align}
% \todo[noline]{use tabbing evironment?}
First, we check if the store buffer contains an entry and store forwarding might apply (\ref{def:load:1}).
%, or the requested value can be directly retrieved from memory (\ref{def:load:9}).
If it is empty, the requested value has to be directly retrieved from memory (\ref{def:load:9}).
% Otherwise, if the immediate address can be forwarded (\ref{def:load:2}), we must further check if it is equal to the effective address (\ref{def:load:3}) and either both (\ref{def:load:4}), or just the immediate address is forwarded (\ref{def:load:5}).
Otherwise, if the store buffer contains an entry for the given address (\ref{def:load:2}), we must further check if it is equal to the effective address (\ref{def:load:3}) to determine if either both (\ref{def:load:4}), or just the given address can be forwarded (\ref{def:load:5}).
% Otherwise, if the store buffer contains an entry for the immediate address (\ref{def:load:2}), we check if it is equal to the effective address (\ref{def:load:3}) and either return the store buffer value (\ref{def:load:4}) or the element at
% Otherwise, if the store buffer contains an entry for the immediate address (\ref{def:load:2}) and
% Finally, in case the given address could not be forwarded, the store buffer might contain an entry
% Finally, in case the given address was not contained,
Finally, in case there is no entry for the given address,
%we test if and either the effective address can be forwarded (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
the effective address is fetched from memory and compared to the store buffer address (\ref{def:load:6}) to see if it
% can be forwarded (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
% might be subject to store forwarding (\ref{def:load:7}), or nothing after all (\ref{def:load:8}).
might be contained (\ref{def:load:7}), or nothing can be forwarded after all (\ref{def:load:8}).
% fetch the effective address from memory and
% or nothing after all.
% and nothing could be forwarded after all.
% If the immediate address cannot be forwarded,

% If store forwaring does not apply because either the store buffer being empty or it neither contains the immediate nor the effective address,
% In case of indirect addressing, we first need to check if the store buffer is full (\ref{def:load:indirect:sbfull}) and the given base address can be forwarded (\ref{def:load:indirect:sbadr}).
% If a value for the base address is contained in the store buffer, we then check if this value

% \begin{align}
  % \LOAD^k_t(adr, indirect) = \ITE(& indirect, \\
  % & \ITE(\SBFULL^k_t, \label{def:load:sbfull} \\
  % & \ITEindent \ITE(\SBADR^k_t = adr, \label{def:load:indirect:sbadr} \\
  % & \ITEindent \ITEindent \ITE(\SBVAL^k_t = adr, \\
  % & \ITEindent \ITEindent \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \ITEindent \ITEindent \READ^k(\SBVAL^k_t)), \\
  % & \ITEindent \ITEindent \ITE(\SBADR^k_t = \READ^k(adr), \\
  % & \ITEindent \ITEindent \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \ITEindent \ITEindent \READ^k(\READ^k(adr)))), \\
  % & \ITEindent \READ^k(\READ^k(adr))), \\
  % & \ITE(\SBFULL^k_t \land \SBADR^k_t = adr, \\
  % & \ITEindent \SBVAL^k_t, \\
  % & \ITEindent \READ^k(adr)))
% \end{align}

% \begin{itemize}
  % \item Nested array lookups if the store buffer is empty and store forwarding does not apply alltogether, or neither the indirect, nor the effective address can be forwarded.
  % \item The value contained in the store buffer if either the effective or both addresses can be forwarded.
% \end{itemize}

% store buffer empty: nested lookup

% \begin{enumerate}
  % \item nothing can be forwarded
  % \item only the indirect address can be forwarded
  % \item only the effective address can be forwarded
  % \item both addresses can be forwarded
% \end{enumerate}

% \[
  % \LOAD^k_t(adr) = \ITE(& \SBFULL^k_t \land \SBADR^k_t = adr, \SBVAL^k_t, \READ^k(adr)))
% \]

% \ref{def:load:sbfull}

% \paragraph{Store Forwarding:} $\sbfull \; \land \; \sbadr = adr \land \accu = \sbval \lor \lnot (\sbfull \land \sbadr = adr)$

% \bigskip

\subsubsection*{Frame Axioms}

\newcommand{\TRUE}{\textit{true}}
\newcommand{\FALSE}{\textit{false}}

\newcommand{\EFFECTIVE}{\texttt{effective}}
\newcommand{\MSB}{\texttt{msb}}

% The effect of a particular operation, determined by the transition variables $\FLUSH^k_t$ and $\EXEC^k_{t, pc}$
% The effect of a thread $t$ flushing its store buffer or executing the instruction at $pc$ in step $k$
Successor states of transitions for all possible types of operations, determined by $\FLUSH^k_t$ and $\EXEC^k_{t, pc}$, are defined by the frame axioms in the table below.
% \todo[inline]{block}
All state variables, not explicitly altered are assumed to be unchanged in the next step, except the block flags $\BLOCK^{k + 1}_{id, t}$, which are reset if all threads synchronized upon checkpoint $id$.
\[
  \BLOCK^{k + 1}_{id, t} = \ITE(\CHECK^k_{id}, \FALSE, \BLOCK^k_{id, t})
\]
To further simplify the definition of axioms, two additional functions are introduced:
% Let $\EFFECTIVE^k: \BVSORT \to \BVSORT$ be a function for transparently selecting the effective address during $\texttt{STORE}$ or $\texttt{CAS}$ instructions.
$\MSB: \BVSORT \to \BVSORT[1]$ for retrieving the most significant bit of a given bit-vector and $\EFFECTIVE^k: \BVSORT \to \BVSORT$ for transparently selecting the effective address during \lstASM{STORE} or \lstASM{CAS} instructions.
\vspace{-0.1cm}
\[
  \EFFECTIVE^k(adr) =
  \begin{cases}
    \READ^k(adr) \text{ if indirect} \\
    adr \text{ otherwise}
  \end{cases}
\]
% and $\MSB: \BVSORT \to \BVSORT[1]$ a function for retrieving the most significant bit of a given bit-vector.

% $\SLICE: \BVSORT \times \mathcal{N} \times \mathcal{N} \to \BVSORT[m]$

% \newcommand{\defaxiom}[1]{
    % \vspace{-0.4cm}
    % {\begin{align*}#1\end{align*}}
    % \vspace{-1.3cm}
% }
% \begin{longtabu}{lX[lm]}
  % \firsthline
    % \texttt{FLUSH} &
    % \vspace{-0.4cm}
    % {\begin{align*}
      % \HEAP^{k + 1} &= \WRITE^k(\SBADR^k_t, \SBVAL^k_t) \\
      % \SBFULL^{k + 1}_t &= false \\
    % \end{align*}}
    % \vspace{-1.3cm}
    % \\
  % \hline
  % \texttt{LOAD adr} &
    % \defaxiom{
      % \ACCU^{k + 1}_t &= \LOAD^k_t(\texttt{adr}) \\
      % \STMT^k_{t, pc} &= false \\
      % \STMT^k_{t, pc + 1} &= true \\
    % } \\
  % \hline
  % foo & bar \\
  % \lasthline
  % \caption{Frame Axioms}
  % \label{tbl:axioms}
% \end{longtabu}

% \doublerulesep=6pt
% \arrayrulewidth=1pt
% \doublerulesep=1.5 pt
% \everyrow{\hline\hline}

% \newcommand{\defaxiom}[2]{
  % \paragraph{#1} ~\\
  % \rule[0.5\baselineskip]{\textwidth}{0.1pt}\vspace{-1\baselineskip}\par\noindent
  % #2
% }

% \newpage
% \defaxiom
% {\texttt{FLUSH}}
% {
  % \begin{itemize}
    % \item[] $\HEAP^{k + 1} = \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$
    % \item[] $\SBFULL^{k + 1} = false$
  % \end{itemize}
% }

% \defaxiom
% {\texttt{LOAD arg}}
% {
  % \begin{itemize}
    % \item[] $\ACCU^{k + 1}_t = \LOAD^k_t(\texttt{adr})$
    % \item[] $\STMT^k_{t, pc} = false$
    % \item[] $\STMT^k_{t, pc + 1} = true$
  % \end{itemize}
% }

% \defaxiom
% {\texttt{STORE arg}}
% {
  % \begin{itemize}
    % \item[] $\SBADR^{k + 1}_t =
      % \begin{cases}
        % \READ^k(adr) \text{ if indirect} \\
        % adr \text{ otherwise}
      % \end{cases}$
    % \item[] $\SBVAL^{k + 1}_t = \ACCU^k_t$
    % \item[] $\STMT^k_{t, pc} = false$
    % \item[] $\STMT^k_{t, pc + 1} = true$
  % \end{itemize}
% }

% \newsavebox{\STORESBADRAXIOM}
% \savebox{\STORESBADRAXIOM}{
  % \hspace{-0.3cm}
  % $\begin{cases}
    % \READ^k(adr) \text{ if indirect} \\
    % adr \text{ otherwise}
  % \end{cases}$
% }

\newsavebox{\CASHEAPAXIOM}
\savebox{\CASHEAPAXIOM}{
  \hspace{-0.3cm}
  % $\begin{cases}
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
      % & \WRITE^k(\READ^k(\texttt{arg}), \ACCU^k_t), \\
      % & \HEAP^k)
    % \end{aligned}
    % \hspace{0.2cm}
    % \text{if indirect} \\
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
      % & \WRITE^k(\texttt{arg}, \ACCU^k_t), \\
      % & \HEAP^k)
    % \end{aligned}
    % \hspace{1.5cm}
    % \text{otherwise}
  % \end{cases}$
  $\begin{aligned}
    \ITE(& \MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), \\
    & \WRITE^k(\EFFECTIVE^k(\texttt{arg}), \ACCU^k_t), \\
    & \HEAP^k)
  \end{aligned}$
}

\newsavebox{\CASACCUAXIOM}
\savebox{\CASACCUAXIOM}{
  \hspace{-0.3cm}
  % $\begin{cases}
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
      % & 1, \\
      % & 0)
    % \end{aligned}
    % % \ITE(\MEM^k_t = \READ^k(\READ^k(\texttt{arg})), 1, 0)
    % \hspace{0.2cm}
    % \text{if indirect} \\
    % \begin{aligned}
      % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
      % & 1, \\
      % & 0) \\
    % \end{aligned}
    % % \ITE(\MEM^k_t = \READ^k(\texttt{arg}), 1, 0)
    % \hspace{1.5cm}
    % \text{otherwise}
  % \end{cases}$
  % $\begin{aligned}
    % \ITE(& \MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), \\
    % & 1, \\
    % & 0)
  % \end{aligned}$
  $\ITE(\MEM^k_t = \READ^k(\EFFECTIVE^k(\texttt{arg})), 1, 0)$
}

% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\mybox} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
    % \lasthline
% \end{longtabu}

% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2}{*}{\texttt{FLUSH}}
    % & $\HEAP^{k + 1}$       & $= \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$ \\
    % & $\SBFULL^{k + 1}$     & $= false$ \\
  % \lasthline
% \end{longtabu}
% \vspace{-0.9cm}
% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{3}{*}{\texttt{LOAD adr}}
    % & $\ACCU^{k + 1}_t$     & $= \LOAD^k_t(\texttt{adr})$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  % \lasthline
% \end{longtabu}
% \vspace{-0.9cm}
% \begin{longtabu}{llX[m]}
  % \firsthline
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\mybox} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  % \lasthline
% \end{longtabu}

% \setlength{\tabulinesep}{2pt}
% \setlength{\doublerulesep}{4pt}
\begin{longtabu}{llX[m]}
  \firsthline
  \multirow{2}{*}{\lstASM{FLUSH}}
    & $\HEAP^{k + 1}$   & $= \WRITE^k(\SBADR^k_t, \SBVAL^k_t)$ \\
    & $\SBFULL^{k + 1}$ & $= \FALSE$ \\
  \hline
  % \hhline{===}
  % \tabucline[2pt off 2pt]{-}
  \multirow{3.05}{*}{\lstASM{LOAD arg}}
    & $\ACCU^{k + 1}_t$           & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \hhline{===}
  % \multirow{2.5}{*}{\texttt{STORE adr}}
    % & $\SBADR^{k + 1}_t$    & $=$ \usebox{\STORESBADRAXIOM} \\
    % & $\SBVAL^{k + 1}_t$    & $= \ACCU^k_t$ \\
    % & $\STMT^k_{t, pc}$     & $= false$ \\
    % & $\STMT^k_{t, pc + 1}$ & $= true$ \\
  \multirow{4}{*}{\lstASM{STORE arg}}
    & $\SBADR^{k + 1}_t$          & $= \EFFECTIVE^k(\texttt{arg})$ \\
    & $\SBVAL^{k + 1}_t$          & $= \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \hhline{===}
  \multirow{2}{*}{\lstASM{FENCE}}
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\lstASM{ADD arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t + \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\lstASM{ADDI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t + \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \newpage
  \hline
  \multirow{3.05}{*}{\lstASM{SUB arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\lstASM{SUBI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\lstASM{MUL arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t * \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3.05}{*}{\lstASM{MULI arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t * \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{3}{*}{\lstASM{CMP arg}}
    & $\ACCU^{k + 1}_t$           & $= \ACCU^k_t - \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{2}{*}{\lstASM{JMP arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \TRUE)}$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \CHANGE{\ITE(pc \neq arg, \TRUE, \FALSE)}$ \\
  \hline
  \multirow{3}{*}{\lstASM{JZ arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \lnot \ACCU^k_t)}$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \lnot \ACCU^k_t$ \\
  \hline
  \multirow{3}{*}{\lstASM{JNZ arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \ACCU^k_t)}$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \ACCU^k_t$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \ACCU^k_t$ \\
  \hline
  \multirow{3}{*}{\lstASM{JS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \MSB(\ACCU^k_t))}$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \MSB(\ACCU^k_t)$ \\
  \hline
  \newpage
  \hline
  \multirow{3}{*}{\lstASM{JNS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \lnot \MSB(\ACCU^k_t))}$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \lnot \MSB(\ACCU^k_t)$ \\
  \hline
  \multirow{3}{*}{\lstASM{JNZNS arg}}
    & $\STMT^{k + 1}_{t, pc}$           & $= \CHANGE{\ITE(pc \neq arg, \FALSE, \ACCU^k_t \land \lnot \MSB(\ACCU^k_t))}$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$       & $= \lnot \ACCU^k_t \lor \MSB(\ACCU^k_t)$ \\
    & $\STMT^{k + 1}_{t, \texttt{arg}}$ & $= \ACCU^k_t \land \lnot \MSB(\ACCU^k_t)$ \\
  \hline
  \multirow{4}{*}{\lstASM{MEM arg}}
    & $\ACCU^{k + 1}_t$           & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\MEM^{k + 1}_t$            & $= \LOAD^k_t(\texttt{arg})$ \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + k}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  % \multirow{2.35}{*}{\texttt{CAS arg}}
  \multirow{2.97}{*}{\lstASM{CAS arg}}
    & $\HEAP^{k + 1}$             & $=$ \usebox{\CASHEAPAXIOM} \\
    & $\ACCU^{k + 1}_t$           & $=$ \usebox{\CASACCUAXIOM} \\
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
  \hline
  \multirow{2}{*}{\lstASM{HALT}}
    % & $\EXIT^{k + 1}_t$ & $= \HALT^{k + 1}_0 \land \ldots \land \HALT^{k + 1}_{n - 1}$ \\
    & $\EXIT^{k + 1}_t$       & $= \displaystyle \bigwedge^{n - 1}_{i = 0} \HALT^{k + 1}_i$ \\
    & $\HALT^{k + 1}_t$       & $= \TRUE$ \\
    & $\STMT^{k + 1}_{t, pc}$ & $= \FALSE$ \\
  \hline
  \multirow{3}{*}{\lstASM{EXIT arg}}
    & $\EXIT^{k + 1}_t$       & $= \TRUE$ \\
    & $\EXITCODE^k$           & \vspace{.15cm} $= \texttt{arg}$ \\
    & $\STMT^{k + 1}_{t, pc}$ & $= \FALSE$ \\
  \hline
  \multirow{3}{*}{\lstASM{CHECK arg}}
    & $\STMT^{k + 1}_{t, pc}$     & $= \FALSE$ \\
    & $\STMT^{k + 1}_{t, pc + 1}$ & $= \TRUE$ \\
    & $\BLOCK^{k + 1}_{arg, t}$   & $= \TRUE$ \\
  \lasthline
  \caption{Frame Axioms}
  \label{tbl:axioms}
\end{longtabu}

% \vspace{0.2cm}
% \hlinE
% \VSPACE{0.1CM}
% \NOINDENT
% \BEGIN{TABU} TO \TEXTWIDTH {Lx[M]}
  % $\heap^{K + 1}$       & $= \write^K(\sbadr^K_T, \sbval^K_T)$ \\
  % $\sbfull^{K + 1}$     & $= FALSE$ \\
% \END{TABU}

% \PARAGRAPH{\TEXTTT{flush}}

% \VSPACE{0.2CM}
% \HLINE
% \VSPACE{0.1CM}
% \NOINDENT
% \BEGIN{TABU} TO \TEXTWIDTH {Lx[M]}
  % $\heap^{K + 1}$       & $= \write^K(\sbadr^K_T, \sbval^K_T)$ \\
  % $\sbfull^{K + 1}$     & $= FALSE$ \\
% \END{TABU}

% \[
% \texttt{compare}^k_t(adr) =
% \begin{cases}
  % \MEM^k_t = \READ^k(\READ^k(adr)) \text{ if indirect} \\
  % \MEM^k_t = \READ^k(adr) \text{ otherwise}
% \end{cases}
% \]

% $\HEAP^{k + 1} =
% \begin{cases}
  % \begin{aligned}
    % \ITE(& \MEM^k_t = \READ^k(\READ^k(\texttt{arg})), \\
    % & \WRITE^k(\READ^k(\texttt{arg}), \ACCU^k_t) \\
    % & \HEAP^k)
  % \end{aligned}
  % \text{ if indirect} \\
  % \begin{aligned}
    % \ITE(& \MEM^k_t = \READ^k(\texttt{arg}), \\
    % & \WRITE^k(\texttt{arg}, \ACCU^k_t) \\
    % & \HEAP^k)
  % \end{aligned}
  % \text{ otherwise}
% \end{cases}$

% Let $\texttt{define-accu}(k, t, pc)$ be the predicate defining the accumulator register state $\ACCU^k_t$ of thread $t$ in step $k$ and $pc$ the set of program counters, altering that state.% \todonote{refine}

% \paragraph{\texttt{LOAD adr}}

% \subsubsection{Statement Activation}

% \setlength{\tabulinesep}{2\lineskip}
