\section{Verification}

\todo{intro
  \begin{itemize}
    \item submodule \texttt{solve}
    \item verification of assembly programs by bounded model checking based on register states
    \item using satisfiability modulo theories (arrays and bitvectors)
    \item problem defined by state and transition variables
  \end{itemize}
}

\todo{states
  \begin{itemize}
    \item $\ACCU^k_t$ - accumulator of thread $t$
    \item mem
    \item sb-adr
    \item sb-val
    \item sb-full
    \item stmt
    \item block
    \item halt
    \item heap
    \item exit-flag
    \item exit-code
  \end{itemize}
}

\newpage

The following variables are used to encode the machine's state at a particular step $k \in [0, bound] \subset \mathbb{N}$, where $k = 0$ is the machine's initial state.

\cite{btor2}

Let $\BVSORT[n]$ be the fixed size bitvector sort of width $n$ and $\ASORT[n]$ the array sort with index and element sorts $\BVSORT[n]$.

\renewcommand{\arraystretch}{1.25}
\begin{table}[h!]
\begin{tabular}{lll}
  \hline
  \textbf{global} &&\\
  \hline
  $\HEAP^k$ & $\ASORT$ & shared memory state in step $k$ \\
  $\EXIT^k$ & $\BVSORT[1]$ & exit flag in step $k$ \\
  $\EXITCODE^k$ & $\BVSORT$ & exit code in step $k$ \\
  \hline
  \textbf{local} &&\\
  \hline
  $\ACCU^k_t$ & $\BVSORT$ & accumulator register state of thread $t$ in step $k$ \\
  $\MEM^k_t$ & $\BVSORT$ & CAS memory register state of thread $t$ in step $k$ \\
  $\SBADR^k_t$ & $\BVSORT$ & store buffer address register of thread $t$ in step $k$ \\
  $\SBVAL^k_t$ & $\BVSORT$ & store buffer value register of thread $t$ in step $k$ \\
  $\SBFULL^k_t$ & $\BVSORT[1]$ & store buffer full flag of thread $t$ in step $k$ \\
  $\STMT^k_{t, pc}$ & $\BVSORT[1]$ & statement activation for $pc$ of thread $t$ in step $k$ \\
  $\BLOCK^k_{t, id}$ & $\BVSORT[1]$ & block flag for checkpoint $id$ of thread $t$ in step $k$ \\
  $\HALT^k_t$ & $\BVSORT[1]$ & halt flag of thread $t$ in step $k$ \\
  \hline
\end{tabular}
\caption{State Variables}
\end{table}

\todo{transitions
  \begin{itemize}
    \item thread
    \item flush
    \item check
  \end{itemize}
}

\begin{table}[h!]
\begin{tabular}{lll}
  \hline
  $\THREAD^k_t$ & $\BVSORT$ & accumulator register state of thread $t$ in step $k$ \\
  $\MEM^k_t$ & $\BVSORT$ & CAS memory register state of thread $t$ in step $k$ \\
  $\SBADR^k_t$ & $\BVSORT$ & store buffer address register of thread $t$ in step $k$ \\
  $\SBVAL^k_t$ & $\BVSORT$ & store buffer value register of thread $t$ in step $k$ \\
  $\SBFULL^k_t$ & $\BVSORT[1]$ & store buffer full flag of thread $t$ in step $k$ \\
  $\STMT^k_{t, pc}$ & $\BVSORT[1]$ & statement activation for $pc$ of thread $t$ in step $k$ \\
  $\BLOCK^k_{t, id}$ & $\BVSORT[1]$ & block flag for checkpoint $id$ of thread $t$ in step $k$ \\
  $\HALT^k_t$ & $\BVSORT[1]$ & halt flag of thread $t$ in step $k$ \\
  \hline
\end{tabular}
\caption{State Variables}
\end{table}

\todo{memory access
  \begin{itemize}
    \item $load$ predicate
  \end{itemize}
}

\newcommand{\ITE}{\texttt{ite}}
\newcommand{\ITEindent}{\;\;\;\;\;\;\;}

Let $\ITE: \BVSORT[1] \times \BVSORT[n] \times \BVSORT[n] \to \BVSORT[n]$ be a functional if-then-else, returning the value $a \in \BVSORT[n]$ if $x \in \BVSORT[1]$ is \emph{true}, else the value $b \in \BVSORT[n]$.
\[
  \ITE(x, a, b) =
  \begin{cases}
    a \text{ if } x \text{ is } true \\
    b \text{ otherwise}
  \end{cases}
\]

\newcommand{\READ}{\texttt{read}}

Let $\READ^k: \BVSORT \to \BVSORT$ be the function returning the shared memory element at index $adr \in \BVSORT$ from array $\HEAP^k \in \ASORT$.

~\\

\newcommand{\LOAD}{\texttt{load}}

Let $\LOAD^k_t: \BVSORT \times \BVSORT[1] \to \BVSORT$ be the function for loading a particular shared memory element $e \in \BVSORT$ with index $i \in \BVSORT$ from array $a \in \ASORT$ and the indirection flag $indirect \in \BVSORT[1]$, defined as follows.
\begin{align}
  \LOAD^k_t(adr, indirect) = \ITE(& indirect, \\
  & \ITE(\SBFULL^k_t, \label{def:load:sbfull} \\
  & \ITEindent \ITE(\SBADR^k_t = adr, \\
  & \ITEindent \ITEindent \ITE(\SBVAL^k_t = adr, \\
  & \ITEindent \ITEindent \ITEindent \SBVAL^k_t, \\
  & \ITEindent \ITEindent \ITEindent \READ^k(\SBVAL^k_t)), \\
  & \ITEindent \ITEindent \ITE(\SBADR^k_t = \READ^k(adr), \\
  & \ITEindent \ITEindent \ITEindent \SBVAL^k_t, \\
  & \ITEindent \ITEindent \ITEindent \READ^k(\READ^k(adr)))), \\
  & \ITEindent \READ^k(\READ^k(adr))), \\
  & \ITE(\SBFULL^k_t \land \SBADR^k_t = adr, \\
  & \ITEindent \SBVAL^k_t, \\
  & \ITEindent \READ^k(adr)))
\end{align}

\ref{def:load:sbfull}

% \paragraph{Store Forwarding:} $\sbfull \; \land \; \sbadr = adr \land \accu = \sbval \lor \lnot (\sbfull \land \sbadr = adr)$

\todo{frame axioms
  \begin{itemize}
    \item instructions
    \item Programs: $\{p_1, \ldots, p_n\} \in \mathcal{P}^n$
    \item \texttt{ADDI val}
      \[
        \ACCU^{k + 1}_t = \ACCU^k_t + \texttt{val}
      \]
    \item \texttt{ADD adr}
      \[
        \ACCU^{k + 1}_t = \ACCU^k_t + \LOAD^k_t(adr, false)
      \]
    \item \texttt{ADD [adr]}
      \[
        \ACCU^{k + 1}_t = \ACCU^k_t + \LOAD^k_t(adr, true)
      \]
  \end{itemize}
}

\paragraph{\texttt{LOAD adr}}

\todo{constraints}
