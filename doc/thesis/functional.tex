\section{Functional Next State Logic}

% \todo[inline]{define states (functional)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\CHANGE{
In principle there are two ways to encode state updates: a functional, relying on \lstCPP{ite} cascades to perform \emph{static single assignments} for determining the successor of each state explicitly and a relational, based on implying the next state for each possible transition.
While the relational version is easier to encode since it is closer to our model's semantics and results in a simpler structure, the functional encoding has the benefit of being more compact and also turned out to be more efficient for SMT solving. % due to its strictly hierarchical nature.
% , which can be radically simplified by clever term rewriting due to its strictly hierarchical nature. %structure.
}%
% deterministically
% functional encoding scheme, static single assignment to determine the successor of each state individually
% functional encoding scheme, based on static single assignments for determining the successor of each state individually.
% We will now introduce the main state update scheme according to our model's frame axioms, generated using the \texttt{-e smtlib} command line parameter.
We will now introduce our \CHANGE{functional} state update scheme, generated by using the \mbox{\texttt{-e smtlib}} command line parameter.
% This functional encoding relies on \lstCPP{ite} cascades to perform \emph{static single assignments} for determining the successor of each state individually and aids the solver by simplifying the deduction process.
% relying on \lstCPP{ite} cascades to perform \emph{static single assignments} for determining the successor of each state explicitly in a functional manner.% and aids the solver by simplifying the deduction process.
% in order to aid the solver by simplifying the deduction process and minimizing the size of the generated formula.

\begin{lstlisting}[style=c++]
void define_states (uint k)
{
  define_accu(k);
  define_mem(k);
  define_adr(k);
  define_val(k);
  define_full(k);
  define_stmt(k);
  define_block(k);
  define_halt(k);
  define_heap(k);
  define_exit(k);

  if (k == bound)
    define_exit_code();
}
\end{lstlisting}

% \todo[inline]{define accu} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% \begin{itemize}
  % \item recursively
  % \item starts with base case of preserving its value
  % \item for each statement altering $\ACCU^k_t$
% \end{itemize}
% starting with the preservation of it's previous state $\ACCU^{k - 1}_t$, the
% starting with the base case of preserving it's previous state $\ACCU^{k - 1}_t$, the
% State update expressions for every thread's accumulator register $\ACCU^k_t$ are initialized with the predecessor $\ACCU^{k - 1}_t$
% Starting with the accumulator registers $\ACCU^k_t$, each update expression is generated by adding an \lstCPP{ite} for every program statement altering the accumulator
% Starting with the accumulator registers $\ACCU^k_t$, each thread's update expression is initialized with it's predecessor $\ACCU^{k - 1}_t$, forming the base case of preserving the previous state.
% Each program statement altering the accumulator then adds an \lstCPP{ite}, returning the successor generated by the \lstinline[style=c++, basicstyle=\normalsize\ttfamily]{Instruction::encode(uint, uint, State)} function
% Starting with the accumulator registers $\ACCU^k_t$, each thread's update expression is built by introducing an \lstCPP{ite} for every program statement altering the accumulator, returning the corresponding successor according to the previously defined implementations of \lstinline[style=c++, basicstyle=\normalsize\ttfamily]{Instruction::encode(uint, uint, State)}.
% Starting with the base case of preserving the previous value, each accumulator register's state update expression is initialized with it's predecessor $\ACCU^{k - 1}_t$.
% Every program statement altering the accumulator then adds an \lstCPP{ite}, returning the according successor state depending on it's execution given by the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ and...
% >>>
% Starting with the accumulator registers $\ACCU^k_t$, each update expression is initialized with it's predecessor $\ACCU^{k - 1}_t$, forming the base case of preserving the previous state.
% >>>
% Every program statement altering the accumulator then adds an \lstCPP{ite} for choosing the successor given by the instruction's \lstinline[style=c++, basicstyle=\normalsize\ttfamily]{Instruction::encode(uint, uint, State)} depending on the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$,   , embedding the current update expression in the \emph{else} branch.
% >>>
% We then add an \lstCPP{ite} for every program statement altering the accumulator to choose the successor state depending on the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ %, given by the instruction's \lstinline[style=c++, basicstyle=\normalsize\ttfamily]{Instruction::encode(uint, uint, State)}
% , utilizing the \lstCPP{Instruction} class's dynamic dispatch mechanism
% and embedding the current update expression in the \emph{else} branch as a fall back in case the statement has not been executed.
% >>>
% ~\\
% ~\\
% $\ACCU^{k - 1}_t$
Starting with the accumulator registers $\ACCU^k_t$, each update expression is initialized with its predecessor $\ACCU^{k - 1}_t$, forming the base case of preserving the previous state.
% The final expression assigned to $\ACCU^k_t$ is then built by adding an $\ITE$ for every program statement altering the accumulator, choosing the successor state depending on the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$.
% >>>
% Starting with the accumulator registers $\ACCU^k_t$, each update expression is initialized with it's predecessor to preserve the previous state.
% Any program statement altering the accumulator then embeds the expression's current value in the \emph{else} branch of an $\ITE$ setting the successor state by encoding the corresponding instruction, depending on the execution variable $\EXEC^{k - 1}_{t, pc}$.
% Any program statement altering the accumulator then extends the update expression by embedding it's current value in the \emph{else} branch of an $\ITE$, setting the successor state according to the encoded instruction, depending on the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$.
% Any program statement altering the accumulator then extends the expression by embedding it's current value in the \emph{else} branch of an $\ITE$, using the \lstCPP{encode} implementation of the corresponding instruction to set the successor state depending on the execution variable $\EXEC^{k - 1}_{t, pc}$.
Any program statement altering the accumulator then extends the expression by embedding its current value in the \emph{else} branch of an $\ITE$, using the corresponding instruction's \lstCPP{encode} implementation to set the successor state
depending on the
% according to it's
execution variable $\EXEC^{k - 1}_{t, pc}$.
% execution signalled by $\EXEC^{k - 1}_{t, pc}$.
% in case it has been executed signalled by $\EXEC^{k - 1}_{t, pc}$.
% in case of it's execution signalled by $\EXEC^{k - 1}_{t, pc}$.
% >>>
% To increase readability of the generated \SMTLIB expressions, we use a reverse iterator to create the $\ite$ cascade in program order.

% \begin{lstlisting}[style=c++]
% void define_accu (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % {
      % std::string expr = accu_var(k - 1, t);
      % const auto & stmts = updates[State::accu][t];
      % for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        % expr = ite(exec_var(k - 1, t, *pc),
                   % program[t][*pc]->encode(k - 1, t, State::accu),
                   % expr);
      % formula << assign(accu_var(k, t), expr) << '\n';
    % }
% }
% \end{lstlisting}
%
% \noindent
% \emph{Example:} \lstCPP{define_accu(1)}
%
% \begin{lstlisting}[style=smtlib]
% (assert (= accu_1_0
           % (ite exec_0_0_0
                % (bvadd accu_0_0 #x0001)
                % (ite exec_0_0_2
                     % (ite (and full_0_0 (= adr_0_0 #x0001))
                          % val_0_0
                          % (select heap_0 #x0001))
                     % accu_0_0))))
% (assert (= accu_1_1
           % (ite exec_0_1_0
                % (bvadd accu_0_1 #x0001)
                % (ite exec_0_1_2
                     % (ite (and full_0_1 (= adr_0_1 #x0000))
                          % val_0_1
                          % (select heap_0 #x0000))
                     % accu_0_1))))
% (assert (= accu_1_2
           % (ite exec_0_2_1
                % (bvadd accu_0_2
                       % (ite (and full_0_2 (= adr_0_2 #x0000))
                            % val_0_2
                            % (select heap_0 #x0000)))
                % (ite exec_0_2_2
                     % (bvadd accu_0_2
                            % (ite (and full_0_2
                                      % (= adr_0_2 #x0001))
                                 % val_0_2
                                 % (select heap_0 #x0001)))
                     % accu_0_2))))
% \end{lstlisting}

\newpage

\begin{lstlisting}[style=c++]
void define_accu (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    {
      std::string next = accu(k - 1, t);
      const auto & stmts = updates[State::accu][t];
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        next = ite(exec(k - 1, t, *pc),
                   program[t][*pc]->encode(k - 1, t, State::accu),
                   next);
      formula << assign(accu(k, t), next) << '\n';
    }
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_accu(1)}

\begin{lstlisting}[style=smtlib]
(assert (= accu_1_0
           (ite exec_0_0_0
                (bvadd accu_0_0 #x0001)
                (ite exec_0_0_2
                     (ite (and full_0_0 (= adr_0_0 #x0001))
                          val_0_0
                          (select heap_0 #x0001))
                     accu_0_0))))
(assert (= accu_1_1 ... ; same as before but reading address 0
(assert (= accu_1_2
           (ite exec_0_2_1
                (bvadd accu_0_2
                       (ite (and full_0_2 (= adr_0_2 #x0000))
                            val_0_2
                            (select heap_0 #x0000)))
                (ite exec_0_2_2
                     (bvadd accu_0_2
                            (ite (and full_0_2
                                      (= adr_0_2 #x0001))
                                 val_0_2
                                 (select heap_0 #x0001)))
                     accu_0_2))))
\end{lstlisting}

% \todo[inline]{define mem} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% State update functions of the remaining register states $\MEM^k_t$, $\SBADR^k_t$ and $\SBVAL^k_t$ are again defined almost identically and only differ by using the appropriate \lstCPP{State} entries and variable generators.
We omit the implementation of state update functions for the remaining register states $\MEM^k_t$, $\SBADR^k_t$ and $\SBVAL^k_t$ as they only differ \CHANGE{in} using the appropriate \lstCPP{State} entries and variable generators, but include their output \CHANGE{to show} the state updates generated for our demo example.

% \begin{lstlisting}[style=c++]
% void define_mem (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % {
      % std::string val = mem_var(k - 1, t);
      % const auto & stmts = updates[State::mem][t];
      % for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        % val = ite(exec_var(k - 1, t, *pc),
                  % program[t][*pc].encode(k - 1, t, State::mem),
                  % val);
      % formula << assign(mem_var(k, t), val) << '\n';
    % }
% }
% \end{lstlisting}

~\\
\noindent
\emph{Example:} \lstCPP{define_mem(1)}

\vspace{-\baselineskip/2}

\begin{lstlisting}[style=smtlib]
(assert (= mem_1_0 mem_0_0))
(assert (= mem_1_1 mem_0_1))
(assert (= mem_1_2 mem_0_2))
\end{lstlisting}

% \todo[inline]{define adr} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_adr (uint k)
% {
  % for (const auto & [t, stmts] : alters[State::adr])
    % {
      % std::string val = adr_var(k - 1, t);
      % for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        % val = ite(exec_var(k - 1, t, *pc),
                  % program[t][*pc].encode(k, t, State::adr),
                  % val);
      % formula << assign(adr_var(k, t), val) << eol;
    % }
  % formula << eol;
% }
% \end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_adr(1)}

\vspace{-\baselineskip/2}

\begin{lstlisting}[style=smtlib]
(assert (= adr_1_0 (ite exec_0_0_1 #x0000 adr_0_0)))
(assert (= adr_1_1 (ite exec_0_1_1 #x0001 adr_0_1)))
(assert (= adr_1_2 adr_0_2))
\end{lstlisting}

% \todo[inline]{define val} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_val (uint k)
% {
  % for (const auto & [t, stmts] : alters[State::val])
    % {
      % std::string val = val_var(k - 1, t);
      % for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        % val = ite(exec_var(k - 1, t, *pc),
                  % program[t][*pc].encode(k, t, State::val),
                  % val);
      % formula << assign(val_var(k, t), val) << eol;
    % }
  % formula << eol;
% }
% \end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_val(1)}

\vspace{-\baselineskip/2}

\begin{lstlisting}[style=smtlib]
(assert (= val_1_0 (ite exec_0_0_1 accu_0_0 val_0_0)))
(assert (= val_1_1 (ite exec_0_1_1 accu_0_1 val_0_1)))
(assert (= val_1_2 val_0_2))
\end{lstlisting}

% \todo[inline]{define full} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% collection the execution variables $\EXEC^{k - 1}_{t, pc}$ of \lstASM{STORE} instructions and the predecessor $\SBFULL^{k - 1}_t$ to preserve it's state.
% Successors of store buffer full flags are defined by a single
Store buffer full flags $\SBFULL^k_t$ are defined by a single
% Store buffer full states $\SBFULL^k_t$ are defined by a single
% $\ITE$, either resetting the state in case the store buffer has been flushed,
$\ITE$, either falsifying the state in case the store buffer has been flushed,
% or setting it by building a conjunction over the previously collected variables.
or assigning a conjunction over all execution variables $\EXEC^{k - 1}_{t, pc}$ of \lstASM{STORE} instructions to set it if an entry was added, as well as the predecessor $\SBFULL^{k - 1}_t$ for preserving its state otherwise.

\begin{lstlisting}[style=c++]
void define_full (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    {
      std::vector<std::string> args {full(k - 1, t)};
      for (uint pc : updates[State::full][t])
        args.push_back(exec(k - 1, t, pc));
      formula << assign(full(k, t),
                        ite(flush(k - 1, t),
                            "false",
                            lor(args))) << '\n';
    }
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_full(1)}

\begin{lstlisting}[style=smtlib]
(assert (= full_1_0 (ite flush_0_0
                            false
                            (or full_0_0 exec_0_0_1))))
(assert (= full_1_1 (ite flush_0_1
                            false
                            (or full_0_1 exec_0_1_1))))
(assert (= full_1_2 (ite flush_0_2 false full_0_2)))
\end{lstlisting}

\noindent
% \todo[inline]{define stmt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \newpage
% \noindent
% Definition of statement activation flags $\STMT^k_{t, pc}$ relies on the predecessors identified during preprocessing
% Definition of statement activation flags $\STMT^k_{t, pc}$ is based on the execution of preceding instructions, given in the \lstCPP{predecessors} map identified during preprocessing,
% Definition of statement activation flags $\STMT^k_{t, pc}$ relies on the following activation rules, based on the execution of preceding instructions, given in the \lstCPP{predecessors} map identified during preprocessing.
% \begin{itemize}
  % \item if the statement has no predecessor, or none of them is activated (\emph{reactivation}), assign it’s previous value if it’s hasn’t been executed
    % \[
      % \STMT^k_{t, pc} = \STMT^{k - 1}_{t, pc} \land \lnot \EXEC^{k - 1}_{t, pc}
    % \]
  % \item if any predecessor is activated, assign it’s execution variable’s value, otherwise follow the rule for statements without a predecessors
    % \[
      % \STMT^k_{t, pc} = \ITE(\STMT^{k - 1}_{t, pre}, \EXEC^{k - 1}_{t, pre}, \STMT^{k - 1}_{t, pc} \land \lnot \EXEC^{k - 1}_{t, pc})
    % \]
  % \item in the case of a jump, use the conjunction of the jump’s execution variable exec_k_t_pc and it’s condition to activate it’s target
    % \[
    % \]
% \end{itemize}
% Definition of statement activation flags $\STMT^k_{t, pc}$ is based on the execution of preceding instructions, given in the \lstCPP{predecessors} map identified during preprocessing.
% In order to either explicitly deactivate it if or otherwise preserve it's previous state (\emph{reactivation}), the corresponding update expression
% In order to either preserve the activation flag's previous state (\emph{reactivation}), or explicit deactivation in case of its execution, the corresponding update expression is initialized with a conjunction containing or deavtivate it in case of it's execution, the corresponding update expression is initialized with a conjunction
% If the corresponding statement is the initial program instruction, or none of it's predecessors was activated, assign
% Instead of another costly cardinality constraint, definition of statement activation variables $\STMT^k_{t, pc}$ is based on the execution of the corresponding instruction or any of it's preceding program statements to determine their successor by
% Instead of another costly cardinality constraint, definition of statement activation variables $\STMT^k_{t, pc}$ is based on the previous execution of the corresponding instruction and preceding program statements to either deactivate or activate them in the current step.
% To do so, each statement activation variables update expression is initialized with a conjunction containing it's previous state $\STMT^{k - 1}_{t, pc}$ together with the negation of the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ in order to deactivate it in case of it's execution or preserve it's state otherwise.
% >>>
% \todo[noline]{refer to interleaving assumption}
In order to correctly model symbolic program counters \CHANGE{correctly}, individual state updates must ensure that at most one statement is activated in any step.
% >>>
% In order to correctly model our symbolic program counters, individual state updates are based on the previous execution of the corresponding statement as well as preceding program instructions to ensure that at most one statement is activated in every step.
% In order to correctly model our symbolic program counters, individual updates of statement activation flags $\STMT^k_{t, pc}$ are based on their previous execution or preceding program instructions to ensure that at most one statement is activated in every step.
% In order to correctly model our symbolic program counters, individual updates of statement activation flags $\STMT^k_{t, pc}$ are based on the previous execution of the corresponding instruction as well as preceding program instructions to ensure that at most one statement is activated in every step.
% In order to correctly model our symbolic program counters, individual state updates of statement activation variables $\STMT^k_{t, pc}$ must ensure that at most one is activated in every step.
% \newpage
% \noindent
% $\STMT^{k - 1}_{t, pc}$t
% Instead of another costly cardinality constraint, the update expression of each statement activation variable $\STMT^k_{t, pc}$ is initialized with a conjunction containing it's previous activation and the negation of the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ for explicitly deactivating the statement in case of it's execution, while preserving it's state otherwise.
% Instead of another costly cardinality constraint, the update expression of each statement activation variable $\STMT^k_{t, pc}$ is initialized with a conjunction containing it's previous activation and the negation of the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ for explicitly deactivating the statement if it has been executed or preserving it's state otherwise.
% >>>
We do so by initializing the update expression of each statement activation variable $\STMT^k_{t, pc}$ with a conjunction containing its previous activation and the negation of the corresponding execution variable $\EXEC^{k - 1}_{t, pc}$ for explicitly deactivating the statement if it has been executed while preserving its state otherwise.
% >>>
% Each preceding instruction in the thread's program then adds an $\ITE$, setting the successor state to the predecessor's execution
% Similar to defining the successor of register states, each preceding instruction in the thread's program then embeds the expression's current value in the \emph{else} branch of an $\ITE$, activating the statement depending on the particular predecessor's execution.
% Similar to defining the successor of register states, each preceding program statement then embeds the expression's current value in the \emph{else} branch of an $\ITE$, either enabling or disabling the statement activation variable according to the predecessors execution in case it was activated.
% Similar to defining the successor of register states, each preceding program statement then embeds the expression's current value in the \emph{else} branch of an $\ITE$, either enabling or disabling the statement activation variable according to the predecessor's execution.
% Similar to defining the successor of register states, each preceding program statement then embeds the expression's current value in the \emph{else} branch of an $\ITE$, either enabling the statement activation variable depending to the predecessor's execution or keeping it disabled.
\CHANGE{Similarly} to defining the successor of register states, each preceding program statement then embeds the expression's current value in the \emph{else} branch of an $\ITE$, activating the statement depending on the predecessor's execution.
% In case of the predecessor being a conditional jump, identified by \lstCPP{bool is_jump (Instruction *)},
% In case of the statement being the target of a jump,
% Conditional jumps, detected by \lstCPP{is_jump}
% In case of the predecessor being a conditional jump, identified by \lstCPP{is_jump},
% Special care must be taken in case of the predecessor being a conditional jump, identified by \lstCPP{is_jump}, to either activate the target of a successfull jump using a conjunction of it's execution variable and condition, generated by the relevant \lstCPP{encode} implementation, or the negation thereof if it failed.
Special care must be taken in case of the predecessor being a conditional jump, identified by \lstCPP{is_jump}, to either activate the target using a conjunction of its execution variable and condition, generated by the relevant \lstCPP{encode} implementation, or the next statement by negating the condition in case of a failed jump.

% using a conjunction of the jump's execution variable together with it's condition, generated by the relevant \lstCPP{encode} implementation, or it's negation.
% >>>
% >>>

% preserve state
% deactivate in case of it's execution

% \todo[noline]{introduce anonymous is_jump function}

% \begin{lstlisting}[style=c++]
% void define_stmt (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % for (uint pc = 0; pc < programs[t].size(); pc++)
      % {
        % // statement reactivation
        % std::string expr = land(stmt_var(k - 1, t, pc),
                              % lnot(exec_var(k - 1, t, pc)));
        % // activation by predecessor
        % const auto & stmts = predecessors[t][pc];
        % for (auto pre = stmts.rbegin(); pre != stmts.rend(); ++pre)
          % {
            % std::string exec = exec_var(k - 1, t, *pre);
            % Instruction * op = programs[t][*pre];
            % // add condition if predecessor is a jump
            % if (is_jump(op))
              % {
                % std::string cond = op->encode(k - 1, t, State::stmt);
                % if (!cond.empty())
                  % exec = land(exec,
                              % // negate condition for failed jumps
                              % *pre == pc - 1 && op.arg != pc
                                % ? lnot(cond)
                                % : cond);
              % }
            % expr = ite(stmt_var(k - 1, t, *pre), exec, expr);
          % }
        % formula << assign(stmt_var(k, t, pc), expr) << '\n';
      % }
% }
% \end{lstlisting}

\begin{lstlisting}[style=c++]
void define_stmt (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    for (uint pc = 0; pc < programs[t].size(); pc++)
      {
        // statement reactivation
        std::string next = land(stmt(k - 1, t, pc),
                              lnot(exec(k - 1, t, pc)));
        // activation by predecessor
        const auto & stmts = predecessors[t][pc];
        for (auto pre = stmts.rbegin(); pre != stmts.rend(); ++pre)
          {
            std::string val = exec(k - 1, t, *pre);
            Instruction * op = programs[t][*pre];
            // add condition if predecessor is a jump
            if (is_jump(op))
              {
                std::string cond = op->encode(k - 1, t, State::stmt);
                val = land(val, op->arg == pc ? cond : lnot(cond));
              }
            next = ite(stmt(k - 1, t, *pre), val, next);
          }
        formula << assign(stmt(k, t, pc), next) << '\n';
      }
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_stmt(1)}

\begin{lstlisting}[style=smtlib]
(assert (= stmt_1_0_0 (and stmt_0_0_0 (not exec_0_0_0))))
(assert (= stmt_1_0_1 (ite stmt_0_0_0
                           exec_0_0_0
                           (and stmt_0_0_1 (not exec_0_0_1)))))
(assert (= stmt_1_0_2 (ite stmt_0_0_1
                           exec_0_0_1
                           (and stmt_0_0_2 (not exec_0_0_2)))))
(assert (= stmt_1_0_3 (ite stmt_0_0_2
                           exec_0_0_2
                           (and stmt_0_0_3 (not exec_0_0_3)))))
(assert (= stmt_1_0_4 (ite stmt_0_0_3
                           exec_0_0_3
                           (and stmt_0_0_4 (not exec_0_0_4)))))
(assert (= stmt_1_1_0 (and stmt_0_1_0 (not exec_0_1_0))))
(assert (= stmt_1_1_1 (ite stmt_0_1_0
                           exec_0_1_0
                           (and stmt_0_1_1 (not exec_0_1_1)))))
(assert (= stmt_1_1_2 (ite stmt_0_1_1
                           exec_0_1_1
                           (and stmt_0_1_2 (not exec_0_1_2)))))
(assert (= stmt_1_1_3 (ite stmt_0_1_2
                           exec_0_1_2
                           (and stmt_0_1_3 (not exec_0_1_3)))))
(assert (= stmt_1_1_4 (ite stmt_0_1_3
                           exec_0_1_3
                           (and stmt_0_1_4 (not exec_0_1_4)))))
(assert (= stmt_1_2_0 (and stmt_0_2_0 (not exec_0_2_0))))
(assert (= stmt_1_2_1 (ite stmt_0_2_0
                           exec_0_2_0
                           (and stmt_0_2_1 (not exec_0_2_1)))))
(assert (= stmt_1_2_2 (ite stmt_0_2_1
                           exec_0_2_1
                           (and stmt_0_2_2 (not exec_0_2_2)))))
(assert (= stmt_1_2_3 (ite stmt_0_2_2
                           exec_0_2_2
                           (and stmt_0_2_3 (not exec_0_2_3)))))
(assert (= stmt_1_2_4 (ite stmt_0_2_3
                           (and exec_0_2_3 (not (= accu_0_2
                                                   #x0000)))
                           (and stmt_0_2_4 (not exec_0_2_4)))))
(assert (= stmt_1_2_5 (ite stmt_0_2_3
                           (and exec_0_2_3 (= accu_0_2 #x0000))
                           (and stmt_0_2_5 (not exec_0_2_5)))))
\end{lstlisting}

% \begin{lstlisting}[style=smtlib]
% (assert (= stmt_1_0_0 (and stmt_0_0_0 (not exec_0_0_0))))
% (assert (= stmt_1_0_1 (ite stmt_0_0_0
                           % exec_0_0_0
                           % (and stmt_0_0_1 (not exec_0_0_1)))))
% (assert (= stmt_1_0_2 (ite stmt_0_0_1
                           % exec_0_0_1
                           % (and stmt_0_0_2 (not exec_0_0_2)))))
% (assert (= stmt_1_0_3 (ite stmt_0_0_2
                           % exec_0_0_2
                           % (and stmt_0_0_3 (not exec_0_0_3)))))
% (assert (= stmt_1_0_4 (ite stmt_0_0_3
                           % exec_0_0_3
                           % (and stmt_0_0_4 (not exec_0_0_4)))))
% ...
% (assert (= stmt_1_2_0 (and stmt_0_2_0 (not exec_0_2_0))))
% (assert (= stmt_1_2_1 (ite stmt_0_2_0
                           % exec_0_2_0
                           % (and stmt_0_2_1 (not exec_0_2_1)))))
% (assert (= stmt_1_2_2 (ite stmt_0_2_1
                           % exec_0_2_1
                           % (and stmt_0_2_2 (not exec_0_2_2)))))
% (assert (= stmt_1_2_3 (ite stmt_0_2_2
                           % exec_0_2_2
                           % (and stmt_0_2_3 (not exec_0_2_3)))))
% (assert (= stmt_1_2_4 (ite stmt_0_2_3
                           % (and exec_0_2_3 (not (= accu_0_2
                                                   % #x0000)))
                           % (and stmt_0_2_4 (not exec_0_2_4)))))
% (assert (= stmt_1_2_5 (ite stmt_0_2_3
                           % (and exec_0_2_3 (= accu_0_2 #x0000))
                           % (and stmt_0_2_5 (not exec_0_2_5)))))
% \end{lstlisting}

% \todo[inline]{define block} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% Block flags $\BLOCK^k_{id, t}$ are defined by a single $\ITE$, either unblocking the thread by resetting the state if all threads synchronized upon the corresponding checkpoint $id$ in the previous step, or assigning a conjunction including all execution variables $\EXEC^{k - 1}_{t, pc}$ of related \lstASM{CHECK id} instructions to enable it, as well as the predecessor $\BLOCK^{k - 1}_{id, t}$ for preserving it's state.
Block flags $\BLOCK^k_{id, t}$ are defined by a single $\ITE$, unblocking the thread by resetting the state if all threads synchronized upon the corresponding checkpoint $id$ in the previous step. %$k - 1$.
Otherwise, \CHANGE{we assign} a disjunction including all execution variables $\EXEC^{k - 1}_{t, pc}$ of related \lstASM{CHECK id} instructions enabling the state as well as the predecessor $\BLOCK^{k - 1}_{id, t}$ to presere its value.
%signalled by $\CHECK^{k - 1}_{id}$

\begin{lstlisting}[style=c++]
void define_block (uint k)
{
  for (const auto & [id, threads] : checkpoints)
    for (const auto & [t, stmts] : threads)
      {
        std::vector<std::string> args {block(k - 1, id, t)};
        for (uint pc : stmts)
          args.push_back(exec(k - 1, t, pc));
        formula << assign(block(k, id, t),
                          ite(check(k - 1, id),
                              "false",
                              lor(args))) << '\n';
      }
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_block(1)}

\begin{lstlisting}[style=smtlib]
(assert (= block_1_0_0 (ite check_0_0
                            false
                            (or block_0_0_0 exec_0_0_3))))
(assert (= block_1_0_1 (ite check_0_0
                            false
                            (or block_0_0_1 exec_0_1_3))))
(assert (= block_1_0_2 (ite check_0_0
                            false
                            (or block_0_0_2 exec_0_2_0))))
\end{lstlisting}

% \todo[inline]{define halt} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_halt (uint k)
% {
  % for (uint t = 0; t < programs.size(); t++)
    % {
      % if (halts.find(thread) != halts.end())
        % {
          % std::vector<std::string> args;
          % for (const auto pc : halts[t])
            % args.push_back(exec_var(k - 1, t, pc));
          % args.push_back(halt_var(k - 1, t));
          % formula << assign(halt_var(k, t), lor(args)) << eol;
        % }
      % else
        % formula << assign(halt_var(k, t), "false") << eol;
    % }
  % formula << eol;
% }
% \end{lstlisting}

\noindent
% Since there is no way of restarting a halted thread, halt flags $\Halt^k_t$ are enabled by a disjunction including the execution variables $\EXEC^{k - 1}_{t, pc}$ of \lstASM{HALT} instructions.
Since halt flags $\HALT^k_t$ cannot be reset once a thread has been stopped, they are defined by a simple disjunction including the execution variables $\EXEC^{k - 1}_{t, pc}$ of \lstASM{HALT} instructions and the previous state $\HALT^{k - 1}_t$ to preserve their value.

\newpage

\begin{lstlisting}[style=c++]
void define_halt (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    {
      std::vector<std::string> args {halt(k - 1, t)};
      for (uint pc : updates[State::halt][t])
        args.push_back(exec(k - 1, t, pc));
      formula << assign(halt(k, t), lor(args)) << '\n';
    }
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_halt(1)}

\begin{lstlisting}[style=smtlib]
(assert (= halt_1_0 (or halt_0_0 exec_0_0_4)))
(assert (= halt_1_1 (or halt_0_1 exec_0_1_4)))
(assert (= halt_1_2 halt_0_2))
\end{lstlisting}

% \todo[inline]{define heap} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% Definition of the global heap array $\HEAP^k$ again starts by initializing the update expression with it's predecessor $\HEAP^{k - 1}$, preserving the previous state.
Definition of our shared memory array $\HEAP^k$ again starts by initializing the update expression with its previous state $\HEAP^{k - 1}$.
% Each thread then embeds the expression in the \emph{else} branch an $\ITE$, storing the store buffer's entry in case it was flushed.
% Each thread then extends the expression by embedding it's current value in the \emph{else} branch an $\ITE$, storing the store buffer's entry in case it was flushed.
% Each thread then extends the expression by embedding it in an $\ITE$, storing the store buffer's entry in case it was flushed.
% Each thread then extends the expression by embedding it in an $\ITE$ for every atomic write, modifying the array according to the instruction's \lstCPP{encode} implementation in case of its execution, as well as storing the store buffer entry if it was flushed.
% Each thread then extends the expression by embedding it in an $\ITE$ for every atomic write, modifying the array according to the instruction's \lstCPP{encode} implementation in case of its execution and storing the store buffer entry if it was flushed.
Each thread then extends the expression by embedding it in an $\ITE$ for every atomic write, modifying the array according to the instruction's \lstCPP{encode} implementation, followed by a final \CHANGE{if-then-else} to store the store buffer entry in case it was flushed.
% Each thread then extends the expression by embedding it in an $\ITE$ for every atomic write, modifying the array according to the instruction's \lstCPP{encode} implementation in case of its execution and another one to store the store buffer entry if it was flushed.
%
% Furthermore, if the contains a statement atomically writing to memory, another $\ITE$, modifying array according to the instruction's \lstCPP{encode} implementation is added.
% Furthermore, if the contains a statement atomically writing to memory, another $\ITE$, modifying array according to the instruction's \lstCPP{encode} implementation is added.
% The actual update expression is then built by iteratively embeding it's previous value in the \emph{else} branch of an $\ITE$, storing the

\begin{lstlisting}[style=c++]
void define_heap (uint k)
{
  std::string next = heap(k - 1);
  for (int t = programs.size() - 1; t >= 0; t--)
    {
      const auto & stmts = updates[State::heap][t];
      for (auto pc = stmts.rbegin(); pc != stmts.rend(); ++pc)
        next = ite(exec(k - 1, t, *pc),
                   programs[t][*pc].encode(k - 1, t, State::heap),
                   next);
      next = ite(flush(k - 1, t),
                 store(heap(k - 1),
                       adr(k - 1, t),
                       val(k - 1, t)),
                 next);
    }
  formula << assign(heap(k, t), next) << '\n';
}
\end{lstlisting}

\newpage

\noindent
\emph{Example:} \lstCPP{define_heap(1)}

\begin{lstlisting}[style=smtlib]
(assert (= heap_1
           (ite flush_0_0
                (store heap_0 adr_0_0 val_0_0)
                (ite flush_0_1
                     (store heap_0 adr_0_1 val_0_1)
                     (ite flush_0_2
                          (store heap_0 adr_0_2 val_0_2)
                          heap_0)))))
\end{lstlisting}

% \todo[inline]{define exit-flag} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_exit_flag (uint k)
% {
  % if (halts.empty() && exits.empty())
    % return;
%
  % std::vector<std::string> args {exit_flag_var(k - 1)};
%
  % if (!halts.empty())
    % {
      % std::vector<std::string> halt;
      % for (uint t = 0; t < programs.size(); t++)
        % halt.push_back(halt_var(k, t));
      % args.push_back(land(halt));
    % }
%
  % if (!exits.empty())
    % for (const auto & [t, stmts] : exits)
      % for (const auto pc : stmts)
        % args.push_back(exec_var(k - 1, t, pc));
%
  % formula << assign(exit_flag_var(k), lor(args)) << eol << eol;
% }
% \end{lstlisting}

\noindent
% In order to enable the exit flag $\EXIT^k$ according to our termination criteria, we define it as a disjunction containing the execution variables $\EXEC^{k - 1}_{t, pc}$ of every \lstASM{EXIT} statement, a conjunction over all halt variables $\HALT^k_t$ to stop the machine if no more thread is running and the previous state $\EXIT^{k - 1}$, preserving it's value.
In order to enable the exit flag $\EXIT^k$ according to our termination criteria, we define it as a disjunction containing the execution variables $\EXEC^{k - 1}_{t, pc}$ of every \lstASM{EXIT} statement, a conjunction over \CHANGE{the} halt variables $\HALT^k_t$ \CHANGE{of threads containing a call to \lstASM{HALT} for} stopping the machine if no more thread\CHANGE{s are} running and the previous state $\EXIT^{k - 1}$ to preserve its value.

\begin{lstlisting}[style=c++]
void define_exit(uint k)
{
  std::vector<std::string> halts;
  for (const auto & stmts : updates[State::halt])
    for (uint pc : stmts)
      halts.push_back(halt(k, t));
  std::vector<std::string> args {exit(k - 1), land(halts)};
  for (const auto & stmts : updates[State::exit])
    for (uint pc : stmts)
      args.push_back(exec(k - 1, t, pc));
  formula << assign(exit(k), lor(args)) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{define_exit(1)}

\begin{lstlisting}[style=smtlib]
(assert (= exit_1
           (or exit_0
               (and halt_1_0 halt_1_1)
               exec_0_2_4
               exec_0_2_5)))
\end{lstlisting}

% \todo[inline]{define exit-code} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lstlisting}[style=c++]
% void define_exit_code ()
% {
  % std::string expr = consth(0);
  % if (!exits.empty())
    % for (uint k = 0; k <= bound; k++)
      % for (int t = programs.size() - 1; t >= 0; t--)
          % for (const auto & pc : exits[t])
            % expr = ite(exec_var(k, t, pc),
                      % programs[t][pc].encode(k, t, State::exit),
                      % expr);
  % formula << assign(exit_code_var, expr) << '\n';
% }
% \end{lstlisting}

\noindent
% Our functional encoding scheme is concluded by the definition of the machine's exit code $\EXITCODE$.
% Our functional encoding scheme is concluded by defining the machine's exit code $\EXITCODE$.
Our functional encoding scheme is concluded by setting the machine's exit code during the final step.
% >>>
% Since it is only assigned once, \emph{static single assignments} allow us to reduce the total number of variables by introducing only a single state
%, defined by an $\ITE$ cascade over all steps $k \in [0, bound]$
% for all steps $k \in [0, bound]$
% >>>
% Since it is unique in every execution, \emph{static single assignments} allow us to reduce the total number of variables by introducing only a single state for all $k \in [0, bound]$.
Since it is unique in every execution, explicit unrolling allows us to reduce the total number of variables by introducing only a single state $\EXITCODE$, %for all steps $k \in [0, bound]$.
% Since it is unique in every execution, the total number of variables can be reduced by introducing only a single state in our unrolled model checking problem,
% Since it is unique in every execution, unrolling our model checking problem for each step $k \in [0, bound]$ allows us to reduce the total number of variables by introducing only a single state for all $k \in [0, bound]$,
% assigned during the final step $k = bound$.
% The defining expression is initialized with zero and extended by embedding it in an $\ITE$
% embedding it in an $\ITE$, covering the execution of any \lstASM{EXIT} statement by assigning the according value, depending on
defined by an expression initialized with zero and embedded in an $\ITE$
for each step $k \in [0, bound]$ and \lstASM{EXIT} statement, assigning the corresponding exit code in case of its execution.
% >>>
% In order to reduce the total number of variables, only a single state is used in
% update expression initialized with the default exit code.

\begin{lstlisting}[style=c++]
void define_exit_code ()
{
  std::string next = consth(0);
  for (uint k = 0; k <= bound; k++)
    for (const auto & stmts : updates[State::exit])
      for (uint pc : stmts)
        next = ite(exec(k, t, pc),
                   programs[t][pc].encode(k, t, State::exit),
                   next);
  formula << assign(exit_code, next) << '\n';
}
\end{lstlisting}

\begin{lstlisting}[style=smtlib]
(assert (= exit-code
           (ite exec_17_2_5
                #x0001
                (ite exec_17_2_4
                     #x0000
                     ...
                     (ite exec_0_2_5
                          #x0001
                          (ite exec_0_2_4
                               #x0000
                               #x0000))))))
\end{lstlisting}

\newpage

