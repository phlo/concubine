\section{Introduction}

\subsection{Toolchain}

\begin{figure}[h]
  \centering
  \input{figures/toolchain.tex}
  \caption{Toolchain}
\end{figure}

\todo[inline]{components structured according to the mode they are used}

\subsection{Problem/Motivation}

\todo[inline]{problems arising due to the unawareness of the specific architectures memory model}
\todo[inline]{example for counter intuitive behaviour} \noindent
The Intel-64 and AMD memory-ordering models allow a load to be reordered with an earlier store to a different location, thus breaking sequential consitency.
However, loads are not reordered with stores to the same location.
Even though this is the only reordering allowed, it is sufficient for introducing counter intuitive behaviour, illustrated by the example given in Listing \ref{fig:intro:code}.

\newpage

\begin{lstlisting}[style=c++, caption={Store Buffer Litmus Test}, label={fig:intro:code}]
#include <pthread.h>
#include <assert.h>

#define ACCESS(x) (*(volatile typeof(x) *) &(x))
#define READ(x) ({typeof(x) TMP = ACCESS(x); TMP;})
#define WRITE(x,v) ({ACCESS(x) = (v);})

static int w0 = 0;
static int w1 = 0;

static int r0 = 0;
static int r1 = 0;

static void * P0 (void * p)
{
  WRITE(w0, 1);
  r0 = READ(w1);
  return p;
}

static void * P1 (void * p)
{
  WRITE(w1, 1);
  r1 = READ(w0);
  return p;
}

int main ()
{
  pthread_t t[2];
  pthread_create (t + 0, 0, P0, 0);
  pthread_create (t + 1, 0, P1, 0);
  pthread_join (t[0], 0);
  pthread_join (t[1], 0);
  assert(r0 + r1);
  return 0;
}
\end{lstlisting}

\todo[inline]{x86 permits $\texttt{r0 = 0} \land \texttt{r1 = 0}$}
