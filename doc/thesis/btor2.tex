\section{BTOR2}

% We also included the possibility to generate the novel word level model checking format \BTOR \cite{ref:BTOR2}, providing a sequential extensions for specifying word-level model checking problems with registers and memories.
We also included the possibility to generate the word level model checking format {\BTOR} \cite{ref:BTOR2}, using the \texttt{-e btor2} command line parameter.
% providing a \emph{sequential extension} for specifying % register and array states in combination with a transition function,
% By providing a \emph{sequential extension} for specifying % register and array states in combination with a transition function,
It provides a \emph{sequential extension} for specifying % register and array states in combination with a transition function,
states in combination with their transition functions,
which are automatically unrolled via symbolic substitution by the accompanying bounded model checker BtorMC.
% the generated formulas size remains constant with respect to the upper bound, compared to the linear growth of our {\SMTLIB} encodings.
% it produces constant sized formulas with respect to the upper bound
% In contrast to \SMTLIB, which requires manual unrolling, \BTOR produces constant sized formulas with respect to the upper bound.
% Automatic unrolling via symbolic substitution by the accompanying bounded model checker BtorMC
% >>>
In contrast to the linear growth of our {\SMTLIB} encodings, the generated formulas size therefore remains constant for any given bound. % with respect to the upper bound.
% The generated formulas size therefore remains constant with respect to the upper bound, compared to the linear growth of our {\SMTLIB} encodings.
% In contrast to {\SMTLIB}, which requires manual unrolling, it produces constant sized formulas with respect to the upper bound by providing a \emph{sequential extension} for specifying states in combination with their transition functions.
% states in combination with their transition functions.
% symbolicly substituting current state expressions into next state functions and incremental SMT solving.
% Its line based syntax on the other hand requires more housekeeping, leading to a slightly more complex encoding process.
% We omit an outline of the encoding process, as it is semantically equivalent to the {\SMTLIB} formulas using our functional next state logic and a bit more tedious due to the line based syntax.
% We omit an outline of the encoding process, as it is semantically equivalent to the previous one using our functional next state logic and a bit more tedious due to the line based syntax.
We omit further details about the encoding process, as it is more or less identical to the previous using our functional next state logic, but a bit more tedious due to the line based syntax.

% \todo[inline]{BTOR2 - word level model checking format \cite{ref:BTOR2}}
% \todo[inline]{provides sequential extensions for specifying word-level model checking problems with registers and memories}
% \todo[inline]{implicit unrolling using symbolic simulation}
% \todo[inline]{solver BtorMC}
% \todo[inline]{constant formula size w.r.t. the upper bound}
% \todo[inline]{generated by using the \texttt{-e btor2} command line parameter}

% \subsubsection{BTOR2 generator functions}
% \todo[inline]{BTOR2 generator functions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{lstlisting}[style=c++]
% template <class ... T>
% std::string expr (const std::string & nid, const T & ... args)
% {
  % std::string e = nid;
  % (((e += ' ') += args), ...);
  % auto & end = e.back();
  % if (end == ' ')
    % end = eol;
  % else
    % e += eol;
  % return e;
% }
% \end{lstlisting}
%
% \todo[inline]{main encoding function (smtlib)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{lstlisting}[style=c++]
% void encode ()
% {
  % declare_sorts();
  % declare_constants();
  % define_mmap();
  % declare_states();
  % declare_inputs();
  % define_transitions();
  % define_constraints();
  % define_states();
% }
% \end{lstlisting}
%
% \todo[inline]{declare sorts} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{lstlisting}[style=c++]
% void declare_sorts ()
% {
  % formula <<
    % sort_bitvec(sid_bool = nid(), "1") <<
    % sort_bitvec(sid_bv = nid(), std::to_string(word_size)) <<
    % sort_array(sid_heap = nid(), "2", "2") <<
    % eol;
% }
% \end{lstlisting}

