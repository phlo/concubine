\section{Relational Next State Logic}

% > show difference in terms of runtime
% State of the art SAT and SMT solvers are able to exploit certain structures in the problem formulation, increasing performance in terms of runtime.
% Different encodings may therefore exhibit a rather drastical impact on the relative hardness of the resulting formula.
Since state of the art SAT and SMT solvers are able to exploit certain structures in the problem formulation, the relative hardness of different semantically equivalent encodings may vary quite drastically.
% State of the art SAT and SMT solvers  their performance partly by exploiting the structure of a given problem.
% structural changes in the problem formulation
% In order to show the differences of structural
% semantically equivalent encodings in terms of the
% generated by using the \texttt{-e smtlib-relational} command line parameter.
% better for combinatorial problems and small domains
% To highlight these differences, we include another encoding using a relational next state logic, sought to be more suitable for large combinatorial problems and small domains, generated by using the \texttt{-e smtlib-relational} command line parameter.
% relational next state logic
% requireing order of magnitude more time to solve than our previous functional approach, leading to a tree-like/hierarchical structure
% > highlight differences
% > next states fully implied by each transition
To highlight these differences,
we included another variant using a relational next state logic,
generated with the \texttt{-e smtlib-relational} command line parameter, % and
% based on states being fully implied by each transition.
% based on implying the complete set of successors for each transition.
based on implying the successors for each possible transition.
% > flat encoding sought of being more suitable for combinatorial problems and small domains
% > order of magnitude more time to solve compared to functional approach, resulting in a hierarchical structure | expression tree
% > simplified by term rewriting during the solver's preprocessing stage
Although this flat encoding scheme tends to work well with large combinatorial problems and small domains, \CHANGE{our experiments show that} it requires \CHANGE{considerably} more time to solve compared to our functional approach. %, which can be radically simplified by clever term rewriting due to its strictly hierarchical nature. %structure.

% \todo[inline]{define states (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[style=c++]
void define_states (uint k)
{
  for (uint t = 0; t < programs.size(); t++)
    {
      imply_thread_executed(k, t);
      imply_thread_not_executed(k, t);
      imply_thread_flushed(k, t);
    }
  imply_machine_exited(k);
}
\end{lstlisting}

\noindent
We begin by defining variadic template functions for simplifying the generation of frequently reoccurring expressions, used to restore a state's previous value and additionally reset flags depending on a given condition.
% conditionally reset flags.
%for generating a frequently reoccuring pattern

% \begin{lstlisting}[style=c++, belowskip=\medskipamount]
\begin{lstlisting}[style=c++]
template <class R, class ... T>
R restore (R (*var) (uint k, T ... args), uint k, T ... args)
{
  return equal(var(k, args...), var(k - 1, args...));
}
\end{lstlisting}

\begin{lstlisting}[style=c++, aboveskip=0pt]
template <class R, class ... T>
R reset (R (*var) (uint k, uint x, T ... args),
         R (*cond) (uint k, uint x),
         uint k, uint x, T ... args)
{
  return equal(var(k, x, args...),
               ite(cond(k - 1, x),
                   "false",
                   var(k - 1, x, args...)));
}
\end{lstlisting}

\noindent
% Definition of successor states depending on the execution of a certain thread is simplified by introducing the following custom map,
% consolidating the next state expressions
% initialized with the common next state expressions
% Implying the successor states according to the execution of a certain thread requires m
% In order to minimize the effort when defining the successors for each possible instruction, we introduce the following custom map
% >>>
% Implying the whole set of states influenced by executing any instruction leads to most of them being unchanged and required to be preserved in the next step.
% Implying the whole set of states that may be influenced by executing any kind of instruction leads to most of them being unchanged and required to be preserved in the next step.
% Implying all states that might be influenced by executing a certain thread, leads to most of them being unchanged by any specific instruction.
Implying a common set of states that might be influenced by executing a certain thread
% leads to most of them being unchanged by any specific statement.
results in most of them \CHANGE{remaining} unchanged. % by any specific statement.
% Implying a common set of states for each statement that might be executed by a certain thread
% Since most states remain unchanged when executing a certain instruction, implying
% >>>
% To reduce the effort when implementing the next state functions of every instruction, we introduce the following custom map,
% To reduce the implementation effort for a particular instruction's encoding function, we introduce the following custom map,
% >>>
% To reduce the effort during the implementation of each instruction's encoding function, we introduce the following custom map,
% To reduce the implementation effort for each instruction's encoding function, we introduce the following custom map,
% To reduce the effort involved in implementing the next state function of each instruction, we introduce the following map, % !
% containing the default expressions for restoring the previous value of this common set of states,
% containing the common set of states, initialized with the default expression for restoring their value,
% initialized with the default expressions for restoring this common set of states in the current step,
% aggregating all relevant states and initializing them with the corresponding state-preserving expression, % !
% containing the common set of states, initialized with the default expression for restoring their value,
% >>>
% initialized the update expression of all common states
% thus requiring only the entries of states actually being altered to be replaced.
% in order to set only the states that actually change.
% such that only the ones set by the specific instruction needs to be overwritten
% thus requiring only the entries of states which are actually altered to be replaced. % !
% >>>
% We introduce the following next state map to reduce the effort involved in implementing the encoding function of each instruction by aggregating all relevant states and initializing them with the corresponding state-preserving expression, thus requiring only the entries of states which are actually altered to be replaced.
% >>>
% Furthermore, it offers an implicit \lstCPP{std::string} conversion operator, returning a conjunction to define the successors of all contained states at once.
% Furthermore, it offers an implicit \lstCPP{std::string} conversion operator, returning a conjunction to define the successors of all contained states at once.
% >>>
% In order to reduce the effort involved in implementing the encoding function of each instruction we introduce the following map, aggregating all relevant states and provide an implicit \lstCPP{std::string} conversion operator returning a conjunction to define the successors of all contained states at once.
In order to reduce the effort involved in implementing the encoding function of each instruction, we introduce the following map,
using the previously defined template functions to initialize it with the corresponding state-preserving expressions,
% and provide an implicit \lstCPP{std::string} conversion operator returning a conjunction to define the successors of all contained states at once.
thus requiring only the entries of states which are actually altered to be replaced
and provide an implicit \lstCPP{std::string} conversion operator returning a conjunction to define all successors at once.
% By using the previously defined template functions, we are able to add a constructor to initialize them with the corresponding state-preserving expressions for a given step and thread, thus requiring only the entries of states which are actually altered to be replaced.
% Furthermore, they are initialized with corresponding state-preserving expressions, thus requiring only the entries of states which are actually altered to be replaced.

% \todo[inline]{map containing next state expressions to simplify definition of successor states that depend on the execution of a certain thread}
% \todo[inline]{replace entries with the required next state expressions}
% \todo[inline]{implicit \lstCPP{std::string} conversion operator: returning a conjunction defining the successors for all states contained}
% \todo[inline]{used by \lstCPP{imply_thread_*executed}}

% // restore block
% if (!checkpoints.empty())
%   {
%     std::vector<std::string> block_vars;
%     for (const auto & [id, threads] : checkpoints)
%       if (threads.find(t) != threads.end())
%         block_vars.push_back(reset(&block_var,
%                                    &check_var,
%                                    k, id, t));
%     (*this)[State::block] = land(block_vars);
%   }
\begin{lstlisting}[style=c++]
struct Next : std::map<State, std::string>
{
  Next (k, t)
    {
      (*this)[State::accu] = restore(&accu, k, t);
      (*this)[State::mem] = restore(&mem, k, t);
      (*this)[State::adr] = restore(&adr, k, t);
      (*this)[State::val] = restore(&val, k, t);
      (*this)[State::full] = restore(&full, k, t);
      (*this)[State::halt] = restore(&halt, k, t);
      (*this)[State::heap] = restore(&heap, k);
      (*this)[State::exit] = lnot(exit(k, t));
      std::vector<std::string> block_vars;
      for (const auto & [id, threads] : checkpoints)
        if (threads.find(t) != threads.end())
          block_vars.push_back(reset(&block,
                                     &check,
                                     k, id, t));
      if (!block_vars.empty())
        (*this)[State::block] = land(block_vars);
    }

  operator std::string () const
    {
      std::vector<std::string> args;
      for (const auto & [_, expr] : *this)
        if (!expr.empty())
          args.push_back(expr);
      return land(args);
    }
};
\end{lstlisting}

% \todo[inline]{changed by every instruction and therefore not included in the next state map}
% \todo[inline]{requires setting all statement activation variables of a given thread}
% \todo[inline]{helper functions for activating a certain statement}

\newpage
\noindent
Since the statement activation variables $\STMT^k_{t, pc}$ of each thread must be fully defined for every possible transition, we include helper functions to generate the required conjunctions.

\begin{lstlisting}[style=c++]
std::string activate (uint k, uint t, uint pc)
{
  std::vector<std::string> stmts;
  for (uint i = 0; i < programs[t].size(); i++)
    stmts.push_back(i == pc ? stmt(k, t, pc)
                            : lnot(stmt(k, t, i)));
  return land(stmts);
}
\end{lstlisting}

% \todo[inline]{overload to be used by jump instructions, either activating the successor statement or jump target depending on its condition}
\noindent
% In terms of jump instructions, we define another overload for either activating the successor statement or the target, depending on the corresponding condition.
In case of jump instructions, another overload either activates the target or successor statement, depending on the corresponding condition.
% Another overload handles jump instructions by either activating the successor statement or the target, depending on the corresponding condition.

% \begin{lstlisting}[style=c++, aboveskip=0pt]
\begin{lstlisting}[style=c++]
std::string activate (uint k, uint t, uint pc, Instruction * jmp)
{
  std::vector<std::string> stmts;
  std::string condition = jmp->encode(k - 1, t, State::stmt);
  for (uint i = 0; i < programs[t].size(); i++)
    {
      std::string stmt_var = stmt(k, t, i);
      if (i == jmp->arg)
        stmts.push_back(ite(condition, stmt_var, lnot(stmt_var)));
      else if (i == pc + 1)
        stmts.push_back(ite(condition, lnot(stmt_var), stmt_var));
      else
        stmts.push_back(lnot(stmt_var));
    }
  return land(stmts);
}
\end{lstlisting}

% \todo[inline]{add another virtual member to \lstCPP{Instruction} class to dynamically dispatch encoding functions}

\noindent
% The next state functions, responsible for defining the successors when executing a certain instruction, are implemented by including yet another virtual member function to the \lstCPP{Instruction} class.
% Analogously to the encoding functions responsible for defining a specific next state
% by dynamically dispatching the according encoding function.
% Generating the next state for each possible instruction
% Encoding the common set of next states for every possible instruction
% Generating the common set of successor states for every possible instruction according to our relational encoding scheme
Generating a common set of successor states for every possible instruction %according to our relational encoding scheme
% according to our relational logic
% again relies on
is again based on
dynamically dispatched virtual member functions of concrete \lstCPP{Instruction} class instantiations.
% dispatched member functions achieved by adding the following virtual member function to the \lstCPP{Instruction} class
% We therefore introduce
Therefore, we introduce the following overload including the current program counter for activating the next statement. % and their actual implementations given below.

% \todo[inline]{adding the following virtual member function to the \lstCPP{Instruction} class and their concrete implementations given below}
% \todo[inline]{including its program counter to activate successor statements}

% \lstCPP{virtual std::string Instruction::encode (uint t, uint k, uint pc) = 0;}
\begin{lstlisting}[style=c++]
virtual std::string Instruction::encode (uint t, uint k, uint pc) = 0;
\end{lstlisting}

% \todo[inline]{encode LOAD (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
By using the previously defined helper constructs, the actual implementations can be \CHANGE{simplified} quite drastically and % are given below. % of every instruction's encoding function
% The actual implementations are given below and can be simplified quite drastically by using the previously defined helper constructs.
% The actual implementations can be simplified quite drastically by using the previously defined helper constructs and are given below.
\CHANGE{even though they therefore almost look the same, we include the full definitions for completeness.}

\newpage

\defencode{\lstASM{LOAD arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Load::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode STORE (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{STORE arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Store::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::adr] = equal(adr(k, t), encode(k - 1, t, State::adr));
  next[State::val] = equal(val(k, t), encode(k - 1, t, State::val));
  next[State::full] = full(k, t);
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode FENCE (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{FENCE}}
\begin{lstlisting}[style=c++, style=encode]
std::string Fence::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode ADD (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{ADD arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Add::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode ADDI (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{ADDI arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Addi::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode SUB (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{SUB arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Sub::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode SUBI (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{SUBI arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Subi::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode MUL (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{MUL arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Mul::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode MULI (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{MULI arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Muli::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode CMP (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{CMP arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Cmp::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JMP (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JMP arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jmp::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, arg);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JZ (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JZ arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jz::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JNZ (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{JNZ arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jnz::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Js::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JNS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JNS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jns::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode JNZNS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{JNZNS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Jnzns::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc, this);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode MEM (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{MEM arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Mem::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::mem] = equal(mem(k, t), encode(k - 1, t, State::mem));
  next[State::stmt] = activate(k, t, pc + 1);
  return next;
}
\end{lstlisting}

% \todo[inline]{encode CAS (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{CAS arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Cas::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::accu] = equal(accu(k, t),
                            encode(k - 1, t, State::accu));
  next[State::stmt] = activate(k, t, pc + 1);
  next[State::heap] = equal(heap(k),
                            encode(k - 1, t, State::heap));
  return next;
}
\end{lstlisting}

% \todo[inline]{encode CHECK (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{CHECK arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Check::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, pc + 1);
  std::vector<std::string> blocks;
  for (const auto & [id, threads] : checkpoints)
    if (threads.find(t) != threads.end())
      blocks.push_back(id == op.arg
                         ? block(k, id, t)
                         : reset(&block, &check, k, id, t));
  next[State::block] = land(blocks);
  return state;
}
\end{lstlisting}

\noindent
\CHANGE{Since a thread might wait for different checkpoints},
% Since the might be multiple checkpoints per thread,
the encode function has to enable the corresponding blocking flag $\BLOCK^k_{id, t}$ while preserving or resetting any other.

% \todo[inline]{encode HALT (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\defencode{\lstASM{HALT}}
\begin{lstlisting}[style=c++, style=encode]
std::string Halt::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, -1);
  if (programs.size() > 1)
    {
      std::vector<std::string> args;
      for (uint thread = 0; thread < programs.size(); thread++)
        if (thread != t)
          args.push_back(halt(k, thread));
      next[State::halt] =
        land(halt(k, t),
             ite(land(args),
                 land(exit(k), equal(exit_code, consth(0))),
                 lnot(exit(k))));
    }
  else
    next[State::halt] = land(halt(k, t),
                             exit(k),
                             equal(exit_code, consth(0))));
  state.erase(state.find(State::exit));
  return state;
}
\end{lstlisting}

\noindent
% Setting a thread's halt flag $\HALT^k_t$
% Stopping the machine if all halt flags $\HALT^k_t$ are set, we have to distinguish between single and multi threaded programs.
Stopping the machine if all threads halted is achieved by an $\ITE$, enabling the exit flag $\EXIT^k$ and assigning the default exit code if all halt flags $\HALT^k_t$ are set.
Otherwise, the exit flag is disabled to continue execution.
% In case only a single thread is running, the exit variables can be
Since the exit flag is now already contained in the \lstCPP{State::halt} entry, we have to erase \lstCPP{State::exit} to prevent conflicts due to its falsification. %, leading to a conflict.

% \todo[inline]{encode EXIT (relational)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defencode{\lstASM{EXIT arg}}
\begin{lstlisting}[style=c++, style=encode]
std::string Exit::encode (uint t, uint k, uint pc)
{
  Next next(k, t);
  next[State::stmt] = activate(k, t, -1);
  next[State::exit] = exit(k);
  next[State::exit_code] = equal(exit_code,
                                 encode(t, k, State::exit_code));
  return state;
}
\end{lstlisting}

\newpage

% \todo[inline]{imply thread executed} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \noindent
% Before we continue with the main functions, implying the next states for each transition,
% wrapper used to generate the assertions for implying the next states of a given transition.

% \begin{lstlisting}[style=c++]
% std::string imply_next (std::string var, std::string state)
% {
  % return assertion(imply(var, state));
% }
% \end{lstlisting}

\noindent
% With all utility constructs and instruction related encoding functions being defined, we are now able to generate the actual implications, starting with the successor states after executing any given statement.
With all utility constructs and instruction related encoding functions defined, we are now able to imply the next states for all transitions, starting with the execution of any given statement.
% Execution of a certain statement, signalled by $\EXEC^{k - 1}_{t, pc}$,
% Starting with the implication of successor states of
% using the previously defined enconding functions.

% // smtlib::Relational::imply_thread_executed -----------------------------------
% //
% // thread t executed an instruction (exec_k_t_pc):
% // * update thread state accordingly
% // * restore heap (or update upon a successful CAS)
% // * unset exit flag iff neither an EXIT, nor a HALT
% // * set exit code iff the instruction was an EXIT
\begin{lstlisting}[style=c++]
void imply_thread_executed (uint k, uint t)
{
  for (uint pc = 0; pc < programs[t].size(); pc++)
    formula << assertion(imply(exec(k - 1, t, pc),
                               programs[t][pc]->encode(k, t, pc)))
            << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{imply_thread_executed(1, 0)}

\begin{lstlisting}[style=smtlib]
(assert (=> exec_0_0_0 ; ADDI 1
            (and (= accu_1_0 (bvadd accu_0_0 #x0001))
                 (= mem_1_0 mem_0_0)
                 (= adr_1_0 adr_0_0)
                 (= val_1_0 val_0_0)
                 (= full_1_0 full_0_0)
                 (and (not stmt_1_0_0)
                           stmt_1_0_1
                      (not stmt_1_0_2)
                      (not stmt_1_0_3)
                      (not stmt_1_0_4))
                 (= block_1_0_0 (ite check_0_0 false block_0_0_0))
                 (= halt_1_0 halt_0_0)
                 (= heap_1 heap_0)
                 (not exit_1))))
(assert (=> exec_0_0_1 ; STORE 0
            (and (= accu_1_0 accu_0_0)
                 (= mem_1_0 mem_0_0)
                 (= adr_1_0 #x0000)
                 (= val_1_0 accu_0_0)
                 full_1_0
                 (and (not stmt_1_0_0)
                      (not stmt_1_0_1)
                      stmt_1_0_2
                      (not stmt_1_0_3)
                      (not stmt_1_0_4))
                 (= block_1_0_0 (ite check_0_0 false block_0_0_0))
                 (= halt_1_0 halt_0_0)
                 (= heap_1 heap_0)
                 (not exit_1)))) ...
\end{lstlisting}

% \todo[inline]{imply thread not executed} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
% In case a thread was not executed, all local states must be preserved, except the store
% In case a thread is not executed, it still might flush it's store buffer, % or have a block flag reset by another thread executing the corresponding checkpoint's final \lstASM{CHECK} instruction.
% or is released from a checkpoint if another thread just executed the corresponding \lstASM{CHECK} instruction.
% All local thread states are therefore preserved, while the store buffer full flag $\SBFULL^k_t$ and any block flag $\BLOCK^k_{id, t}$ might be reset.
% while preserving all local states.
% >>>
% In case a thread was not executed in the previous step, all local states must be preserved, while the store buffer full flag $\SBFULL^k_t$ and block flags $\BLOCK^k_{id, t}$ might be reset by a store buffer flush or due to being released from a checkpoint if another thread executed the corresponds \lstASM{CHECK} instruction.
In case a thread was not executed in the previous step, all local states must be preserved except the store buffer full flag $\SBFULL^k_t$ and block flags $\BLOCK^k_{id, t}$, as they might be reset by a store buffer flush, or due to being released from a checkpoint if another thread executed the corresponds \lstASM{CHECK} instruction.

% // imply_thread_not_executed
% //
% // thread t didn't execute an instruction (not thread_k_t):
% // * preserve thread state
% // * reset full iff the thread's store buffer has been flushed
\begin{lstlisting}[style=c++]
void imply_thread_not_executed (uint k, uint t)
{
  Next next(k, t);
  next[State::full] = reset(&full, &flush, k, t);
  std::vector<std::string> stmts;
  for (uint pc = 0; pc < programs.size(); pc++)
    stmts.push_back(restore(&stmt, k, t, pc));
  next[State::stmt] = land(stmts);
  next.erase(next.find(State::heap));
  next.erase(next.find(State::exit));

  formula << assertion(imply(lnot(thread(k - 1, t)), next)) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{imply_thread_not_executed(1, 0)}

\begin{lstlisting}[style=smtlib]
(assert (=> (not thread_0_0)
            (and (= accu_1_0 accu_0_0)
                 (= mem_1_0 mem_0_0)
                 (= adr_1_0 adr_0_0)
                 (= val_1_0 val_0_0)
                 (= full_1_0 (ite flush_0_0 false full_0_0))
                 (and (= stmt_1_0_0 stmt_0_0_0)
                      (= stmt_1_0_1 stmt_0_0_1)
                      (= stmt_1_0_2 stmt_0_0_2)
                      (= stmt_1_0_3 stmt_0_0_3)
                      (= stmt_1_0_4 stmt_0_0_4))
                 (= block_1_0_0 (ite check_0_0 false block_0_0_0))
                 (= halt_1_0 halt_0_0))))
\end{lstlisting}

% \todo[inline]{imply thread flushed} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\noindent
% Since all thread states are already handeled,
With all local thread states already being set,
% Since resetting the store buffer full flag $\SBFULL^k_t$ is already handeled by the previous function,
% a thread flushing it's store buffer only needs to set the relevant global machine states, namely writing the heap array $\HEAP^k$ and disabling the exit flag $\EXIT^k$ to continue execution.
% a thread flushing it's store buffer
a store buffer flush
% only needs to write the heap array $\HEAP^k$ and disable the exit flag $\EXIT^k$ to continue executing.
% just writes the heap array $\HEAP^k$ and disables the exit flag $\EXIT^k$ to continue execution.
just needs to write the heap array $\HEAP^k$ and disable the exit flag $\EXIT^k$ to continue execution.
% continue execution by disabling the exit flag $\EXIT^k$.

% // imply_thread_flushed
% //
% // thread t flushed its store buffer (flush_k_t):
% // * update heap
% // * unset exit flag
\begin{lstlisting}[style=c++]
void imply_thread_flushed (uint k, uint t)
{
  formula << assertion(imply(flush(k - 1, t),
                             land(equal(heap(k),
                                        store(heap(k - 1),
                                              adr(k - 1, t),
                                              val(k - 1, t)))
                                  lnot(exit(k))))) << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{imply_thread_flushed(1, 0)}

\begin{lstlisting}[style=smtlib]
(assert (=> flush_0_0
            (and (= heap_1 (store heap_0 adr_0_0 val_0_0))
                 (not exit_1))))
\end{lstlisting}

% \todo[inline]{imply machine exited} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
Finally, to keep the model consistent if the machine terminated in a step $k < bound$, the heap array $\HEAP^{k - 1}$ must be preserved.
% On the other hand, if the machine still has not exited in the final step, the exit code needs to be set since it would remain undefined.
On the other hand, if the machine is still running in the final step,
% the exit code needs to be set since it would remain undefined.
we need to set the default exit code as it would otherwise remain undefined.

% // imply_machine_exited
% //
% // machine exited (exit_k):
% // * preserve exit flag
% // * preserve heap
% // * set exit code to zero iff machine never exited (step == bound)
\begin{lstlisting}[style=c++]
void imply_machine_exited (uint k)
{
  formula << assertion(imply(exit(k - 1),
                             land(restore(&heap, k),
                                  exit(k)))) << '\n';
  if (k == bound)
    formula << assertion(imply(lnot(exit(k)),
                               equal(exit_code, consth(0))))
            << '\n';
}
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{imply_machine_exited(1, 0)}

\begin{lstlisting}[style=smtlib]
(assert (=> exit_0 (and (= heap_1 heap_0) exit_1)))
\end{lstlisting}

\noindent
\emph{Example:} \lstCPP{imply_machine_exited(17, 0)}

\begin{lstlisting}[style=smtlib]
(assert (=> exit_16 (and (= heap_17 heap_16) exit_17)))
(assert (=> (not exit_17) (= exit-code #x0000)))
\end{lstlisting}

