\newcommand{\EncoderStatsTable}[3]{
  \begin{table}[!hbt]
  \noindent\makebox[\textwidth]{
  \footnotesize
  \centering
  \begin{tabu}{|c|X[r]|X[r]|X[r]|X[r]|X[r]|X[r]|}
    \tabucline{2-}
    \multicolumn{1}{c|}{}
      & \multicolumn{2}{c|}{\textbf{btor2}}
      & \multicolumn{2}{c|}{\textbf{functional}}
      & \multicolumn{2}{c|}{\textbf{relational}} \\
    \tabucline{2-}
    \multicolumn{1}{c|}{}
      & \multicolumn{1}{c|}{time}
      & \multicolumn{1}{c|}{size}
      & \multicolumn{1}{c|}{time}
      & \multicolumn{1}{c|}{size}
      & \multicolumn{1}{c|}{time}
      & \multicolumn{1}{c|}{size} \\
    \tabucline{2-}
    \firsthline
    \csvreader
      [late after line=\\] %, separator=pipe]
      {#1}
      {1=\A, 2=\B, 3=\C, 4=\D, 5=\E, 6=\F, 7=\G}
      {\StatsTableRowHeader{\A} & \B & \C & \D & \E & \F & \G}
    \lasthline
  \end{tabu}}
  \caption{#3}
  \label{#2}
  \end{table}
}

\newcommand{\CleanInf}[1]{\IfStrEq{#1}{inf}{-}{#1}}

\newcommand{\SolverStatsTable}[3]{
  \begin{table}[!hbt]
  \noindent\makebox[\textwidth]{
  \footnotesize
  \centering
  \begin{tabu}{|c|X[r]|X[r]|X[r]|X[r]|X[r]|X[r]|X[r]|}
    \tabucline{2-}
    \multicolumn{1}{c|}{}
      & \multicolumn{1}{c|}{\textbf{BtorMC}}
      & \multicolumn{2}{c|}{\textbf{Boolector}}
      & \multicolumn{2}{c|}{\textbf{Z3}}
      & \multicolumn{2}{c|}{\textbf{CVC4}} \\
    \tabucline{2-}
    \multicolumn{1}{c|}{}
      & \multicolumn{1}{c|}{\scriptsize btor2}
      & \multicolumn{1}{c|}{\scriptsize functional}
      & \multicolumn{1}{c|}{\scriptsize relational}
      & \multicolumn{1}{c|}{\scriptsize functional}
      & \multicolumn{1}{c|}{\scriptsize relational}
      & \multicolumn{1}{c|}{\scriptsize functional}
      & \multicolumn{1}{c|}{\scriptsize relational} \\
    \tabucline{2-}
    \firsthline
    \csvreader
      [late after line=\\] %, separator=pipe]
      {#1}
      {1=\A, 2=\B, 3=\C, 4=\D, 5=\E, 6=\F, 7=\G, 8=\H}
      {\StatsTableRowHeader{\A} & \CleanInf{\B} & \CleanInf{\C} & \CleanInf{\D} & \CleanInf{\E} & \CleanInf{\F} & \CleanInf{\G} & \CleanInf{\H}}
    \lasthline
  \end{tabu}}
  \caption{#3}
  \label{#2}
  \end{table}
}

\pgfplotsset{filter discard warning=false}
\tikzset{every mark/.append style={solid}}

\newcommand{\EncoderStatsGraph}[4]{
  \begin{figure}[!hbt]
    \footnotesize
    \centering
    \begin{tikzpicture}
      \pgfplotstableread[col sep=comma]{#1}{\Data}
      \begin{axis}[
        width=\textwidth,
        height=\axisdefaultheight + 16,
        grid=major,
        grid style={dashed,gray!30},
        % xlabel=X axis,
        % ylabel=Y axis,
        % ymode=log,
        % x tick label style={rotate=90,anchor=east},
        scaled ticks=false,
        x tick label style={anchor=north},
        y tick label style={/pgf/number format/.cd,fixed,1000 sep={\,}},
        xticklabels from table={\Data}{experiment},
        xtick=data,
        % filter discard warning=false,
        legend style={
          % draw=none,
          % at={(0.0,-0.1)},
          % anchor=north west,
          % at={(0.0,1.05)},
          % anchor=south west,
          font=\scriptsize,
          legend cell align=left,
          % legend pos=outer north east,
          legend pos=#2,
        },
      ]
      \addplot [black, mark=diamond*] table [x expr=\coordindex, y index=2] {\Data};
      \addlegendentry{\BTOR}
      \addplot [blue, mark=*] table [x expr=\coordindex, y index=4] {\Data};
      \addlegendentry{{\SMTLIB} (functional)}
      \addplot [red, mark=square*] table [x expr=\coordindex, y index=6] {\Data};
      \addlegendentry{{\SMTLIB} (relational)}
      \end{axis}
    \end{tikzpicture}
    \caption{#3}
    \label{#4}
  \end{figure}
}

\newcommand{\SolverStatsGraph}[4]{
  % https://texwelt.de/fragen/22222/pgfplots-x-achse-mit-strings
  \begin{figure}[!hbt]
    \small
    \centering
    \begin{tikzpicture}
      \pgfplotstableread[col sep=comma]{#1}{\Data}
      \begin{axis}[
        width=\textwidth,
        height=\axisdefaultheight + 16,
        grid=major,
        grid style={dashed,gray!30},
        % xlabel=X axis,
        % ylabel=Y axis,
        ymode=log,
        % x tick label style={rotate=90,anchor=east},
        x tick label style={anchor=north},
        xticklabels from table={\Data}{experiment},
        xtick=data,
        % filter discard warning=false,
        legend style={
          % draw=none,
          % at={(0.0,-0.1)},
          % anchor=north west,
          % at={(0.0,1.05)},
          % anchor=south west,
          font=\scriptsize,
          legend cell align=left,
          % legend pos=outer north east,
          legend pos=#2,
        },
      ]
      \addplot [black, mark=diamond*] table [x expr=\coordindex, y index=1] {\Data};
      \addlegendentry{BtorMC}
      \addplot [thick, dotted, blue, mark=*] table [x expr=\coordindex, y index=2] {\Data};
      \addlegendentry{Boolector (functional)}
      \addplot [thick, dotted, blue, mark=square*] table [x expr=\coordindex, y index=3] {\Data};
      \addlegendentry{Boolector (relational)}
      \addplot [dashed, red, mark=*] table [x expr=\coordindex, y index=4] {\Data};
      \addlegendentry{Z3 (functional)}
      \addplot [dashed, red, mark=square*] table [x expr=\coordindex, y index=5] {\Data};
      \addlegendentry{Z3 (relational)}
      \addplot [dashdotted, brown, mark=*] table [x expr=\coordindex, y index=6] {\Data};
      \addlegendentry{CVC4 (functional)}
      \addplot [dashdotted, brown, mark=square*] table [x expr=\coordindex, y index=7] {\Data};
      \addlegendentry{CVC4 (relational)}
      \end{axis}
    \end{tikzpicture}
    \caption{#3}
    \label{#4}
  \end{figure}
}

%------------------------------------------------------------------------------%

\section{Experiments}

To asses performance related aspects of our encodings,
we conducted a series of experiments, using the following versions of supported SMT solvers.
%a series of experiments have been conducted and
%
% show validity of Appendix \ref{appendix:litmus:intel}
% asses performance of our encodings by comparing the runtimes of all supported solvers
%
% Appendices \ref{appendix:litmus:intel} and \ref{appendix:litmus:amd}
%
% \todo[inline]{solver versions}
%
% \begin{table}[!hbt]
  % \centering
% \bigbreak
  % \begin{tabu}{lll}
    % % Solver & Version \\
    % % \hline
    % Boolector & 3.2.1 & \url{https://github.com/Boolector/boolector} \\
    % CVC 4 & 1.8 & \url{https://github.com/CVC4/CVC4} \\
    % Z3 & 4.8.9 & \url{https://github.com/Z3Prover/z3} \\
  % \end{tabu}
% % \bigbreak
% \end{table}
%
\begin{itemize}
  \item Boolector 3.2.1 (including BtorMC, using CaDiCaL 1.0.3) %\footnote{\url{https://github.com/Boolector/boolector}}
  \item CVC4 1.8 %\footnote{\url{https://github.com/CVC4/CVC4}}
  \item Z3 4.8.9 %\footnote{\url{https://github.com/Z3Prover/z3}}
\end{itemize}
%
% Intel(R) Xeon(R) E5-2620 v4 @ 2.10GHz
% All tests were performed on a cluster of Intel\textsuperscript{\textregistered} Xeon\textsuperscript{\textregistered} E5-2620 v4 nodes, where runtime and memory usage were limited to 86400 seconds (24 hours) and 8 GB respectively.

We recorded the resulting formula sizes in terms of the number of generated expression, as well as the runtimes for encoding and solving each particular instance.
All tests were performed on a cluster of Intel\textsuperscript{\textregistered} Xeon\textsuperscript{\textregistered} E5-2620 v4 nodes, with CPU runtime and memory usage limited to 86400 seconds (24 hours) and 8 GB respectively.

% The x86-TSO memory-ordering model (used by AMD and Intel) is defined by a set of litmus tests.
% To show equivalence of ConcuBinE-TSO and x86-TSO, the tests have been ported to ConcuBinE.

\subsection*{Litmus Tests}

Instead of a rigorous formal description, the memory-ordering models of Intel's \cite{ref:Intel} and AMD's \cite{ref:AMD} x86 implementations are defined by a set of litmus tests.
%, given in the according software developer's manuals \cite{ref:Intel, ref:AMD}.
In order to show their conformance with the memory-ordering principles of our virtual machine model, all documented litmus tests have been ported to ConcuBinE and are explained in Appendices \ref{appendix:litmus:intel} and \ref{appendix:litmus:amd}.

% \subsubsection*{Intel}

% \newcommand{\StatsTableRowHeader}[1]{\StrBehind[2]{#1}{:}}
% \newcommand{\StatsTableRowHeader}[1]{\ref{tbl:#1}}
% \newcommand{\StatsTableRowHeader}[1]{\hyperref[tbl:#1]{\StrBehind[2]{#1}{:}}}
\newcommand{\StatsTableRowHeader}[1]{\hyperref[tbl:litmus:intel:#1]{#1}}

% \todo[inline]{table - encoding stats - litmus intel}

\EncoderStatsTable
  {figures/litmus-intel-encoder.csv}
  {tbl:litmus:intel:encoder}
  {Intel litmus test encoding times in milliseconds and formula sizes as the number of expressions.}
  % {Intel Litmus Test Econding Time [ms] and Size [\#expressions]}

\EncoderStatsGraph
  {figures/litmus-intel-encoder.csv}
  {north west}
  {Caption.}
  {fig:litmus:intel:encoder}

\newpage
\noindent
Table \ref{tbl:litmus:intel:encoder} shows the runtimes and formula sizes for encoding Intel's litmus test suite.

% \todo[inline]{table - solving times - litmus intel}

\newpage

\SolverStatsTable
  {figures/litmus-intel-solver.csv}
  {tbl:litmus:intel:solver}
  {Intel litmus test solving times in seconds.}
  % {Intel Litmus Test Solving Times in Seconds}

\SolverStatsGraph
  {figures/litmus-intel-solver.csv}
  {north west}
  {Caption.}
  {fig:litmus:intel:solver}

\newpage

\subsubsection*{AMD}

% \todo[inline]{table - encoding stats - litmus amd}
\renewcommand{\StatsTableRowHeader}[1]{\hyperref[tbl:litmus:amd:#1]{#1}}

\EncoderStatsTable
  {figures/litmus-amd-encoder.csv}
  {tbl:litmus:amd:encoder}
  {AMD litmus test encoding times in milliseconds and formula sizes as the number of expressions.}
  % {AMD Litmus Test Econding Time [ms] and Size [\#expressions]}

\EncoderStatsGraph
  {figures/litmus-amd-encoder.csv}
  {north west}
  {Caption.}
  {fig:litmus:amd:encoder}

\newpage
\todo[inline]{table - solving times - amd}

\SolverStatsTable
  {figures/litmus-amd-solver.csv}
  {tbl:litmus:amd:solver}
  {AMD litmus test solving times in seconds.}
  % {AMD Litmus Test Solving Times in Seconds}

\SolverStatsGraph
  {figures/litmus-amd-solver.csv}
  {north west}
  {Caption.}
  {fig:litmus:amd:solver}

\newpage

\subsection*{Statistical Counter}

\subsubsection*{Buggy}

% \renewcommand{\StatsTableRowHeader}[1]{%
% \StrBehind{#1}{:}[\SplitColon]%
% \StrBehind{\SplitColon}{.}[\SplitDot]%
% \StrSubstitute{\SplitDot}{.}{ }%
% }
\renewcommand{\StatsTableRowHeader}[1]{#1}

\todo[inline]{table - encoding stats - count buggy}

\EncoderStatsTable
  {figures/count-buggy-encoder.csv}
  {tbl:count:buggy:encoder}
  {Econding Time [ms] and Size [\#expressions]}

\EncoderStatsGraph
  {figures/count-buggy-encoder.csv}
  {north west}
  {Caption.}
  {fig:count:buggy:encoder}

\newpage
\todo[inline]{table - solving times - count buggy}

\SolverStatsTable
  {figures/count-buggy-solver.csv}
  {tbl:count:buggy:solver}
  {Solving Times in Seconds}

\todo[inline]{graphs}

\SolverStatsGraph
  {figures/count-buggy-solver.csv}
  {south east}
  {Caption.}
  {fig:count:buggy:solver}

\newpage

\subsubsection*{CAS}

\todo[inline]{table - encoding stats - count cas}

\EncoderStatsTable
  {figures/count-cas-encoder.csv}
  {tbl:count:cas:encoder}
  {Econding Time [ms] and Size [\#expressions]}

\EncoderStatsGraph
  {figures/count-cas-encoder.csv}
  {north west}
  {Caption.}
  {fig:count:cas:encoder}

\newpage
\todo[inline]{table - solving times - coubt cas}

\SolverStatsTable
  {figures/count-cas-solver.csv}
  {tbl:count:cas:solver}
  {Solving Times in Seconds}

\SolverStatsGraph
  {figures/count-cas-solver.csv}
  {south east}
  {Caption.}
  {fig:count:cas:solver}
